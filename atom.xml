<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>darryrzhong</title>
  
  <subtitle>时光，不会辜负每一个平静努力的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://darryrzhong.xyz/"/>
  <updated>2020-03-09T04:45:59.000Z</updated>
  <id>http://darryrzhong.xyz/</id>
  
  <author>
    <name>darryrzhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 内存优化篇 - 使用profile 和 MAT 工具进行内存泄漏检测</title>
    <link href="http://darryrzhong.xyz/2020/03/09/Android-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E7%AF%87-%E4%BD%BF%E7%94%A8profile-%E5%92%8C-MAT-%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/"/>
    <id>http://darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/</id>
    <published>2020-03-09T04:44:28.000Z</published>
    <updated>2020-03-09T04:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在 Android 开发中，内存泄漏这个名词我想大家都不陌生，但是真正注意到这个问题并去解决的估计很少，因为内存泄漏表面上并不会表现出对app的任何影响，加之现在的手机配置与内存都挺高的，所以对于中小型app来说，可能不怎么去处理也几乎看不出来，但是作为一名android 开发者，你肯定和我一样不能忍受这种瑕疵吧，那 就撸起袖子干它就完事了</p></blockquote><h2 id="内存抖动-amp-内存泄漏-amp-内存溢出（OOM）"><a href="#内存抖动-amp-内存泄漏-amp-内存溢出（OOM）" class="headerlink" title="内存抖动 &amp; 内存泄漏 &amp; 内存溢出（OOM）"></a>内存抖动 &amp; 内存泄漏 &amp; 内存溢出（OOM）</h2><h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><blockquote><p>含义：短时间内有大量对象创建销毁，它伴随着频繁的GC。</p></blockquote><ol><li><p>查看：可以使用android studio自带的profile工具检测。</p></li><li><p>现象：在profile中的内存图像就像是心电图一样，忽上忽下，如下图所示：</p></li></ol><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506380.png" alt="image"></p><ol start="3"><li><p>常见场景：循环使用字符串拼接，比如我们项目的日志打印等</p></li><li><p>预防内存抖动方法：</p></li></ol><ul><li>避免在循环中创建对象，能复用的尽量复用。</li><li>避免在频繁调用的方法中创建对象，如自定义view中的onDraw（）等方法中创建画笔。</li><li>获取对象尽量从对象池中获取，如Handler获取Message对象应使用obtain（）方法获取了。</li><li></li></ul><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><blockquote><p>程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。<br>长生命周期对象持有短生命周期对象强引用，从而导致短生命周期对象无法被回收！</p></blockquote><ol><li><p>查看：使用profile工具检测内存情况，重复执行进入然后退出一个activity，看activity实例是否还存在。如果activity实例还存在，很可能就出现了内存泄漏。</p></li><li><p>现象：反复进入A，然后退出A ，执行三次，可以看到A 的实例存在两个。如下图，VideoPlayerActivity：</p></li></ol><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506297.png" alt="image"></p><p>这就说明我们的activity并没有被销毁，至少目前是这样的。至于究竟会不会内存泄漏，就需要接下来使用另一款工具配合使用了。</p><a id="more"></a><ol start="3"><li>如何判断内存泄漏:</li></ol><ul><li>使用可达性分析法</li></ul><blockquote><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所有的引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。也就会被回收。</p></blockquote><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506298.png" alt="image"></p><ol start="4"><li><p>何为GC Roots 对象，一般静态变量就是gc root对象，可以理解成生命周期很长的对象。</p></li><li><p>如何预防内存泄漏：</p></li></ol><ul><li><p>使用 软引用、弱引用间接的持有对象的引用。</p></li><li><p>软引用：</p></li></ul><blockquote><p>定义一些还有用但并非必须的对象。对于软引用关联的对象，GC不会直接回收，而是在系统将要内存溢出之前才会触发GC将这些对象进行回收。</p></blockquote><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506219.png" alt="image"></p><ul><li>弱引用 ：</li></ul><blockquote><p>同样定义非必须对象。被弱引用关联的对象在GC执行时会被直接回收。</p></blockquote><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506714.png" alt="image"></p><ol start="6"><li>造成内存泄漏的常见场景：</li></ol><ul><li>使用集合时，例如add一个监听器，我们必须要手动remove掉。</li><li>使用静态成员变量/单利对象时，如果持有短生命周期对象的引用（Activity）将导致短生命周期对象无法被释放。</li><li>进行文件io操作时，没有close（）。最好写在finally{ }里面；</li><li>android 系统bug、第三方类库造成的内存泄漏。</li></ul><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><blockquote><p>内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出，有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件</p></blockquote><ul><li>频繁的出现内存抖动或者大量内存泄漏很有可能就会导致内存溢出（OOM）。</li></ul><h2 id="Android-中的垃圾回收器-CMS"><a href="#Android-中的垃圾回收器-CMS" class="headerlink" title="Android 中的垃圾回收器 CMS"></a>Android 中的垃圾回收器 CMS</h2><blockquote><p> android 中使用的垃圾回收器 叫做CMS ,下面简单介绍下他的垃圾回收算法。</p></blockquote><ul><li>新生代对象</li></ul><p>新生代对象采用的是复制算法，当大对象也可能直接进入老年代。</p><ul><li>老年代对象 </li></ul><p>老年代对象采用的是标记-清除算法，所以频繁的内存抖动，会造成内存碎片化，最后可能我们需要加载一个大对象的时候，就OOM 了。</p><p>简单介绍下CMS垃圾回收算法，如果不熟悉的建议请先百度jvm 垃圾回收机制相关知识。</p><h2 id="实战-内存泄漏"><a href="#实战-内存泄漏" class="headerlink" title="实战 内存泄漏"></a>实战 内存泄漏</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ul><li>android studio </li><li>eclipse memory analyzer (mat)</li></ul><h4 id="下载mat"><a href="#下载mat" class="headerlink" title="下载mat"></a>下载mat</h4><ul><li><a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">下载地址点我</a></li></ul><p>选择相应版本进行下载安装。</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506368.png" alt="image"></p><ul><li>配置mat 环境，因为从 android profile直接获取到的hprof文件格式与mat的格式不兼容，所以需要使用工具转换一下</li></ul><blockquote><p>win 环境配置，请自行百度，由于本人用的Mac 所以这里只写Mac的配置</p></blockquote><ol><li>打开终端输入：echo $HOME</li><li>继续输入：touch .bash_profile</li><li>继续输入： open -e .bash_profile</li><li>在打开的bash文件中输入： export PATH=${PATH}:/Users/用户名/你的sdk路径/platform-tools</li><li>最后输入： source .bash_profile</li><li>没有6了，已经成功配置了。</li></ol><h3 id="使用profile获取内存分析文件"><a href="#使用profile获取内存分析文件" class="headerlink" title="使用profile获取内存分析文件"></a>使用profile获取内存分析文件</h3><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506241.png" alt="image"></p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506297-3729106.png" alt="image"></p><p>名字随便了，怎么方便怎么来</p><p>打开终端，进行文件转换 </p><p>转换格式 ： hprof-conv before.hprof after.hprof  </p><p>我们这里输入 ： hprof-conv memory-99.hprof 66.hprof<br>能看懂吧，吧我们的源文件 -99 转换成 -66文件，</p><blockquote><p>注意了 ： 需要进入-99 所在的文件目录，要不然会报错找不到文件</p></blockquote><p>打开mat工具，导入我们的-66 文件</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506340.png" alt="image"></p><p>打开后可以看到这样的界面</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506336.png" alt="image"></p><p>点击红框的选项，这个是进行内存泄漏分析的</p><p>下面就是这段时间所产生的对象，点击红框 可以直接搜索你要分析的对象</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506348.png" alt="image"></p><p>这里找到了我们的VideoPlayerActivity</p><p>鼠标右键选择</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506414-3729106.png" alt="image"></p><p>可以看到，意思就是我们排除掉软、弱、虚引用，因为这几种是不会造成内存泄漏的，可以不用管它，我们只需要看排除后还有没引用存在，有的话 那就是强引用了，也就发生了内存泄漏了。</p><p>继续看我们的结果：</p><p>点击后，发现里面存在数据，那就说明我们有内存泄漏发生了，也就是为什么上面我们已经退出了，profile里面还有三个activity的存在，刚刚上面那张图右侧也有显示有3个activity对象存在。</p><p>我们一一展开，看看到底哪里内存泄漏了</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506406.png" alt="image"></p><p>可以看到，我们的Avtivity 作为mContext 变量被我们的自定义CoverVideoPlayerView 持有了，那也就是说，因为我们的自定义View不能被gc回收，所以activity也无法被回收。</p><p>那就继续看，为什么自定义view无法被回收，可以看到，this$0，这表示在自定义view的内部有一个非静态内部类，而非静态内部类是默认持有外部类的引用的，也就是我们的，mNetChangeListener对象，这个就熟悉了吧，肯定是new 一个匿名内部类啊，</p><p>继续看，这个内部类又被NetInfoModeule引用了，我丢，然后继续往上看，我就不看了，你自己看吧</p><p>我去喝杯水，你慢慢看吧</p><p>啥？ 我喝完回来了，你还没看完呢？ 那还是我们一起看吧，</p><p>继续往上的话，可以看到 NetInfoModeule又被什么xxxxxBroadcastReceiver 引用了，那不就是广播吗? 猜想，肯定又是一个非静态内部类了，在往上看</p><p>咳咳，别看了，上面和我们没啥关系了，全是系统在搞事情了，</p><p>通过上面一波分析，我们应该清楚了，泄漏的原因了，</p><p>然后梳理一下：</p><p>VideoPlayerActivity -&gt; mContext -&gt; CoverVideoPlayerView -&gt; mNetChangeListener -&gt;  NetInfoModeule -&gt; xxxxxBroadcastReceiver;</p><p>引用链找到了，所以，我们把链条给整段了，就不会内存泄漏了啊</p><p>怎么段呢？</p><p>最简单的方式： 假如啊 ，这些个不靠谱的代码都是你自己写的，那好办</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在activity 的onDestory（）方法中加上，</span><br><span class="line"></span><br><span class="line">1.CoverVideoPlayerView.;</span><br><span class="line"></span><br><span class="line">2.在CoverVideoPlayerView方法中，添加个cancel（）方法，</span><br><span class="line">加上  </span><br><span class="line">  mContext = null</span><br><span class="line">  mNetChangeListener = null；</span><br><span class="line">  NetInfoModeule = null；</span><br><span class="line">  然后广播记得unregister（）一下，这样不就完事了。</span><br></pre></td></tr></table></figure><p>嗯，一切都入想象的那般甜美，but，残酷的事实摆在眼前，这特么是第三方库的代码，你咋改？<br>下源码改? 得 ，可行是可行，那要是很多个库呢？ 你还下不？还改不？</p><p>算了，不改了，嗯也行，反正也好像没啥影响，而且我们的VideoPlayerActivity用的SingleTop 启动模式，<br>但是你如果用户不是在播放页面点击跳转的呢，退出再进来，退出再进来，最后十几个activity的实例，<br>连带着我们的model 、viewmodel 、统统都是十几份，你确定你不会被老大拿出去祭天？</p><p>界面如下：</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506437.png" alt="image"></p><p>那要怎么改呢? 你说说呗，</p><p>改当然能改了，那就是用java反射，通过反射去拿到对象，进行修改，</p><p>直接上代码吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 利用反射 解决gsy库中导致的内存泄漏</span><br><span class="line">   */</span><br><span class="line">  public void cancel()</span><br><span class="line">  &#123;</span><br><span class="line">      mAudioManager.abandonAudioFocus(onAudioFocusChangeListener);</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          // 拿到NetInfoModule对象中 mConnectivityBroadcastReceiver字段.</span><br><span class="line">          Field mConnectivityBroadcastReceiver = NetInfoModule.class</span><br><span class="line">              .getDeclaredField(&quot;mConnectivityBroadcastReceiver&quot;);</span><br><span class="line">          // 由于是私有字段,所以需要调用setAccessible(true),否则会报错</span><br><span class="line">          mConnectivityBroadcastReceiver.setAccessible(true);</span><br><span class="line">          // 根据当前mNetInfoModule对象的 mConnectivityBroadcastReceiver字段值为null</span><br><span class="line">          mConnectivityBroadcastReceiver.set(mNetInfoModule, null);</span><br><span class="line">          Field mNetChangeListener =</span><br><span class="line">              NetInfoModule.class.getDeclaredField(&quot;mNetChangeListener&quot;);</span><br><span class="line">          mNetChangeListener.setAccessible(true);</span><br><span class="line">          mNetChangeListener.set(mNetInfoModule, null);</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      catch (NoSuchFieldException e)</span><br><span class="line">      &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (IllegalAccessException e)</span><br><span class="line">      &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      mAudioManager = null;</span><br><span class="line">      mContext = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>好了，改完了，我们在来抓一下内存情况</p><p>直接上图：</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506407.png" alt="image"></p><p>看见没有，啥也没有了，说明我们的activiy再没有被其他对象引用了，说的不对，纠正一下，是没有被其他对象强引用了，而只要没有强引用关系，gc肯定能够回收的，自然你就也不需要担心内存泄漏了，</p><p>但是为什么还是会显示有3个activity对象存在呢？</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506414.png" alt="image"></p><p>那我们排除一下弱应用，看一看</p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506474.png" alt="image"></p><p><img src="//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506425.png" alt="image"></p><p>看见没有，这里有一个FinalizeRefernce对象，说明我们的activity被FinalizeRefernce对象所引用，而我们知道，只要一个对象将要被gc回收了，那么他就会被这个FinalizeRefernce所引用，这是为了让gc知道我们不需要这个对象了，你可以回收了，</p><p>所以我们的activity 虽然显示有两个，但是只是gc还没来的及回收而已，并没有内存泄漏的风险。</p><p>上面的例子是我的开源项目里的真实实例，感兴趣的可以前往支持 start 一下，</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><ul><li><h1 id="Android-MvvmComponent-App"><a href="#Android-MvvmComponent-App" class="headerlink" title="Android-MvvmComponent-App"></a><strong><a href="https://github.com/darryrzhong/Android-MvvmComponent-App" target="_blank" rel="noopener">Android-MvvmComponent-App</a></strong></h1></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>内存抖动的分析用profile工具完全就够用了，当然我们这里没有详讲怎么用profile分析解决内存抖动，之后有时间在补上吧。而我们的内存泄漏通过profile是不能看出他到底有没有发生内存泄漏的，所以我们还需要借助mat工具进一步分析。</p></blockquote><p>当然还有一些第三方的检测库，比较知名的比如leakCannary工具，腾讯的xxxdog，但是个人还是推荐使用mat来分析，mat操作起来也很方便，好了，今天就到这吧，感谢！</p><blockquote><p>欢迎关注作者<a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">darryrzhong</a>,更多干货等你来拿哟.</p></blockquote><h3 id="请赏个小红心！因为你的鼓励是我写作的最大动力！"><a href="#请赏个小红心！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请赏个小红心！因为你的鼓励是我写作的最大动力！"></a>请赏个小红心！因为你的鼓励是我写作的最大动力！</h3><blockquote><p>更多精彩文章请关注</p><ul><li><a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">个人博客:darryrzhong</a></li><li><a href="https://juejin.im/user/5a6c3b19f265da3e49804988" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/users/b7fdf53ec0b9/timeline" target="_blank" rel="noopener">简书</a></li><li><a href="https://segmentfault.com/u/darryrzhong_5ac59892a5882/articles" target="_blank" rel="noopener">SegmentFault</a></li><li><a href="https://www.imooc.com/u/6733207" target="_blank" rel="noopener">慕课网手记</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在 Android 开发中，内存泄漏这个名词我想大家都不陌生，但是真正注意到这个问题并去解决的估计很少，因为内存泄漏表面上并不会表现出对app的任何影响，加之现在的手机配置与内存都挺高的，所以对于中小型app来说，可能不怎么去处理也几乎看不出来，但是作为一名android 开发者，你肯定和我一样不能忍受这种瑕疵吧，那 就撸起袖子干它就完事了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;内存抖动-amp-内存泄漏-amp-内存溢出（OOM）&quot;&gt;&lt;a href=&quot;#内存抖动-amp-内存泄漏-amp-内存溢出（OOM）&quot; class=&quot;headerlink&quot; title=&quot;内存抖动 &amp;amp; 内存泄漏 &amp;amp; 内存溢出（OOM）&quot;&gt;&lt;/a&gt;内存抖动 &amp;amp; 内存泄漏 &amp;amp; 内存溢出（OOM）&lt;/h2&gt;&lt;h3 id=&quot;内存抖动&quot;&gt;&lt;a href=&quot;#内存抖动&quot; class=&quot;headerlink&quot; title=&quot;内存抖动&quot;&gt;&lt;/a&gt;内存抖动&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;含义：短时间内有大量对象创建销毁，它伴随着频繁的GC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看：可以使用android studio自带的profile工具检测。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现象：在profile中的内存图像就像是心电图一样，忽上忽下，如下图所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506380.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;常见场景：循环使用字符串拼接，比如我们项目的日志打印等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预防内存抖动方法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;避免在循环中创建对象，能复用的尽量复用。&lt;/li&gt;
&lt;li&gt;避免在频繁调用的方法中创建对象，如自定义view中的onDraw（）等方法中创建画笔。&lt;/li&gt;
&lt;li&gt;获取对象尽量从对象池中获取，如Handler获取Message对象应使用obtain（）方法获取了。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。&lt;br&gt;长生命周期对象持有短生命周期对象强引用，从而导致短生命周期对象无法被回收！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看：使用profile工具检测内存情况，重复执行进入然后退出一个activity，看activity实例是否还存在。如果activity实例还存在，很可能就出现了内存泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现象：反复进入A，然后退出A ，执行三次，可以看到A 的实例存在两个。如下图，VideoPlayerActivity：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/Android-内存优化篇-使用profile-和-MAT-工具进行内存泄漏检测/1240-20200309124506297.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;这就说明我们的activity并没有被销毁，至少目前是这样的。至于究竟会不会内存泄漏，就需要接下来使用另一款工具配合使用了。&lt;/p&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://darryrzhong.xyz/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="mat" scheme="http://darryrzhong.xyz/tags/mat/"/>
    
  </entry>
  
  <entry>
    <title>Android 组件化开源app -开眼短视频(OpenEyes)</title>
    <link href="http://darryrzhong.xyz/2020/03/09/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E6%BA%90app/"/>
    <id>http://darryrzhong.xyz/2020/03/09/组件化开源app/</id>
    <published>2020-03-09T04:24:33.000Z</published>
    <updated>2020-03-09T04:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 一款模仿 Eyepetizer | 开眼视频的 开源app</p></blockquote><ul><li><p>这是一个完全模仿 <code>开眼视频</code>的开源Demo，个人非常喜欢这款app 的UI 风格，由此第二次模仿该app进行相关技术的学习与整合，</p></li><li><p>废话不多说，直接上图 ，不论是商业项目还是开源app，首先肯定是看眼缘</p></li></ul><h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><table><thead><tr><th><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204444.png" alt="app_02.png"></th><th><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204541.png" alt="app_03.png"></th><th><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204537.png" alt="app_04.png"></th></tr></thead><tbody><tr><td><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204579.png" alt="app_05.png"></td><td><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204546.png" alt="app_06.png"></td><td><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204558.png" alt="app_07.png"></td></tr><tr><td><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204489.png" alt="app_08.png"></td><td><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204466.png" alt="app_09.png"></td><td><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204524.png" alt="app_10.png"></td></tr></tbody></table><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>该开源项目采用组件化的方式开发，使用MVVM + AndroidX + jetpack 组件为基本架构进行开发。</p><ul><li>项目结构图</li></ul><p><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/1240-20200309124204560.png" alt="app_12.png"></p><ul><li>app 架构图</li></ul><p><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/720-20200309124204564.png" alt="app_os.png"></p><a id="more"></a><h2 id="app-功能介绍"><a href="#app-功能介绍" class="headerlink" title="app 功能介绍"></a>app 功能介绍</h2><blockquote><p> 当然由于是个人闲暇时间基于兴趣开发的，没有UI 小姐姐 和测试小姐姐的陪伴，自然存在许些缺陷，当然写这个项目更多的是为了学习和锻炼app架构搭建的思维，希望能够帮到刷到这个博文的小伙伴，一起学习一起进步。</p></blockquote><p>功能方面，想了想觉得还是没啥好说的，就是UI 上显示的那样，相信在座的各位看官都是熟的不能再熟了，</p><h2 id="app-使用技术介绍"><a href="#app-使用技术介绍" class="headerlink" title="app 使用技术介绍"></a>app 使用技术介绍</h2><ul><li><p>Mvvm 架构设计<br>关于各种mvx 的区别，我就不一一介绍了，上Google 搜一下就好，关于项目中使用的mvvm设计封装，请移步 <a href="https://developer.android.google.cn/jetpack/androidx" target="_blank" rel="noopener">这里</a> ；代码是最好的老师，直接看源码吧。</p></li><li><p>Android X<br>这个也没啥好说的，就是android Support 库的升级迁移版而已，现在新项目肯定都是直接androidX了，对Android X 不熟悉的小伙伴，请移步 <a href="https://developer.android.google.cn/jetpack/androidx" target="_blank" rel="noopener">官方介绍</a> ；</p></li><li><p>jetpack<br>这个也没啥好说的，jetpack就是Google推出的一套组件开发库，直接上图可能更好， <a href="https://developer.android.google.cn/jetpack" target="_blank" rel="noopener">官方介绍</a></p></li></ul><p>基本最主要使用的就是这些了<br> <img src="//darryrzhong.xyz/2020/03/09/组件化开源app/1240-20200309124204581.png" alt="jetpack"></p><h2 id="app-第三方的依赖"><a href="#app-第三方的依赖" class="headerlink" title="app 第三方的依赖"></a>app 第三方的依赖</h2><ul><li><p>RxEasyHttp<br>RxEasyHttp是一款github上开源的RxJava2+Retrofit2实现简单易用的网络请求框架，在本人发现并观摩其源码和设计原理后，发现着实写的不错，各种业务场景基本都设计到了，api 设计的也不错，当然也存在一些瑕疵，所以实际项目中还需根据自己的业务需求进行二次开发，推荐给各位看官<a href="https://github.com/darryrzhong/RxEasyHttp" target="_blank" rel="noopener">RxEasyHttp</a></p></li><li><p>Loadsir<br>loadsir是一个app 页面状态管理的第三方库，也非常得实用，用来控制app 内的加载页面 、加载错误页面、空页面显示，点击重试等，从此告别自己控制网络加载失败等页面 show 、 hint 操作 和ViewStub等的控制，<br>可以基于自己的业务进行基类封装，具体请看项目base库中activity 和fragment 基类的封装。推荐给各位看官<br><a href="https://github.com/darryrzhong/LoadSir/blob/master/README-cn.md" target="_blank" rel="noopener">Loadsir</a></p></li><li><p>mmkv<br>mmkv 是腾讯开源的一个轻量级的存储库，用来代替SharedPreferences 再好不过了，具体使用请看官方介绍</p></li><li><p>BaseRecyclerViewAdapterHelper<br>相信对于这个库大家应该是非常熟悉了吧，基本做android 开发的都用过吧，不多说了</p></li><li><p>SmartRefreshLayout<br>这个库和上面那个库一样，用的非常多，</p></li><li><p>immersionbar<br>实现沉浸式状态栏的一个第三方库，也是非常常用</p></li><li><p>glide<br>图片加载库</p></li><li><p>rxpermissions<br>权限加载库</p></li><li><p>logger<br>日志打印库，打出来的日志格式看得比较舒服</p></li><li><p>utilcodex<br>一个android 工具库，里面有非常多的工具类，当然实际项目用不到这么多，所以可以根据需求copy代码就好，不用集成</p></li><li><p>BannerViewPager<br>一个第三方轮播图的库，这个库比较新，所以start数比较少，但是挺好用，推荐</p></li><li><p>PagerBottomTabStrip<br>一个第三方导航库，app中的底部导航就是基于这个库，挺好用，自带小红点管理</p></li><li><p>gsyVideoPlayer<br>一个第三方视频播放库，基于bilibili 开源的 ijkplayer，可自定义性也还不错，<br>主要使用这个库实现类似微博等视频列表根据滚动判断自动播放，</p></li></ul><h2 id="项目Api"><a href="#项目Api" class="headerlink" title="项目Api"></a>项目Api</h2><blockquote><p>声明 ，项目中所有api接口都是抓取自开眼app，所有版权均归属开眼app所有，仅供学习借鉴使用，请勿用做商业用途，若有侵权，请联系作者删除。</p></blockquote><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p>1.发现更多</p><ul><li>请求地址： <a href="http://baobab.kaiyanapp.com/api/v7/index/tab/discovery" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v7/index/tab/discovery</a></li></ul><p>2.每日推荐</p><ul><li>请求地址： <a href="http://baobab.kaiyanapp.com/api/v5/index/tab/allRec" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v5/index/tab/allRec</a></li></ul><p>3.日报精选</p><ul><li>请求地址 ： <a href="http://baobab.kaiyanapp.com/api/v5/index/tab/feed" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v5/index/tab/feed</a></li></ul><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>1.推荐</p><ul><li>请求地址： <a href="http://baobab.kaiyanapp.com/api/v7/community/tab/rec" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v7/community/tab/rec</a></li></ul><p>2.关注</p><ul><li>请求地址： <a href="http://baobab.kaiyanapp.com/api/v6/community/tab/follow" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v6/community/tab/follow</a></li></ul><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>1.主题 </p><ul><li>请求地址： <a href="http://baobab.kaiyanapp.com/api/v7/tag/tabList" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v7/tag/tabList</a></li></ul><p>2.通知 </p><ul><li>请求地址 ：  <a href="http://baobab.kaiyanapp.com/api/v3/messages" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v3/messages</a></li></ul><p>3.互动</p><ul><li>请求地址 ：  <a href="http://baobab.kaiyanapp.com/api/v7/topic/list" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v7/topic/list</a></li></ul><h3 id="视频详情页"><a href="#视频详情页" class="headerlink" title="视频详情页"></a>视频详情页</h3><p>1.相关推荐 </p><ul><li>请求地址 ：<a href="http://baobab.kaiyanapp.com/api/v4/video/related?id=186856" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v4/video/related?id=186856</a></li></ul><table><thead><tr><th>参数说明</th><th>说明</th><th>是否必须</th><th>默认值</th></tr></thead><tbody><tr><td>id</td><td>当前播放视频的id，从跳转页面视频item中获取</td><td>是</td><td>无</td></tr></tbody></table><ol start="2"><li>评论</li></ol><ul><li>请求地址 ：<a href="http://baobab.kaiyanapp.com/api/v2/replies/video?videoId=186856" target="_blank" rel="noopener">http://baobab.kaiyanapp.com/api/v2/replies/video?videoId=186856</a></li></ul><table><thead><tr><th>参数说明</th><th>说明</th><th>是否必须</th><th>默认值</th></tr></thead><tbody><tr><td>videoId</td><td>当前播放视频的id，从跳转页面视频item中获取</td><td>是</td><td>无</td></tr></tbody></table><h2 id="aok下载"><a href="#aok下载" class="headerlink" title="aok下载"></a>aok下载</h2><p><img src="//darryrzhong.xyz/2020/03/09/组件化开源app/1240-20200309124204582.png" alt="安装密码：darryrzhong"></p><ul><li><a href="https://www.pgyer.com/Pedw" target="_blank" rel="noopener">安装密码 ： darryrzhong </a></li></ul><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><ul><li><h1 id="Android-MvvmComponent-App"><a href="#Android-MvvmComponent-App" class="headerlink" title="Android-MvvmComponent-App"></a><strong><a href="https://github.com/darryrzhong/Android-MvvmComponent-App" target="_blank" rel="noopener">Android-MvvmComponent-App</a></strong></h1></li></ul><p>欢迎关注作者<a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">darryrzhong</a>,更多干货等你来拿哟.</p><h3 id="请赏个小红心！因为你的鼓励是我写作的最大动力！"><a href="#请赏个小红心！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请赏个小红心！因为你的鼓励是我写作的最大动力！"></a>请赏个小红心！因为你的鼓励是我写作的最大动力！</h3><blockquote><p>更多精彩文章请关注</p><ul><li><a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">个人博客:darryrzhong</a></li><li><a href="https://juejin.im/user/5a6c3b19f265da3e49804988" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/users/b7fdf53ec0b9/timeline" target="_blank" rel="noopener">简书</a></li><li><a href="https://segmentfault.com/u/darryrzhong_5ac59892a5882/articles" target="_blank" rel="noopener">SegmentFault</a></li><li><a href="https://www.imooc.com/u/6733207" target="_blank" rel="noopener">慕课网手记</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 一款模仿 Eyepetizer | 开眼视频的 开源app&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是一个完全模仿 &lt;code&gt;开眼视频&lt;/code&gt;的开源Demo，个人非常喜欢这款app 的UI 风格，由此第二次模仿该app进行相关技术的学习与整合，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;废话不多说，直接上图 ，不论是商业项目还是开源app，首先肯定是看眼缘&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;效果图：&quot;&gt;&lt;a href=&quot;#效果图：&quot; class=&quot;headerlink&quot; title=&quot;效果图：&quot;&gt;&lt;/a&gt;效果图：&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204444.png&quot; alt=&quot;app_02.png&quot;&gt;&lt;/th&gt;
&lt;th&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204541.png&quot; alt=&quot;app_03.png&quot;&gt;&lt;/th&gt;
&lt;th&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204537.png&quot; alt=&quot;app_04.png&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204579.png&quot; alt=&quot;app_05.png&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204546.png&quot; alt=&quot;app_06.png&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204558.png&quot; alt=&quot;app_07.png&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204489.png&quot; alt=&quot;app_08.png&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204466.png&quot; alt=&quot;app_09.png&quot;&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/260-20200309124204524.png&quot; alt=&quot;app_10.png&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h2&gt;&lt;p&gt;该开源项目采用组件化的方式开发，使用MVVM + AndroidX + jetpack 组件为基本架构进行开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目结构图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/1240-20200309124204560.png&quot; alt=&quot;app_12.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app 架构图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2020/03/09/组件化开源app/720-20200309124204564.png&quot; alt=&quot;app_os.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="组件化" scheme="http://darryrzhong.xyz/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android Activity生命周期&amp;启动模式详解</title>
    <link href="http://darryrzhong.xyz/2019/09/16/Android-Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/</id>
    <published>2019-09-16T13:33:49.000Z</published>
    <updated>2020-03-09T04:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Activity生命周期-amp-启动模式详解"><a href="#Android-Activity生命周期-amp-启动模式详解" class="headerlink" title="Android Activity生命周期&amp;启动模式详解"></a>Android Activity生命周期&amp;启动模式详解</h1><h2 id="从四个视角理解Android-Activity启动模式"><a href="#从四个视角理解Android-Activity启动模式" class="headerlink" title="从四个视角理解Android Activity启动模式"></a>从四个视角理解Android Activity启动模式</h2><ul><li>从Android软件体系架构的角度来看</li><li>从Android系统Task来看</li><li>从Activity生命周期来看</li><li>从Activity启动方式来看</li></ul><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><ul><li>Task是属于Android系统的任务栈,一个Task中可以包含有多个application的Activity</li><li>Activity代码属于Application，但是Task属于Android操作系统</li></ul><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240.jpeg" alt="图片2.jpg"></p><ul><li>Android中如何查看Task</li></ul><p>1.可以在Android studio 中的terminal中输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activitys</span><br></pre></td></tr></table></figure><p>2.通过手机navigation方式查看</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125420909.png" alt="图片4.png"></p><h2 id="Task启动方式"><a href="#Task启动方式" class="headerlink" title="Task启动方式"></a>Task启动方式</h2><ul><li>恢复模式</li></ul><p>此种方式属于Activity生命周期由不可见到获得焦点的范畴</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125424561.png" alt="图片5.png"></p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125428575.jpeg" alt="图片7.jpg"></p><ul><li>新建模式</li></ul><p>此种方式如下:</p><p>1.通过通知栏打开</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125432435.jpeg" alt="图片8.jpg"></p><p>2.通过其他第三方App唤醒</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125435845.jpeg" alt="图片9.jpg"></p><a id="more"></a><p>这种启动方式都是由 startActivity()新建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DisplayMessageActivity.class);     </span><br><span class="line">EditText editText = (EditText) findViewById(R.id.editText);</span><br><span class="line">String message = editText.getText().toString();</span><br><span class="line">intent.putExtra(EXTRA_MESSAGE, message);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><ul><li>luncher启动模式</li></ul><p>luncher启动方式分为两种情况</p><p>1.Task不存在</p><p>2.Task已经存在</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125444517.png" alt="图片10.png"></p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125447681.png" alt="图片11.png"></p><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><ul><li>activity生命周期</li></ul><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125450091.jpeg" alt="图片12.jpg"></p><ul><li>对于activity生命周期中各个方法,需要记住他们是成对出现的</li></ul><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125452539.jpeg" alt="图片13.jpg"></p><ul><li>activity相邻状态之间的区别(面试重点)</li></ul><p>在讲解相邻状态之间区别之前,首先我们需要知道当两个activity交互时的生命周期,如图所示:</p><p>1.从启动ActivityA 进入到ActivityB的生命周期走向</p><p>2.从ActivityB 返回到ActivityA时的生命周期走向</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125454657.jpeg" alt="图片14.jpg"></p><p>从上图我们可以看到,当ActivityA启动ActivityB时,执行到onPause()时,并没有立即执行onStop();</p><p>而是先执行ActivityB 的相应方法,知道ActivityB 的onResume()执行完毕,也就是ActivityB启动成功后,才调用自身的onStop();反之亦是如此</p><blockquote><p>这里有一个小技巧</p><p>我们日常开发中,启动App时都会先加载一个splash页面,而关于这个splash页面何时关闭呢?</p><p>2s? 3s? 肯是我们的MainActivity加载完成后再关闭,所以时间是不确定的</p><p>那看了上面的生命周期介绍,我就知道了,放在splashActivity的onStop()方法中执行finish()就ok了</p></blockquote><p>下面我们详细介绍activity生命周期中各个相邻状态之间的区别吧,敲黑板了!!!</p><p>1.onCreate和onStart之间有什么区别？</p><p>（1）可见与不可见的区别。前者不可见，后者可见。<br> （2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。<br> （3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。</p><p>2.onStart方法和onResume方法有什么区别？</p><p>（1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。<br> （2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。</p><p>这里解释下,这里所谓的前台并不是我们日常所说的前台任务的那个前台,这里的前台指的是能否与用户产生交互</p><p>3.onPause方法和onStop方法有什么区别？</p><p>（1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。<br> （2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。</p><p>4.onStop方法和onDestroy方法有什么区别？</p><p>onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁</p><ul><li>onNewIntent的生命周期</li></ul><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125459649.jpeg" alt="图片15.jpg"></p><p>1、只对singleTop，singleTask，singleInstance有效，因为standard每次都是新建，所以不存在onNewIntent；</p><p>2、只对startActivity有效，对于从Navigation切换回来的恢复无效；</p><h2 id="Activity的四种启动模式"><a href="#Activity的四种启动模式" class="headerlink" title="Activity的四种启动模式"></a>Activity的四种启动模式</h2><p>介绍如图:</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125502554.png" alt="image.png"></p><ul><li>standard 模式</li></ul><p>1.standard 默认模式</p><p>系统在启动Activity的任务中创建Activity的新实例并向其传送Intent。Activity可以多次实例化，不管这个实例是否已经存在，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这种模式的Activity被创建时它的onCreate、onStart 都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈在这种模式下，谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中</p><p>以下三种情况:</p><p>a、当从非Activity的context启动activity时，需要带new_task的flag；</p><p>b、当启动一个带有affinity的activity，如果这个activity已经有实例存在该task，则不会重新创建；</p><p>c、如果从应用内启动的standard activity的Affinity就是App默认的Affinity，则会每次新建一个实例；</p><blockquote><p>小提示:affinity是指Task的标识,而我们一般不指定的话默认就是App的包名,而一旦指定一个affinity,</p><p>那么启动的activity将会在另一个Task中执行,在后台任务切换栏里,你就可以看到两个任务窗口</p></blockquote><ul><li>singleTop 模式</li></ul><p>一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。</p><p>分析图如下:</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125506171.jpeg" alt="图片16.jpg"></p><ul><li>singleTask</li></ul><p>这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例，和 singleTop一样，系统也会回调其 onNewIntent。当一个具有 singleTask 模式的Activity请求启动后，比如 Activity A，系统首先会寻找是否存在 A 想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。</p><p>分析如下:</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125508719.jpeg" alt="图片17.jpg"></p><blockquote><p>小提示: 此种启动模式和singleTop有点像,但是值得注意的是,下面这句话</p><p>如果存在实例则重用实例,移到栈顶,并清空所有在它上面的Activity,一般用作程序的主入口</p></blockquote><ul><li>singleInstance</li></ul><p>与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中</p><h2 id="Intent-Activity-Flag-的使用"><a href="#Intent-Activity-Flag-的使用" class="headerlink" title="Intent Activity Flag 的使用"></a>Intent Activity Flag 的使用</h2><p>使用流程如下:</p><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125511178.png" alt="image.png"></p><p>对于Intent Flag 种类太多了,这里就不一一解释了,</p><p>我们只需要知道要使用Flag的流程即可,需要用到的时候自己查一下文档</p><p>另外需要注意的是,Intent Flag的设置只对standard和singleTop这两种启动模式有效</p><h2 id="Activity四种启动模式的应用场景"><a href="#Activity四种启动模式的应用场景" class="headerlink" title="Activity四种启动模式的应用场景"></a>Activity四种启动模式的应用场景</h2><p><img src="//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125513357.png" alt="image.png"></p><p>至此,anctivity的四种启动模式和生命周期分析完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-Activity生命周期-amp-启动模式详解&quot;&gt;&lt;a href=&quot;#Android-Activity生命周期-amp-启动模式详解&quot; class=&quot;headerlink&quot; title=&quot;Android Activity生命周期&amp;amp;启动模式详解&quot;&gt;&lt;/a&gt;Android Activity生命周期&amp;amp;启动模式详解&lt;/h1&gt;&lt;h2 id=&quot;从四个视角理解Android-Activity启动模式&quot;&gt;&lt;a href=&quot;#从四个视角理解Android-Activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;从四个视角理解Android Activity启动模式&quot;&gt;&lt;/a&gt;从四个视角理解Android Activity启动模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从Android软件体系架构的角度来看&lt;/li&gt;
&lt;li&gt;从Android系统Task来看&lt;/li&gt;
&lt;li&gt;从Activity生命周期来看&lt;/li&gt;
&lt;li&gt;从Activity启动方式来看&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Task&quot;&gt;&lt;a href=&quot;#Task&quot; class=&quot;headerlink&quot; title=&quot;Task&quot;&gt;&lt;/a&gt;Task&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Task是属于Android系统的任务栈,一个Task中可以包含有多个application的Activity&lt;/li&gt;
&lt;li&gt;Activity代码属于Application，但是Task属于Android操作系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240.jpeg&quot; alt=&quot;图片2.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android中如何查看Task&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.可以在Android studio 中的terminal中输入命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adb shell dumpsys activity activitys&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.通过手机navigation方式查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125420909.png&quot; alt=&quot;图片4.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Task启动方式&quot;&gt;&lt;a href=&quot;#Task启动方式&quot; class=&quot;headerlink&quot; title=&quot;Task启动方式&quot;&gt;&lt;/a&gt;Task启动方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;恢复模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此种方式属于Activity生命周期由不可见到获得焦点的范畴&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125424561.png&quot; alt=&quot;图片5.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125428575.jpeg&quot; alt=&quot;图片7.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此种方式如下:&lt;/p&gt;
&lt;p&gt;1.通过通知栏打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125432435.jpeg&quot; alt=&quot;图片8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.通过其他第三方App唤醒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/16/Android-Activity生命周期-启动模式详解/1240-20200309125435845.jpeg&quot; alt=&quot;图片9.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="activity启动模式" scheme="http://darryrzhong.xyz/tags/activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java系列之io框架</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8Bio%E6%A1%86%E6%9E%B6/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之io框架/</id>
    <published>2019-09-15T09:33:35.000Z</published>
    <updated>2020-03-09T05:33:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java IO的学习是一件非常艰巨的任务。</span><br></pre></td></tr></table></figure><p>它的挑战是来自于要覆盖所有的可能性。不仅存在各种I/O源端还有想要和他通信的接收端（文件/控制台/网络链接），而且还需要以不同的方式与他们进行通信（顺序/随机存取/缓冲/二进制/字符/行/字 等等）这些情况综合起来就给我们带来了大量的学习任务，大量的类需要学习。</p><p>我们要学会所有的这些java 的IO是很难的，因为我们没有构建一个关于IO的体系，要构建这个体系又需要深入理解IO库的演进过程，所以，我们如果缺乏历史的眼光，很快我们会对什么时候应该使用IO中的哪些类，以及什么时候不该使用它们而困惑。</p><p>所以，在开发者的眼中，IO很乱，很多类，很多方法，很迷茫。</p><h1 id="IO简介"><a href="#IO简介" class="headerlink" title="IO简介"></a>IO简介</h1><p>​    数据流是一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</p><p>​    流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： <strong>1) 字节流：</strong>数据流中最小的数据单元是字节 <strong>2) 字符流：</strong>数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p><p>​    Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。掌握了这些就掌握了Java I/O的精髓了。</p><h6 id="Java-I-O主要包括如下3层次："><a href="#Java-I-O主要包括如下3层次：" class="headerlink" title="Java I/O主要包括如下3层次："></a>Java I/O主要包括如下3层次：</h6><ol><li>流式部分——最主要的部分。如：OutputStream、InputStream、Writer、Reader等</li><li>非流式部分——如：File类、RandomAccessFile类和FileDescriptor等类</li><li>其他——文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</li></ol><p><img src="//darryrzhong.xyz/2019/09/15/java系列之io框架/1240-20200309133318419.png" alt="IO图谱.png"></p><h1 id="IO详细介绍"><a href="#IO详细介绍" class="headerlink" title="IO详细介绍"></a>IO详细介绍</h1><p>​          在Android 平台，从应用的角度出发，我们最需要关注和研究的就是 字节流（Stream）字符流（Reader/Writer）和 File/ RandomAccessFile。当我们需要的时候再深入研究也未尝不是一件好事。关于字符和字节，例如文本文件，XML这些都是用字符流来读取和写入。而如RAR，EXE文件，图片等非文本，则用字节流来读取和写入。<strong>面对如此复杂的类关系，有一个点是我们必须要首先掌握的，那就是设计模式中的修饰模式</strong>，学会并理解修饰模式是搞懂流必备的前提条件哦。</p><h2 id="字节流的学习"><a href="#字节流的学习" class="headerlink" title="字节流的学习"></a>字节流的学习</h2><p>​        在具体的学习流之前，我们必须要学的一个设计模式是装饰模式。因为从流的整个发展历史，出现的各种类之间的关系看，都是沿用了修饰模式，都是一个类的功能可以用来修饰其他类，然后组合成为一个比较复杂的流。比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = new DataOutputStream(</span><br><span class="line">newBufferedOutputStream(</span><br><span class="line">new FileOutputStream(file)));</span><br></pre></td></tr></table></figure><p>​        从上面的代码块中大家不难看出这些类的关系：<strong>为了向文件中写入数据，首先需要创建一个FileOutputStream，然后为了提升访问的效率，所以将它发送给具备缓存功能的BufferedOutput-Stream,而为了实现与机器类型无关的java基本类型数据的输出，所以，我们将缓存的流传递给了DataOutputStream</strong>。从上面的关系，我们可以看到，其根本目的都是为outputSteam添加额外的功能。<strong>而这种额外功能的添加就是采用了装饰模式来构建的代码</strong>。因此，学习流，必须要学好装饰模式。</p><a id="more"></a><p>​       下面的图是一个关于字节流的图谱，这张图谱比较全面的概况了我们字节流中间的各个类以及他们之间的关系。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之io框架/1240-20200309133323218.jpeg" alt="输入输出流.jpg"></p><h4 id="字节流的学习过程"><a href="#字节流的学习过程" class="headerlink" title="字节流的学习过程"></a>字节流的学习过程</h4><p>​       为什么要按照一个学习路线来呢？原因是他们的功能决定的。</p><p>​      OutputStream -&gt; FileOutputStream/FilterOutputStream -&gt;DataOutputStream-&gt;bufferedOutputStream</p><p>​      相应的学习InputStream方法就好了。</p><p>​       从学习的角度来，我们应该先掌握FilterOutputStream, 以及FileOutputStream，这两个类是基本的类，从继承关系可以不难发现他们都是对 abstract 类 OutputStream的拓展，是它的子类。然而，伴随着 对 Stream流的功能的拓展，所以就出现了 DataOutputStream，（将java中的基础数据类型写入数据字节输出流中、保存在存储介质中、然后可以用DataOutputStream从存储介质中读取到程序中还原成java基础类型）。这里多提一句、DataOutputStream、FilterOutputStream三个类的关系的这种设计既使用了装饰器模式 避免了类的爆炸式增长。 </p><p>​        为了提升Stream的执行效率，所以出现了bufferedOutputStream。bufferedOutputStream就是将本地添加了一个缓存的数组。在使用bufferedOutputStream之前每次从磁盘读入数据的时候都是需要访问多少byte数据就向磁盘中读多少个byte的数据，而出现bufferedOutputSteam之后，策略就改了，会先读取整个缓存空间相应大小的数据，这样就是从磁盘读取了一块比较大的数据，然后缓存起来，从而减少了对磁盘的访问的次数以达到提升性能的目的。</p><p>​          另外一方面，我们知道了outputStream（输出流）的发展历史后，我们便可以知道如何使用outpuSteam了，同样的方法，我们可以运用到inputStream中来，这样对称的解释就出现到了inputStream相关的中来了，于是，我们对整个字节流就有了全方位的理解，所以这样子我们就不会感觉到流的复杂了。这个时候对于其他的一些字节流的使用(byteArrayOutputStream/PipeOutputStream/ObjectOutputStream)的学习就自需要在使用的时候看看API即可。</p><h2 id="字符流的学习"><a href="#字符流的学习" class="headerlink" title="字符流的学习"></a>字符流的学习</h2><p>下图则是一个关于字符流的图谱，这张图谱比较全面的概况了我们字符流中间的各个类以及他们之间的关系。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之io框架/1240-20200309133325980.jpeg" alt="字符输入输出流.jpg"></p><p>​        字符流的学习和字节流的学习是一样的，它和字节流有着同样的发展过程，只是，字节流面向的是我们未知或者即使知道了他们的编码格式也意义不大的文件（png，exe, zip）的时候是采用字节，而面对一些我们知道文件构造我们就能够搞懂它的意义的文件（json，xml）等文件的时候我们还是需要以字符的形式来读取，所以就出现了字符流。reader 和 Stream最大的区别我认为是它包含了一个readline（）接口，这个接口标明了，一行数据的意义，这也是可以理解的，因为自有字符才具备行的概念，相反字节流中的行也就是一个字节符号。</p><h4 id="字符流的学习历程："><a href="#字符流的学习历程：" class="headerlink" title="字符流的学习历程："></a>字符流的学习历程：</h4><p>​        Writer- &gt;FilterWriter-&gt;BufferedWriter-&gt;OutputStreamWriter-&gt;FileWriter-&gt;其他</p><p>​        同时类比着学习Reader相关的类。</p><h5 id="FilterWriter-FilterReader"><a href="#FilterWriter-FilterReader" class="headerlink" title="FilterWriter/FilterReader"></a>FilterWriter/FilterReader</h5><p>​        字符过滤输出流、与FilterOutputStream功能一样、只是简单重写了父类的方法、目的是为所有装饰类提供标准和基本的方法、要求子类必须实现核心方法、和拥有自己的特色。这里FilterWriter没有子类、可能其意义只是提供一个接口、留着以后的扩展。。。本身是一个抽象类。</p><h5 id="BufferedWriter-BufferedReader"><a href="#BufferedWriter-BufferedReader" class="headerlink" title="BufferedWriter/BufferedReader"></a>BufferedWriter/BufferedReader</h5><p>​         BufferedWriter是 Writer类的一个子类。他的功能是为传入的底层字符输出流提供缓存功能、同样当使用底层字符输出流向目的地中写入字符或者字符数组时、每写入一次就要打开一次到目的地的连接、这样频繁的访问不断效率底下、也有可能会对存储介质造成一定的破坏、比如当我们向磁盘中不断的写入字节时、夸张一点、将一个非常大单位是G的字节数据写入到磁盘的指定文件中的、没写入一个字节就要打开一次到这个磁盘的通道、这个结果无疑是恐怖的、而当我们使用BufferedWriter将底层字符输出流、比如FileReader包装一下之后、我们可以在程序中先将要写入到文件中的字符写入到BufferedWriter的内置缓存空间中、然后当达到一定数量时、一次性写入FileReader流中、此时、FileReader就可以打开一次通道、将这个数据块写入到文件中、这样做虽然不可能达到一次访问就将所有数据写入磁盘中的效果、但也大大提高了效率和减少了磁盘的访问量！</p><h5 id="OutputStreamWriter-InputStreamReader"><a href="#OutputStreamWriter-InputStreamReader" class="headerlink" title="OutputStreamWriter/InputStreamReader"></a>OutputStreamWriter/InputStreamReader</h5><p>​       输入字符转换流、是输入字节流转向输入字符流的桥梁、用于将输入字节流转换成输入字符流、通过指定的或者默认的编码将从底层读取的字节转换成字符返回到程序中、与OutputStreamWriter一样、本质也是使用其内部的一个类来完成所有工作：StreamDecoder、使用默认或者指定的编码将字节转换成字符；OutputStreamWriter/ InputStreamReader只是对StreamDecoder进行了封装、isr内部所有方法核心都是调用StreamDecoder来完成的、InputStreamReader只是对StreamDecoder进行了封装、使得我们可以直接使用读取方法、而不用关心内部实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter、InputStreamReader分别为InputStream、OutputStream的低级输入输出流提供将字节转换成字符的桥梁、他们只是外边的一个门面、真正的核心：</span><br></pre></td></tr></table></figure><p>OutputStreamWriter中的StreamEncoder：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、使用指定的或者默认的编码集将字符转码为字节        </span><br><span class="line"></span><br><span class="line">2、调用StreamEncoder自身实现的写入方法将转码后的字节写入到底层字节输出流中。</span><br></pre></td></tr></table></figure><p>InputStreamReader中的StreamDecoder：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、使用指定的或者默认的编码集将字节解码为字符         </span><br><span class="line"></span><br><span class="line">2、调用StreamDecoder自身实现的读取方法将解码后的字符读取到程序中。</span><br></pre></td></tr></table></figure><p>在理解这两个流的时候要注意：java——io中只有将字节转换成字符的类、没有将字符转换成字节的类、原因很简单——字符流的存在本来就像对字节流进行了装饰、加工处理以便更方便的去使用、在使用这两个流的时候要注意：由于这两个流要频繁的对读取或者写入的字节或者字符进行转码、解码和与底层流的源和目的地进行交互、所以使用的时候要使用BufferedWriter、BufferedReader进行包装、以达到最高效率、和保护存储介质。</p><h5 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader/FileWriter"></a>FileReader/FileWriter</h5><p>​        FileReader和FileWriter 继承于InputStreamReader/OutputStreamWriter。</p><p>​        从源码可以发现FileWriter 文件字符输出流、主要用于将字符写入到指定的打开的文件中、其本质是通过传入的文件名、文件、或者文件描述符来创建FileOutputStream、然后使用OutputStreamWriter使用默认编码将FileOutputStream转换成Writer（这个Writer就是FileWriter）。如果使用这个类的话、最好使用BufferedWriter包装一下、高端大气上档次、低调奢华有内涵！</p><p>​       FileReader  文件字符输入流、用于将文件内容以字符形式读取出来、一般用于读取字符形式的文件内容、也可以读取字节形式、但是因为FileReader内部也是通过传入的参数构造InputStreamReader、并且只能使用默认编码、所以我们无法控制编码问题、这样的话就很容易造成乱码。所以读取字节形式的文件还是使用字节流来操作的好、同样在使用此流的时候用BufferedReader包装一下、就算冲着BufferedReader的readLine()方法去的也要使用这个包装类、不说他还能提高效率、保护存储介质。</p><h2 id="字节流与字符流的关系"><a href="#字节流与字符流的关系" class="headerlink" title="字节流与字符流的关系"></a>字节流与字符流的关系</h2><p>那么字节输入流和字符输入流之间的关系是怎样的呢？请看下图</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之io框架/1240-20200309133329346.jpeg" alt="字节与字符输入流.jpg"></p><p>同样的字节与字符输出流字节的关系也如下图所示</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之io框架/1240-20200309133331558.jpeg" alt="字节与字符输出流.jpg"></p><h4 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a><strong>字节流与字符流的区别</strong></h4><p>​       字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？</p><p>　　<em>字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</em></p><h6 id="那开发中究竟用字节流好还是用字符流好呢？"><a href="#那开发中究竟用字节流好还是用字符流好呢？" class="headerlink" title="那开发中究竟用字节流好还是用字符流好呢？"></a>那开发中究竟用字节流好还是用字符流好呢？</h6><p>　　在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。</p><p>　　如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。</p><h4 id="字节流与字符流的转换"><a href="#字节流与字符流的转换" class="headerlink" title="字节流与字符流的转换"></a>字节流与字符流的转换</h4><p>虽然Java支持字节流和字符流，但有时需要在字节流和字符流两者之间转换。InputStreamReader和OutputStreamWriter，这两个为类是字节流和字符流之间相互转换的类。</p><h6 id="InputSreamReader用于将一个字节流中的字节解码成字符："><a href="#InputSreamReader用于将一个字节流中的字节解码成字符：" class="headerlink" title="InputSreamReader用于将一个字节流中的字节解码成字符："></a>InputSreamReader用于将一个字节流中的字节解码成字符：</h6><p>　　<strong>有两个构造方法</strong>：　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in);</span><br></pre></td></tr></table></figure><p>　　<strong>功能</strong>：用默认字符集创建一个InputStreamReader对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in,String CharsetName);</span><br></pre></td></tr></table></figure><p>　 <strong>功能</strong>：接收已指定字符集名的字符串，并用该字符创建对象</p><h6 id="OutputStream用于将写入的字符编码成字节后写入一个字节流。"><a href="#OutputStream用于将写入的字符编码成字节后写入一个字节流。" class="headerlink" title="OutputStream用于将写入的字符编码成字节后写入一个字节流。"></a>OutputStream用于将写入的字符编码成字节后写入一个字节流。</h6><p>　　<strong>同样有两个构造方法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream out);</span><br></pre></td></tr></table></figure><p>　　<strong>功能</strong>：用默认字符集创建一个OutputStreamWriter对象；　　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream out,String  CharSetName);</span><br></pre></td></tr></table></figure><p>　　<strong>功能</strong>：接收已指定字符集名的字符串，并用该字符集创建OutputStreamWrite对象</p><p>​      为了避免频繁的转换字节流和字符流，对以上两个类进行了封装。</p><p>　　BufferedWriter类封装了OutputStreamWriter类；</p><p>　　BufferedReader类封装了InputStreamReader类；</p><p>　　<strong>封装格式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter out=new BufferedWriter(new OutputStreamWriter(System.out));</span><br><span class="line">BufferedReader in= new BufferedReader(new InputStreamReader(System.in);</span><br></pre></td></tr></table></figure><p>　　利用下面的语句，可以从控制台读取一行字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String line=in.readLine();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IO框架&quot;&gt;&lt;a href=&quot;#IO框架&quot; class=&quot;headerlink&quot; title=&quot;IO框架&quot;&gt;&lt;/a&gt;IO框架&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Java IO的学习是一件非常艰巨的任务。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它的挑战是来自于要覆盖所有的可能性。不仅存在各种I/O源端还有想要和他通信的接收端（文件/控制台/网络链接），而且还需要以不同的方式与他们进行通信（顺序/随机存取/缓冲/二进制/字符/行/字 等等）这些情况综合起来就给我们带来了大量的学习任务，大量的类需要学习。&lt;/p&gt;
&lt;p&gt;我们要学会所有的这些java 的IO是很难的，因为我们没有构建一个关于IO的体系，要构建这个体系又需要深入理解IO库的演进过程，所以，我们如果缺乏历史的眼光，很快我们会对什么时候应该使用IO中的哪些类，以及什么时候不该使用它们而困惑。&lt;/p&gt;
&lt;p&gt;所以，在开发者的眼中，IO很乱，很多类，很多方法，很迷茫。&lt;/p&gt;
&lt;h1 id=&quot;IO简介&quot;&gt;&lt;a href=&quot;#IO简介&quot; class=&quot;headerlink&quot; title=&quot;IO简介&quot;&gt;&lt;/a&gt;IO简介&lt;/h1&gt;&lt;p&gt;​    数据流是一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。&lt;/p&gt;
&lt;p&gt;​    流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： &lt;strong&gt;1) 字节流：&lt;/strong&gt;数据流中最小的数据单元是字节 &lt;strong&gt;2) 字符流：&lt;/strong&gt;数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。&lt;/p&gt;
&lt;p&gt;​    Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。掌握了这些就掌握了Java I/O的精髓了。&lt;/p&gt;
&lt;h6 id=&quot;Java-I-O主要包括如下3层次：&quot;&gt;&lt;a href=&quot;#Java-I-O主要包括如下3层次：&quot; class=&quot;headerlink&quot; title=&quot;Java I/O主要包括如下3层次：&quot;&gt;&lt;/a&gt;Java I/O主要包括如下3层次：&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;流式部分——最主要的部分。如：OutputStream、InputStream、Writer、Reader等&lt;/li&gt;
&lt;li&gt;非流式部分——如：File类、RandomAccessFile类和FileDescriptor等类&lt;/li&gt;
&lt;li&gt;其他——文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之io框架/1240-20200309133318419.png&quot; alt=&quot;IO图谱.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;IO详细介绍&quot;&gt;&lt;a href=&quot;#IO详细介绍&quot; class=&quot;headerlink&quot; title=&quot;IO详细介绍&quot;&gt;&lt;/a&gt;IO详细介绍&lt;/h1&gt;&lt;p&gt;​          在Android 平台，从应用的角度出发，我们最需要关注和研究的就是 字节流（Stream）字符流（Reader/Writer）和 File/ RandomAccessFile。当我们需要的时候再深入研究也未尝不是一件好事。关于字符和字节，例如文本文件，XML这些都是用字符流来读取和写入。而如RAR，EXE文件，图片等非文本，则用字节流来读取和写入。&lt;strong&gt;面对如此复杂的类关系，有一个点是我们必须要首先掌握的，那就是设计模式中的修饰模式&lt;/strong&gt;，学会并理解修饰模式是搞懂流必备的前提条件哦。&lt;/p&gt;
&lt;h2 id=&quot;字节流的学习&quot;&gt;&lt;a href=&quot;#字节流的学习&quot; class=&quot;headerlink&quot; title=&quot;字节流的学习&quot;&gt;&lt;/a&gt;字节流的学习&lt;/h2&gt;&lt;p&gt;​        在具体的学习流之前，我们必须要学的一个设计模式是装饰模式。因为从流的整个发展历史，出现的各种类之间的关系看，都是沿用了修饰模式，都是一个类的功能可以用来修饰其他类，然后组合成为一个比较复杂的流。比如说：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;	DataOutputStream out = new DataOutputStream(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new	BufferedOutputStream(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new FileOutputStream(file)));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​        从上面的代码块中大家不难看出这些类的关系：&lt;strong&gt;为了向文件中写入数据，首先需要创建一个FileOutputStream，然后为了提升访问的效率，所以将它发送给具备缓存功能的BufferedOutput-Stream,而为了实现与机器类型无关的java基本类型数据的输出，所以，我们将缓存的流传递给了DataOutputStream&lt;/strong&gt;。从上面的关系，我们可以看到，其根本目的都是为outputSteam添加额外的功能。&lt;strong&gt;而这种额外功能的添加就是采用了装饰模式来构建的代码&lt;/strong&gt;。因此，学习流，必须要学好装饰模式。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="javaIO" scheme="http://darryrzhong.xyz/tags/javaIO/"/>
    
  </entry>
  
  <entry>
    <title>java系列之json解析</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8Bjson%E8%A7%A3%E6%9E%90/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之json解析/</id>
    <published>2019-09-15T09:24:09.000Z</published>
    <updated>2020-03-09T05:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>数据标记，存储，传输</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>读写速度快</li><li>解析简单</li><li>轻量级</li><li>独立于语言，平台</li><li>具有自我描叙性</li></ol><h2 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h2><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133348995.png" alt="jsonjiexiqi.png"></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON建构于两种结构：</p><ul><li>“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</li><li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</li></ul><p>这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。</p><p>JSON具有以下这些形式：</p><p>对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133352592.gif" alt="object.gif"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">"name"</span>: <span class="string">"英语"</span>,</span><br><span class="line">     <span class="attr">"score"</span>: <span class="number">78.3</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133355549.gif" alt="array.gif"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"courses": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"英语"</span>,</span><br><span class="line">      <span class="attr">"score"</span>: <span class="number">78.3</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>值（<em>value</em>）可以是双引号括起来的字符串（<em>string</em>）、数值(number)、<code>true</code>、<code>false</code>、 <code>null</code>、对象（object）或者数组（array）。这些结构可以嵌套。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133358450.gif" alt="value.gif"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"https://qqe2.com"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"欢迎使用JSON在线解析编辑器"</span>,</span><br><span class="line">  <span class="attr">"array"</span>: &#123;</span><br><span class="line">    <span class="attr">"JSON校验"</span>: <span class="string">"http://jsonlint.qqe2.com/"</span>,</span><br><span class="line">    <span class="attr">"Cron生成"</span>: <span class="string">"http://cron.qqe2.com/"</span>,</span><br><span class="line">    <span class="attr">"JS加密解密"</span>: <span class="string">"http://edit.qqe2.com/"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"boolean"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"null"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"number"</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">"object"</span>: &#123;</span><br><span class="line">    <span class="attr">"a"</span>: <span class="string">"b"</span>,</span><br><span class="line">    <span class="attr">"c"</span>: <span class="string">"d"</span>,</span><br><span class="line">    <span class="attr">"e"</span>: <span class="string">"f"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串（<em>string</em>）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。</p><p>字符串（<strong>string</strong>）与C或者Java的字符串非常相似。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133401457.gif" alt="string.gif"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Zero"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数值（<em>number</em>）也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133404168.gif" alt="number.gif"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">28</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="JSON解析方式"><a href="#JSON解析方式" class="headerlink" title="JSON解析方式"></a>JSON解析方式</h2><h3 id="Android-Studio自带org-json解析"><a href="#Android-Studio自带org-json解析" class="headerlink" title="Android Studio自带org.json解析"></a>Android Studio自带org.json解析</h3><ul><li>解析原理：基于文档驱动，需要把全部文件读入到内存中，然后遍历所有数据，根据需要检索想要的数据</li><li>具体使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成JSON</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createJson</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(getFilesDir(), <span class="string">"orgjson.json"</span>);<span class="comment">//获取到应用在内部的私有文件夹下对应的orgjson.json文件</span></span><br><span class="line">        JSONObject student = <span class="keyword">new</span> JSONObject();<span class="comment">//实例化一个JSONObject对象</span></span><br><span class="line">        student.put(<span class="string">"name"</span>, <span class="string">"OrgJson"</span>);<span class="comment">//对其添加一个数据</span></span><br><span class="line">        student.put(<span class="string">"sax"</span>, <span class="string">"男"</span>);</span><br><span class="line">        student.put(<span class="string">"age"</span>, <span class="number">23</span>);</span><br><span class="line">        JSONObject course1 = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        course1.put(<span class="string">"name"</span>, <span class="string">"语文"</span>);</span><br><span class="line">        course1.put(<span class="string">"score"</span>, <span class="number">98.2f</span>);</span><br><span class="line">        JSONObject course2 = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        course2.put(<span class="string">"name"</span>, <span class="string">"数学"</span>);</span><br><span class="line">        course2.put(<span class="string">"score"</span>, <span class="number">93.2f</span>);</span><br><span class="line">        JSONArray coures = <span class="keyword">new</span> JSONArray();<span class="comment">//实例化一个JSON数组</span></span><br><span class="line">        coures.put(<span class="number">0</span>, course1);<span class="comment">//将course1添加到JSONArray，下标为0</span></span><br><span class="line">        coures.put(<span class="number">1</span>, course2);</span><br><span class="line">        <span class="comment">//然后将JSONArray添加到名为student的JSONObject</span></span><br><span class="line">        student.put(<span class="string">"courses"</span>, coures);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        fos.write(student.toString().getBytes());</span><br><span class="line">        fos.close();</span><br><span class="line">        Log.i(TAG, <span class="string">"createJson: "</span> + student.toString());</span><br><span class="line">        Toast.makeText(context, <span class="string">"创建成功"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析JSON</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseJson</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(getFilesDir(), <span class="string">"orgjson.json"</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String line;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != (line = br.readLine())) &#123;</span><br><span class="line">            sb.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//利用JSONObject进行解析</span></span><br><span class="line">        JSONObject stuJsonObject = <span class="keyword">new</span> JSONObject(sb.toString());</span><br><span class="line">        <span class="comment">//为什么不用getString?</span></span><br><span class="line">        <span class="comment">//optString会在得不到你想要的值时候返回空字符串""，而getString会抛出异常</span></span><br><span class="line">        String name = stuJsonObject.optString(<span class="string">"name"</span>, <span class="string">""</span>);</span><br><span class="line">        student.setName(name);</span><br><span class="line">        student.setSax(stuJsonObject.optString(<span class="string">"sax"</span>, <span class="string">"男"</span>));</span><br><span class="line">        student.setAge(stuJsonObject.optInt(<span class="string">"age"</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数组数据</span></span><br><span class="line">        JSONArray couresJson = stuJsonObject.optJSONArray(<span class="string">"courses"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; couresJson.length(); i++) &#123;</span><br><span class="line">            JSONObject courseJsonObject = couresJson.getJSONObject(i);</span><br><span class="line">            Course course = <span class="keyword">new</span> Course();</span><br><span class="line">            course.setName(courseJsonObject.optString(<span class="string">"name"</span>, <span class="string">""</span>));</span><br><span class="line">            course.setScore((<span class="keyword">float</span>) courseJsonObject.optDouble(<span class="string">"score"</span>, <span class="number">0</span>));</span><br><span class="line">            student.addCourse(course);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"parseJson: "</span> + student);</span><br><span class="line">        Toast.makeText(context, <span class="string">"解析成功"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Gson-解析"><a href="#Gson-解析" class="headerlink" title="Gson 解析"></a>Gson 解析</h3><ul><li>解析原理：基于事件驱动</li><li>解析流程：根据所需取的数据 建立1个对应于JSON数据的JavaBean类，即可通过简单操作解析出所需数据</li><li>Gson 不要求JavaBean类里面的属性一定全部和JSON数据里的所有key相同，可以按需取数据</li><li>具体实现</li></ul><ol><li>创建一个与JSON数据对应的JavaBean类（用作存储需要解析的数据）<ul><li>JSON的大括号对应一个对象<ul><li>对象里面有key,value</li><li>JavaBean的类属性名 = key</li></ul></li><li>JSON的方括号对应一个数组</li><li>JavaBean里面对应的也是数组</li><li>对象里 可以有值/对象</li><li>若对象里面只有值，没有key,则说明是纯数组，对应JavaBean里的数组类型</li><li>若对象里面有值和key,则说明是对象数组，对应JavaBean里的内部类     </li><li>对象嵌套 <ul><li>建立内部类 该内部类对象的名字 = 父对象的key ,类似对象数组</li><li></li></ul></li></ul></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="attr">"simpleArray"</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  <span class="attr">"arrays"</span>: [</span><br><span class="line">    [&#123;</span><br><span class="line">      <span class="attr">"arrInnerClsKey"</span>: <span class="string">"arrInnerClsValue"</span>,</span><br><span class="line">      <span class="attr">"arrInnerClsKeyNub"</span>: <span class="number">1</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"innerclass"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"zero"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"sax"</span>: <span class="string">"男"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转化成JavaBean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> InnerclassBean innerclass;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; simpleArray;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;ArraysBean&gt;&gt; arrays;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerclassBean <span class="title">getInnerclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInnerclass</span><span class="params">(InnerclassBean innerclass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.innerclass = innerclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getSimpleArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> simpleArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSimpleArray</span><span class="params">(List&lt;Integer&gt; simpleArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.simpleArray = simpleArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;ArraysBean&gt;&gt; getArrays() &#123;</span><br><span class="line">        <span class="keyword">return</span> arrays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArrays</span><span class="params">(List&lt;List&lt;ArraysBean&gt;&gt; arrays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrays = arrays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerclassBean</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String sax;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sax;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSax</span><span class="params">(String sax)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sax = sax;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysBean</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> String arrInnerClsKey;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> arrInnerClsKeyNub;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getArrInnerClsKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arrInnerClsKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArrInnerClsKey</span><span class="params">(String arrInnerClsKey)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arrInnerClsKey = arrInnerClsKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArrInnerClsKeyNub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arrInnerClsKeyNub;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArrInnerClsKeyNub</span><span class="params">(<span class="keyword">int</span> arrInnerClsKeyNub)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arrInnerClsKeyNub = arrInnerClsKeyNub;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用例子</li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"Zero"</span>);</span><br><span class="line">        student.setSax(<span class="string">"男"</span>);</span><br><span class="line">        student.setAge(<span class="number">28</span>);</span><br><span class="line">        student.addCourse(<span class="keyword">new</span> Course(<span class="string">"英语"</span>, <span class="number">78.3f</span>));</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        <span class="comment">//1. 生成json文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(CurPath + <span class="string">"/gsonjsontest.json"</span>);</span><br><span class="line">        OutputStream oot = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        JsonWriter jw = <span class="keyword">new</span> JsonWriter(<span class="keyword">new</span> OutputStreamWriter(oot, <span class="string">"utf-8"</span>));</span><br><span class="line">        gson.toJson(student, <span class="keyword">new</span> TypeToken&lt;Student&gt;() &#123;</span><br><span class="line">        &#125;.getType(), jw);</span><br><span class="line">        jw.flush();</span><br><span class="line">        jw.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Student student1 = gson.fromJson(<span class="keyword">new</span> JsonReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file)))</span><br><span class="line">                , <span class="keyword">new</span> TypeToken&lt;Student&gt;() &#123;</span><br><span class="line">                &#125;.getType());</span><br><span class="line">        System.out.println(student1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Jackson解析"><a href="#Jackson解析" class="headerlink" title="Jackson解析"></a>Jackson解析</h3><ul><li>解析原理：基于事件驱动</li><li>解析过程：<ol><li>类似 GSON，先创建1个对应于JSON数据的JavaBean类，再通过简单操作即可解析</li><li>与 Gson解析不同的是：GSON可按需解析，即创建的JavaBean类不一定完全涵盖所要解析的JSON数据，按需创建属性；但Jackson解析对应的JavaBean必须把Json数据里面的所有key都有所对应，即必须把JSON内的数据所有解析出来，无法按需解析</li></ol></li><li>导入Jackson依赖</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何配置jackson https://mvnrepository.com/search?q=jackson</span></span><br><span class="line">    implementation <span class="string">'com.fasterxml.jackson.core:jackson-databind:2.9.8'</span></span><br><span class="line">    implementation <span class="string">'com.fasterxml.jackson.core:jackson-core:2.9.8'</span></span><br><span class="line">    implementation <span class="string">'com.fasterxml.jackson.core:jackson-annotations:2.9.8'</span></span><br></pre></td></tr></table></figure><ul><li>使用Jackson解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"杰克逊"</span>);</span><br><span class="line">        student.setSax(<span class="string">"男"</span>);</span><br><span class="line">        student.setAge(<span class="number">28</span>);</span><br><span class="line">        student.addCourse(<span class="keyword">new</span> Course(<span class="string">"英语"</span>, <span class="number">78.3f</span>));</span><br><span class="line">        student.addCourse(<span class="keyword">new</span> Course(<span class="string">"语文"</span>, <span class="number">88.9f</span>));</span><br><span class="line">        student.addCourse(<span class="keyword">new</span> Course(<span class="string">"数学"</span>, <span class="number">48.2f</span>));</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//jackson序列化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(CurPath + <span class="string">"/jacksontest.json"</span>);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        objectMapper.writeValue(fileOutputStream, student);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Student student1 = objectMapper.readValue(file, Student.class);</span><br><span class="line">        System.out.println(student1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        HashMap&lt;String, Student&gt; studentHashMap = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Student stu1 = new Student("King", "男", 32);</span></span><br><span class="line"><span class="comment">//        stu1.addCourse(new Course("物理", 68.9f));</span></span><br><span class="line"><span class="comment">//        Student stu2 = new Student("Mark", "男", 33);</span></span><br><span class="line"><span class="comment">//        studentHashMap.put("key1", stu1);</span></span><br><span class="line"><span class="comment">//        studentHashMap.put("key2", stu2);</span></span><br><span class="line"><span class="comment">//        System.out.println("studentHashMap:\n" + studentHashMap);</span></span><br><span class="line"><span class="comment">//        JacksonUtil.encode2File(studentHashMap,CurPath + "/jacksontest1.json");</span></span><br><span class="line"><span class="comment">//        String jsonStr = JacksonUtil.encode(studentHashMap);</span></span><br><span class="line"><span class="comment">//        System.out.println(jsonStr);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化 TypeReference用法</span></span><br><span class="line"><span class="comment">//        HashMap&lt;String,Student&gt; studentHashMap1 = objectMapper.readValue(jsonStr,HashMap.class);//错误做法</span></span><br><span class="line">        <span class="comment">//正确的方式</span></span><br><span class="line"><span class="comment">//        HashMap&lt;String,Student&gt; studentHashMap1 = objectMapper.readValue(jsonStr, new TypeReference&lt;HashMap&lt;String,Student&gt;&gt;()&#123;&#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println("studentHashMap1:\n" + studentHashMap1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//List</span></span><br><span class="line"><span class="comment">//        List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        studentList.add(stu1);</span></span><br><span class="line"><span class="comment">//        studentList.add(stu2);</span></span><br><span class="line"><span class="comment">//        JacksonUtil.encode2File(studentList, CurPath + "/jacksontest2.json");</span></span><br><span class="line"><span class="comment">//        String jsonStr2 = JacksonUtil.encode(studentList);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        List&lt;Student&gt; studentList1 = objectMapper.readValue(jsonStr2, objectMapper.getTypeFactory().constructParametricType(ArrayList.class, Student.class));</span></span><br><span class="line"><span class="comment">//        System.out.println("studentList1:\n" + studentList1);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Fastjson解析"><a href="#Fastjson解析" class="headerlink" title="Fastjson解析"></a>Fastjson解析</h3><ul><li>导入Fastjson依赖</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.alibaba:fastjson:1.2.57'</span></span><br></pre></td></tr></table></figure><ul><li>使用Fastjson解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">       Student student = <span class="keyword">new</span> Student();</span><br><span class="line">       student.setName(<span class="string">"FastJson"</span>);</span><br><span class="line">       student.setSax(<span class="string">"男"</span>);</span><br><span class="line">       student.setAge(<span class="number">28</span>);</span><br><span class="line">       student.addCourse(<span class="keyword">new</span> Course(<span class="string">"英语"</span>, <span class="number">78.3f</span>));</span><br><span class="line">       student.addCourse(<span class="keyword">new</span> Course(<span class="string">"语文"</span>, <span class="number">88.9f</span>));</span><br><span class="line">       student.addCourse(<span class="keyword">new</span> Course(<span class="string">"数学"</span>, <span class="number">48.2f</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1. 生成json文件</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(CurPath + <span class="string">"/fastjsontest.json"</span>);</span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">       JSONObject.writeJSONString(fileOutputStream,student);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2. 反序列化</span></span><br><span class="line">       Student student1 = JSONObject.parseObject(<span class="keyword">new</span> FileInputStream(file),Student.class);</span><br><span class="line">       System.out.println(student1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="自定义一个JSON解析库"><a href="#自定义一个JSON解析库" class="headerlink" title="自定义一个JSON解析库"></a>自定义一个JSON解析库</h2><p>编写一个JSON解析器实际上就是一个方法，它的输入是一个表示JSON的字符串，输出是结构化的对应到语言本身的数据结构<br>一般来说，解析过程包括词法分析和语法分析两个阶段。词法分析阶段的目标是按照构词规则将 JSON 字符串解析成 Token 流，比如有如下的 JSON 字符串：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"key"</span> : <span class="string">"value"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果词法分析后，得到一组 Token，如下：<br>{key : value, }</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133413279.png" alt="cifafenxi.png"><br>词法分析解析出 Token 序列后，接下来要进行语法分析。语法分析的目的是根据 JSON 文法检查上面 Token 序列所构成的 JSON 结构是否合法。比如 JSON 文法要求非空 JSON 对象以键值对的形式出现，形如 object = {string : value}。如果传入了一个格式错误的字符串，比如</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "key", "value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在语法分析阶段，语法分析器分析完 Token name后，认为它是一个符合规则的 Token，并且认为它是一个键。接下来，语法分析器读取下一个 Token，期望这个 Token 是 :。但当它读取了这个 Token，发现这个 Token 是 ,，并非其期望的:，于是文法分析器就会报错误。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133415916.png" alt="yufafenxi.png"></p><h3 id="JSON解析分析小结"><a href="#JSON解析分析小结" class="headerlink" title="JSON解析分析小结"></a>JSON解析分析小结</h3><ol><li>通过词法分析是将字符串解析成一组 Token 序列</li><li>然后通过语法分析检查输入的 Token 序列所构成的 JSON 格式是否合法</li></ol><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>按照“构词规则”将 JSON 字符串解析成 Token 流。请注意双引号引起来词–构词规则，所谓构词规则是指词法分析模块在将字符串解析成 Token 时所参考的规则。在 JSON 中，构词规则对应于几种数据类型，当词法解析器读入某个词，且这个词类型符合 JSON 所规定的数据类型时，词法分析器认为这个词符合构词规则，就会生成相应的 Token。这里我们可以参考<a href="http://www.json.org/对" target="_blank" rel="noopener">http://www.json.org/对</a> JSON 的定义，罗列一下 JSON 所规定的数据类型：</p><ul><li>BEGIN_OBJECT（{）</li><li>END_OBJECT（}）</li><li>BEGIN_ARRAY（[）</li><li>END_ARRAY（]）</li><li>NULL（null）</li><li>NUMBER（数字）</li><li>STRING（字符串）</li><li>BOOLEAN（true/false）</li><li>SEP_COLON（:）</li><li>SEP_COMMA（,）</li></ul><p>当词法分析器读取的词是上面类型中的一种时，即可将其解析成一个 Token。我们可以定义一个枚举类来表示上面的数据类型，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TokenType &#123;</span><br><span class="line">    BEGIN_OBJECT(<span class="number">1</span>),</span><br><span class="line">    END_OBJECT(<span class="number">2</span>),</span><br><span class="line">    BEGIN_ARRAY(<span class="number">4</span>),</span><br><span class="line">    END_ARRAY(<span class="number">8</span>),</span><br><span class="line">    NULL(<span class="number">16</span>),</span><br><span class="line">    NUMBER(<span class="number">32</span>),</span><br><span class="line">    STRING(<span class="number">64</span>),</span><br><span class="line">    BOOLEAN(<span class="number">128</span>),</span><br><span class="line">    SEP_COLON(<span class="number">256</span>),</span><br><span class="line">    SEP_COMMA(<span class="number">512</span>),</span><br><span class="line">    END_DOCUMENT(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    TokenType(<span class="keyword">int</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTokenCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析过程中，仅有 TokenType 类型还不行。我们除了要将某个词的类型保存起来，还需要保存这个词的字面量。所以，所以这里还需要定义一个 Token 类。用于封装词类型和字面量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TokenType tokenType;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="comment">// 省略不重要的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好了 Token 类，接下来再来定义一个读取字符串的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pos = Math.max(<span class="number">0</span>, --pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMore</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fillBuffer();</span><br><span class="line">        <span class="keyword">return</span> pos &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = reader.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 TokenType、Token 和 CharReader 这三个辅助类，接下来我们就可以实现词法解析器了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tokenizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CharReader charReader;</span><br><span class="line">    <span class="keyword">private</span> TokenList tokens;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenList <span class="title">tokenize</span><span class="params">(CharReader charReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charReader = charReader;</span><br><span class="line">        tokens = <span class="keyword">new</span> TokenList();</span><br><span class="line">        tokenize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tokenize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用do-while处理空文件</span></span><br><span class="line">        Token token;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            token = start();</span><br><span class="line">            tokens.add(token);</span><br><span class="line">        &#125; <span class="keyword">while</span> (token.getTokenType() != TokenType.END_DOCUMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Token <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!charReader.hasMore()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.END_DOCUMENT, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch = charReader.next();</span><br><span class="line">            <span class="keyword">if</span> (!isWhiteSpace(ch)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.BEGIN_OBJECT, String.valueOf(ch));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.END_OBJECT, String.valueOf(ch));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.BEGIN_ARRAY, String.valueOf(ch));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.END_ARRAY, String.valueOf(ch));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.SEP_COMMA, String.valueOf(ch));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">':'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.SEP_COLON, String.valueOf(ch));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">                <span class="keyword">return</span> readBoolean();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                <span class="keyword">return</span> readString();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">return</span> readNumber();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDigit(ch)) &#123;</span><br><span class="line">            <span class="keyword">return</span> readNumber();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(<span class="string">"Illegal character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Token <span class="title">readNull</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Token <span class="title">readBoolean</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Token <span class="title">readString</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Token <span class="title">readNumber</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是词法分析器的实现，部分代码这里没有贴出来，后面具体分析的时候再贴。先来看看词法分析器的核心方法 start，这个方法代码量不多，并不复杂。其通过一个死循环不停的读取字符，然后再根据字符的类型，执行不同的解析逻辑。上面说过，JSON 的解析过程比较简单。原因在于，在解析时，只需通过每个词第一个字符即可判断出这个词的 Token Type。比如：</p><ul><li>第一个字符是{、}、[、]、,、:，直接封装成相应的 Token 返回即可</li><li>第一个字符是n，期望这个词是null，Token 类型是NULL</li><li>第一个字符是t或f，期望这个词是true或者false，Token 类型是 BOOLEAN</li><li>第一个字符是”，期望这个词是字符串，Token 类型为String</li><li>第一个字符是0~9或-，期望这个词是数字，类型为NUMBER<br>正如上面所说，词法分析器只需要根据每个词的第一个字符，即可知道接下来它所期望读取的到的内容是什么样的。如果满足期望了，则返回 Token，否则返回错误。下面就来看看词法解析器在碰到第一个字符是n和”时的处理过程。先看碰到字符n的处理过程：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Token <span class="title">readNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(charReader.next() == <span class="string">'u'</span> &amp;&amp; charReader.next() == <span class="string">'l'</span> &amp;&amp; charReader.next() == <span class="string">'l'</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(<span class="string">"Invalid json string"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Token(TokenType.NULL, <span class="string">"null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，词法分析器在读取字符n后，期望后面的三个字符分别是u,l,l，与 n 组成词 null。如果满足期望，则返回类型为 NULL 的 Token，否则报异常。readNull 方法逻辑很简单，不多说了。接下来看看 string 类型的数据处理过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private Token readString() throws IOException &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        char ch = charReader.next();</span><br><span class="line">        // 处理转义字符</span><br><span class="line">        if (ch == &apos;\\&apos;) &#123;</span><br><span class="line">            if (!isEscape()) &#123;</span><br><span class="line">                throw new JsonParseException(&quot;Invalid escape character&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(&apos;\\&apos;);</span><br><span class="line">            ch = charReader.peek();</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            // 处理 Unicode 编码，形如 \u4e2d。且只支持 \u0000 ~ \uFFFF 范围内的编码</span><br><span class="line">            if (ch == &apos;u&apos;) &#123;</span><br><span class="line">                for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                    ch = charReader.next();</span><br><span class="line">                    if (isHex(ch)) &#123;</span><br><span class="line">                        sb.append(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new JsonParseException(&quot;Invalid character&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (ch == &apos;&quot;&apos;) &#123;    // 碰到另一个双引号，则认为字符串解析结束，返回 Token</span><br><span class="line">            return new Token(TokenType.STRING, sb.toString());</span><br><span class="line">        &#125; else if (ch == &apos;\r&apos; || ch == &apos;\n&apos;) &#123;    // 传入的 JSON 字符串不允许换行</span><br><span class="line">            throw new JsonParseException(&quot;Invalid character&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isEscape() throws IOException &#123;</span><br><span class="line">    char ch = charReader.next();</span><br><span class="line">    return (ch == &apos;&quot;&apos; || ch == &apos;\\&apos; || ch == &apos;u&apos; || ch == &apos;r&apos;</span><br><span class="line">                || ch == &apos;n&apos; || ch == &apos;b&apos; || ch == &apos;t&apos; || ch == &apos;f&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isHex(char ch) &#123;</span><br><span class="line">    return ((ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) || (&apos;a&apos; &lt;= ch &amp;&amp; ch &lt;= &apos;f&apos;)</span><br><span class="line">            || (&apos;A&apos; &lt;= ch &amp;&amp; ch &lt;= &apos;F&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string 类型的数据解析起来要稍微复杂一些，主要是需要处理一些特殊类型的字符。JSON 所允许的特殊类型的字符如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\&quot;</span><br><span class="line">\\</span><br><span class="line">\b</span><br><span class="line">\f</span><br><span class="line">\n</span><br><span class="line">\r</span><br><span class="line">\t</span><br><span class="line">\u four-hex-digits</span><br><span class="line">\/</span><br></pre></td></tr></table></figure><p>最后一种特殊字符\/代码中未做处理，其他字符均做了判断，判断逻辑在 isEscape 方法中。在传入 JSON 字符串中，仅允许字符串包含上面所列的转义字符。如果乱传转义字符，解析时会报错。对于 STRING 类型的词，解析过程始于字符”，也终于”。所以在解析的过程中，当再次遇到字符”，readString 方法会认为本次的字符串解析过程结束，并返回相应类型的 Token。</p><p>上面说了 null 类型和 string 类型的数据解析过程，过程并不复杂，理解起来应该不难。至于 boolean 和 number 类型的数据解析过程，大家有兴趣的话可以自己看源码，这里就不在说了。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>当词法分析结束后，且分析过程中没有抛出错误，那么接下来就可以进行语法分析了。语法分析过程以词法分析阶段解析出的 Token 序列作为输入，输出 JSON Object 或 JSON Array。语法分析器的实现的文法如下：<br>当词法分析结束后，且分析过程中没有抛出错误，那么接下来就可以进行语法分析了。语法分析过程以词法分析阶段解析出的 Token 序列作为输入，输出 JSON Object 或 JSON Array。语法分析器的实现的文法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">object = &#123;&#125;</span><br><span class="line">       | &#123; members &#125;</span><br><span class="line"></span><br><span class="line">members = pair</span><br><span class="line">        | pair , members</span><br><span class="line"></span><br><span class="line">pair = string : value</span><br><span class="line"></span><br><span class="line">array = []</span><br><span class="line">      | [ elements ]</span><br><span class="line"></span><br><span class="line">elements = value </span><br><span class="line">         | value , elements</span><br><span class="line"></span><br><span class="line">value = string</span><br><span class="line">      | number</span><br><span class="line">      | object</span><br><span class="line">      | array</span><br><span class="line">      | true</span><br><span class="line">      | false</span><br><span class="line">      | null</span><br><span class="line"></span><br><span class="line">string = &quot;&quot;</span><br><span class="line">       | &quot; chars &quot;</span><br><span class="line"></span><br><span class="line">chars = char</span><br><span class="line">      | char chars</span><br><span class="line"></span><br><span class="line">char = any-Unicode-character-except-&quot;-or-\-or- control-character</span><br><span class="line">     | \&quot;</span><br><span class="line">     | \\</span><br><span class="line">     | \/</span><br><span class="line">     | \b</span><br><span class="line">     | \f</span><br><span class="line">     | \n</span><br><span class="line">     | \r</span><br><span class="line">     | \t</span><br><span class="line">     | \u four-hex-digits</span><br><span class="line"></span><br><span class="line">number = int</span><br><span class="line">       | int frac</span><br><span class="line">       | int exp</span><br><span class="line">       | int frac exp</span><br><span class="line"></span><br><span class="line">int = digit</span><br><span class="line">    | digit1-9 digits </span><br><span class="line">    | - digit</span><br><span class="line">    | - digit1-9 digits</span><br><span class="line"></span><br><span class="line">frac = . digits</span><br><span class="line"></span><br><span class="line">exp = e digits</span><br><span class="line"></span><br><span class="line">digits = digit</span><br><span class="line">       | digit digits</span><br><span class="line"></span><br><span class="line">e = e</span><br><span class="line">  | e+</span><br><span class="line">  | e-</span><br><span class="line">  | E</span><br><span class="line">  | E+</span><br><span class="line">  | E-</span><br></pre></td></tr></table></figure><p>语法分析器的实现需要借助两个辅助类，也就是语法分析器的输出类，分别是 JsonObject 和 JsonArray。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map.Entry&lt;String, Object&gt;&gt; getAllKeyValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonObject <span class="title">getJsonObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> JsonObject)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JsonTypeException(<span class="string">"Type of value is not JsonObject"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (JsonObject) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonArray <span class="title">getJsonArray</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> JsonArray)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JsonTypeException(<span class="string">"Type of value is not JsonArray"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (JsonArray) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BeautifyJsonUtils.beautify(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonArray</span> <span class="keyword">implements</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonObject <span class="title">getJsonObject</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> JsonObject)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JsonTypeException(<span class="string">"Type of value is not JsonObject"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (JsonObject) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonArray <span class="title">getJsonArray</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> JsonArray)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JsonTypeException(<span class="string">"Type of value is not JsonArray"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (JsonArray) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BeautifyJsonUtils.beautify(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法解析器的核心逻辑封装在了 parseJsonObject 和 parseJsonArray 两个方法中，接下来我会详细分析 parseJsonObject 方法，parseJsonArray 方法大家自己分析吧。parseJsonObject 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JsonObject <span class="title">parseJsonObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JsonObject jsonObject = <span class="keyword">new</span> JsonObject();</span><br><span class="line">    <span class="keyword">int</span> expectToken = STRING_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">    String key = <span class="keyword">null</span>;</span><br><span class="line">    Object value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (tokens.hasMore()) &#123;</span><br><span class="line">        Token token = tokens.next();</span><br><span class="line">        TokenType tokenType = token.getTokenType();</span><br><span class="line">        String tokenValue = token.getValue();</span><br><span class="line">        <span class="keyword">switch</span> (tokenType) &#123;</span><br><span class="line">        <span class="keyword">case</span> BEGIN_OBJECT:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            jsonObject.put(key, parseJsonObject());    <span class="comment">// 递归解析 json object</span></span><br><span class="line">            expectToken = SEP_COMMA_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> END_OBJECT:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            <span class="keyword">return</span> jsonObject;</span><br><span class="line">        <span class="keyword">case</span> BEGIN_ARRAY:    <span class="comment">// 解析 json array</span></span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            jsonObject.put(key, parseJsonArray());</span><br><span class="line">            expectToken = SEP_COMMA_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NULL:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            jsonObject.put(key, <span class="keyword">null</span>);</span><br><span class="line">            expectToken = SEP_COMMA_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NUMBER:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            <span class="keyword">if</span> (tokenValue.contains(<span class="string">"."</span>) || tokenValue.contains(<span class="string">"e"</span>) || tokenValue.contains(<span class="string">"E"</span>)) &#123;</span><br><span class="line">                jsonObject.put(key, Double.valueOf(tokenValue));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Long num = Long.valueOf(tokenValue);</span><br><span class="line">                <span class="keyword">if</span> (num &gt; Integer.MAX_VALUE || num &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                    jsonObject.put(key, num);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    jsonObject.put(key, num.intValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            expectToken = SEP_COMMA_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            jsonObject.put(key, Boolean.valueOf(token.getValue()));</span><br><span class="line">            expectToken = SEP_COMMA_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STRING:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            Token preToken = tokens.peekPrevious();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 在 JSON 中，字符串既可以作为键，也可作为值。</span></span><br><span class="line"><span class="comment">             * 作为键时，只期待下一个 Token 类型为 SEP_COLON。</span></span><br><span class="line"><span class="comment">             * 作为值时，期待下一个 Token 类型为 SEP_COMMA 或 END_OBJECT</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (preToken.getTokenType() == TokenType.SEP_COLON) &#123;</span><br><span class="line">                value = token.getValue();</span><br><span class="line">                jsonObject.put(key, value);</span><br><span class="line">                expectToken = SEP_COMMA_TOKEN | END_OBJECT_TOKEN;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key = token.getValue();</span><br><span class="line">                expectToken = SEP_COLON_TOKEN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEP_COLON:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            expectToken = NULL_TOKEN | NUMBER_TOKEN | BOOLEAN_TOKEN | STRING_TOKEN</span><br><span class="line">                    | BEGIN_OBJECT_TOKEN | BEGIN_ARRAY_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEP_COMMA:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            expectToken = STRING_TOKEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> END_DOCUMENT:</span><br><span class="line">            checkExpectToken(tokenType, expectToken);</span><br><span class="line">            <span class="keyword">return</span> jsonObject;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(<span class="string">"Unexpected Token."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(<span class="string">"Parse error, invalid Token."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExpectToken</span><span class="params">(TokenType tokenType, <span class="keyword">int</span> expectToken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((tokenType.getTokenCode() &amp; expectToken) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(<span class="string">"Parse error, invalid Token."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseJsonObject 方法解析流程大致如下：</p><ol><li>读取一个 Token，检查这个 Token 是否是其所期望的类型</li><li>如果是，更新期望的 Token 类型。否则，抛出异常，并退出</li><li>重复步骤1和2，直至所有的 Token 都解析完，或出现异常<br>上面的步骤并不复杂，但有可能不好理解。这里举个例子说明一下，有如下的 Token 序列：</li></ol><p>{、 id、 :、 1、 }</p><p>parseJsonObject 解析完 { Token 后，接下来它将期待 STRING 类型的 Token 或者 END_OBJECT 类型的 Token 出现。于是 parseJsonObject 读取了一个新的 Token，发现这个 Token 的类型是 STRING 类型，满足期望。于是 parseJsonObject 更新期望Token 类型为 SEL_COLON，即:。如此循环下去，直至 Token 序列解析结束或者抛出异常退出。</p><p>上面的解析流程虽然不是很复杂，但在具体实现的过程中，还是需要注意一些细节问题。比如：</p><ol><li>在 JSON 中，字符串既可以作为键，也可以作为值。作为键时，语法分析器期待下一个 Token 类型为 SEP_COLON。而作为值时，则期待下一个 Token 类型为 SEP_COMMA 或 END_OBJECT。所以这里要判断该字符串是作为键还是作为值，判断方法也比较简单，即判断上一个 Token 的类型即可。如果上一个 Token 是 SEP_COLON，即:，那么此处的字符串只能作为值了。否则，则只能做为键。</li><li>对于整数类型的 Token 进行解析时，简单点处理，可以直接将该整数解析成 Long 类型。但考虑到空间占用问题，对于 [Integer.MIN_VALUE, Integer.MAX_VALUE] 范围内的整数来说，解析成 Integer 更为合适，所以解析的过程中也需要注意一下。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://segmentfault.com/a/1190000010998941#articleHeader1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010998941#articleHeader1</a></p></blockquote><h2 id="Gson原理解析"><a href="#Gson原理解析" class="headerlink" title="Gson原理解析"></a>Gson原理解析</h2><p>在这个序列化和反序列化的过程中，</p><p>充当的了一个解析器的角色</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133429772.png" alt="gson.png"></p><h3 id="JsonElement"><a href="#JsonElement" class="headerlink" title="JsonElement"></a>JsonElement</h3><p>该类是一个抽象类，代表着json串的某一个元素。这个元素可以是一个Json(JsonObject)、可以是一个数组(JsonArray)、可以是一个Java的基本类型(JsonPrimitive)、当然也可以为null(JsonNull);JsonObject,JsonArray,JsonPrimitive，JsonNull都是JsonElement这个抽象类的子类。JsonElement提供了一系列的方法来判断当前的JsonElement</p><p>各个JsonElement的关系可以用如下图表示：<br><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133433270.png" alt="jsonelement.png"></p><p>JsonObject对象可以看成 name/values的集合，而这写values就是一个个JsonElement,他们的结构可以用如下图表示：<br><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133435965.png" alt="jsonelement1.png"></p><h3 id="JsonDeserializer的工作原理"><a href="#JsonDeserializer的工作原理" class="headerlink" title="JsonDeserializer的工作原理"></a>JsonDeserializer的工作原理</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133438467.png" alt="deserize.png"></p><h3 id="TypeAdapter的工作原理"><a href="#TypeAdapter的工作原理" class="headerlink" title="TypeAdapter的工作原理"></a>TypeAdapter的工作原理</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133441446.png" alt="typeadapter.png"></p><h3 id="Gson的整体解析原理"><a href="#Gson的整体解析原理" class="headerlink" title="Gson的整体解析原理"></a>Gson的整体解析原理</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133444236.png" alt="gson1.png"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133448072.png" alt="gsonwork.png"></p><h3 id="Gson的反射解析机制"><a href="#Gson的反射解析机制" class="headerlink" title="Gson的反射解析机制"></a>Gson的反射解析机制</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133452928.png" alt="json_refect.png"></p><h2 id="Gson解析常见的错误"><a href="#Gson解析常见的错误" class="headerlink" title="Gson解析常见的错误"></a>Gson解析常见的错误</h2><ul><li>Expected BEGIN_ARRAY but was STRING at line 1 column 27<br>这种错误一般都是原来是一个字段需要是数组类型，但是事实上给的是””,导致的</li></ul><p>-解决办法</p><ol><li>让返回null即可解决问题</li><li>用Gson自带的解决方案</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonError1Deserializer</span> <span class="keyword">implements</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">GsonError1</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> GsonError1 <span class="title">deserialize</span><span class="params">(JsonElement json, Type typeOfT, JsonDeserializationContext context)</span> <span class="keyword">throws</span> JsonParseException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> JsonObject jsonObject = json.getAsJsonObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> JsonElement jsonTitle = jsonObject.get(<span class="string">"name"</span>);</span><br><span class="line">            <span class="keyword">final</span> String name = jsonTitle.getAsString();</span><br><span class="line"></span><br><span class="line">            JsonElement jsonAuthors = jsonObject.get(<span class="string">"authors"</span>);</span><br><span class="line"></span><br><span class="line">            GsonError1 gsonError1 = <span class="keyword">new</span> GsonError1();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jsonAuthors.isJsonArray()) &#123;<span class="comment">//如果数组类型，此种情况是我们需要的</span></span><br><span class="line">                <span class="comment">//关于context在文章最后有简单说明</span></span><br><span class="line">                GsonError1.AuthorsBean[] authors = context.deserialize(jsonAuthors, GsonError1.AuthorsBean[].class);</span><br><span class="line">                gsonError1.setAuthors(Arrays.asList(authors));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//此种情况为无效情况</span></span><br><span class="line">                gsonError1.setAuthors(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            gsonError1.setName(name);</span><br><span class="line">            <span class="keyword">return</span> gsonError1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorDeserializer</span> <span class="keyword">implements</span> <span class="title">JsonDeserializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(JsonElement json, Type typeOfT, JsonDeserializationContext context)</span> <span class="keyword">throws</span> JsonParseException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> JsonObject jsonObject = json.getAsJsonObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> GsonError1.AuthorsBean author = <span class="keyword">new</span> GsonError1.AuthorsBean();</span><br><span class="line">            author.setId(jsonObject.get(<span class="string">"id"</span>).getAsString());</span><br><span class="line">            author.setName(jsonObject.get(<span class="string">"name"</span>).getAsString());</span><br><span class="line">            <span class="keyword">return</span> author;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">//        test1();</span></span><br><span class="line"><span class="comment">//        test2();</span></span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        String json = <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"    \"name\": \"java\",\n"</span> +</span><br><span class="line">                <span class="string">"    \"authors\": [\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"id\": \"1'\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"name\": \"Joshua Bloch'\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;,\n"</span> +</span><br><span class="line">                <span class="string">"        &#123;\n"</span> +</span><br><span class="line">                <span class="string">"            \"id\": \"2'\",\n"</span> +</span><br><span class="line">                <span class="string">"            \"name\": \"Tom\"\n"</span> +</span><br><span class="line">                <span class="string">"        &#125;\n"</span> +</span><br><span class="line">                <span class="string">"    ]\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        GsonError1 gsonError1 = gson.fromJson(json, GsonError1.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(gsonError1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        String json = <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"    \"name\": \"java\",\n"</span> +</span><br><span class="line">                <span class="string">"    \"authors\": \"\"\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        GsonError1 gsonError1 = gson.fromJson(json, GsonError1.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(gsonError1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        String json = <span class="string">"&#123;\n"</span> +</span><br><span class="line">                <span class="string">"    \"name\": \"java\",\n"</span> +</span><br><span class="line">                <span class="string">"    \"authors\": \"\"\n"</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        GsonBuilder gsonBuilder = <span class="keyword">new</span> GsonBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册TypeAdapter</span></span><br><span class="line">        gsonBuilder.registerTypeAdapter(GsonError1.class, <span class="keyword">new</span> GsonError1Deserializer());</span><br><span class="line">        gsonBuilder.registerTypeAdapter(GsonError1.AuthorsBean.class, <span class="keyword">new</span> AuthorDeserializer());</span><br><span class="line"></span><br><span class="line">        Gson gson = gsonBuilder.create();</span><br><span class="line">        GsonError1 gsonError1 = gson.fromJson(json, GsonError1.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(gsonError1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式&lt;/p&gt;
&lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;数据标记，存储，传输&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;读写速度快&lt;/li&gt;
&lt;li&gt;解析简单&lt;/li&gt;
&lt;li&gt;轻量级&lt;/li&gt;
&lt;li&gt;独立于语言，平台&lt;/li&gt;
&lt;li&gt;具有自我描叙性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;JSON解析&quot;&gt;&lt;a href=&quot;#JSON解析&quot; class=&quot;headerlink&quot; title=&quot;JSON解析&quot;&gt;&lt;/a&gt;JSON解析&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之json解析/1240-20200309133348995.png&quot; alt=&quot;jsonjiexiqi.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;JSON建构于两种结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。&lt;/li&gt;
&lt;li&gt;值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。&lt;/p&gt;
&lt;p&gt;JSON具有以下这些形式：&lt;/p&gt;
&lt;p&gt;对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133352592.gif&quot; alt=&quot;object.gif&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;英语&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;&quot;score&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;78.3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133355549.gif&quot; alt=&quot;array.gif&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&quot;courses&quot;: [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;英语&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;&quot;score&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;78.3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值（&lt;em&gt;value&lt;/em&gt;）可以是双引号括起来的字符串（&lt;em&gt;string&lt;/em&gt;）、数值(number)、&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;、 &lt;code&gt;null&lt;/code&gt;、对象（object）或者数组（array）。这些结构可以嵌套。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133358450.gif&quot; alt=&quot;value.gif&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;url&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;https://qqe2.com&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;欢迎使用JSON在线解析编辑器&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;array&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;JSON校验&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;http://jsonlint.qqe2.com/&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;Cron生成&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;http://cron.qqe2.com/&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;JS加密解密&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;http://edit.qqe2.com/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;boolean&quot;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;null&quot;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;number&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;object&quot;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;a&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;c&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;e&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;f&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;字符串（&lt;em&gt;string&lt;/em&gt;）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。&lt;/p&gt;
&lt;p&gt;字符串（&lt;strong&gt;string&lt;/strong&gt;）与C或者Java的字符串非常相似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133401457.gif&quot; alt=&quot;string.gif&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Zero&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数值（&lt;em&gt;number&lt;/em&gt;）也与C或者Java的数值非常相似。除去未曾使用的八进制与十六进制格式。除去一些编码细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之json解析/strip-20200309133404168.gif&quot; alt=&quot;number.gif&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="json" scheme="http://darryrzhong.xyz/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>java系列之xml解析</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8Bxml%E8%A7%A3%E6%9E%90/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之xml解析/</id>
    <published>2019-09-15T09:22:23.000Z</published>
    <updated>2020-03-09T05:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>XML，即 extensible Markup Language ，是一种数据标记语言 &amp; 传输格式</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>对数据进行标记（结构化数据）、存储 &amp; 传输</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>灵活性: 可自定义标签，文档结构</li><li>自我描叙性<ul><li>XML文档即 一个纯文本文件，代码结构清晰，适合人类阅读</li><li>有文本处理能力的软件都可以处理XML</li></ul></li><li>可扩展性: 可在不中断解析，应用程序的情况下进行扩展</li><li>可跨平台数据传输: 可以不兼容的系统间交换数据，降低了复杂性</li><li>数据共享: XML 以纯文本进行存储，独立于软硬件和应用程序的数据存储方式，使得不同的系统都能访问XML</li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>元素要关闭标签</li><li>对大小写敏感</li><li>必须要有根元素(父元素）</li><li>属性值必须加引号</li><li>XML元素命名规则<ul><li>不能以数字或标点符号开头</li><li>不能包含空格</li><li>不能以xml开头    </li></ul></li><li>CDATA<br>不被解析器解析的文本数据，所有xml文档都会被解析器解析（cdata区段除外）<br>&lt;![CDATA[“传输的文本 “]]&gt;     </li><li>PCDATA<br>被解析的字符数据</li></ul><h2 id="XML树形结构"><a href="#XML树形结构" class="headerlink" title="XML树形结构"></a>XML树形结构</h2><p>XML文档中的元素会形成一种树结构，从根部开始，然后拓展到每个树叶（节点）,下面将以实例说明XML的树结构。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">classes</span>&gt;</span><span class="comment">&lt;!--根节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Av<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sax</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sax</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Courses</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">course</span> <span class="attr">name</span>=<span class="string">"语文"</span> <span class="attr">score</span>=<span class="string">"90"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">course</span> <span class="attr">name</span>=<span class="string">"数学"</span> <span class="attr">score</span>=<span class="string">"78"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Courses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Lance<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>22<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sax</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sax</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Courses</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">course</span> <span class="attr">name</span>=<span class="string">"语文"</span> <span class="attr">score</span>=<span class="string">"59"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">course</span> <span class="attr">name</span>=<span class="string">"数学"</span> <span class="attr">score</span>=<span class="string">"38"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Courses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br></pre></td></tr></table></figure><p>树形结构</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之xml解析/1240-20200309133514278.png" alt="xml.png"></p><p>XML节点解释</p><p>XML文件是由节点构成的。它的第一个节点为“根节点”。一个XML文件必须有且只能有一个根节点，其他节点都必须是它的子节点,每个子节点又可以有自己的子节点。</p><a id="more"></a><h2 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h2><p>解析XML，即从XML中提取有用的信息<br>XML的解析方式主要分为2大类：</p><table><thead><tr><th>解析方式</th><th style="text-align:center">原理</th><th>类型</th></tr></thead><tbody><tr><td>基于文档驱动</td><td style="text-align:center">在解析XML文档前，需先将整个XML文档加载到内存中</td><td>DOM方式</td></tr><tr><td>基于事件驱动</td><td style="text-align:center">根据不同需求事件(检索，修改，删除等)去执行不同解析操作(不需要把整个XML 文档加载到内存中)</td><td>SAX方式，PULL方式</td></tr></tbody></table><h3 id="DOM方式"><a href="#DOM方式" class="headerlink" title="DOM方式"></a>DOM方式</h3><p>Document Object Model，即 文件对象模型，是 一种 基于树形结构节点 &amp; 文档驱动 的XML解析方法，它定义了访问 &amp; 操作xml文档元素的方法和接口</p><h3 id="DOM解析原理"><a href="#DOM解析原理" class="headerlink" title="DOM解析原理"></a>DOM解析原理</h3><ul><li>核心思想<br>基于文档驱动，在解析XML文档前，先将整个XML文档存储到内存中，然后再解析</li><li>解析过程<ol><li>解析器读入整个XML文档到内存中</li><li>解析全部文件，并将文件分为独立的元素，属性等，以树结构的形式在内存中表示XML文件</li><li>然后通过DOM API去遍历XML树，根据需要搜索数据/修改文档</li></ol></li><li>具体解析步骤<ol><li>获取DOM解析器工厂实例(DocumentBuilderFactory.newInstance())     </li><li>获取DOM解析器对象,调用解析器工厂实例类的newDocumentBuilder()</li><li>最后获取代表整个文档的Document对象</li></ol></li></ul><h3 id="具体解析实例"><a href="#具体解析实例" class="headerlink" title="具体解析实例"></a>具体解析实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">domTest</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            Document document = db.parse(context.getResources().openRawResource(R.raw.students));</span><br><span class="line">            <span class="comment">//通过Document对象的getElementsByTagName()返根节点的一个list集合</span></span><br><span class="line">            NodeList studentList = document.getElementsByTagName(<span class="string">"student"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentList.getLength(); i++) &#123;</span><br><span class="line">                Student student = <span class="keyword">new</span> Student();</span><br><span class="line">                <span class="comment">//循环遍历获取每一个student</span></span><br><span class="line">                Node studentNode = studentList.item(i);</span><br><span class="line">                <span class="keyword">if</span> (((Element) studentNode).hasAttribute(<span class="string">"id"</span>)) &#123;</span><br><span class="line">                    student.setId(Integer.parseInt(((Element) studentNode).getAttribute(<span class="string">"id"</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//解析student节点的子节点</span></span><br><span class="line">                NodeList childList = studentNode.getChildNodes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; childList.getLength(); t++) &#123;</span><br><span class="line">                    <span class="comment">//区分出text类型的node以及element类型的node</span></span><br><span class="line">                    <span class="keyword">if</span> (childList.item(t).getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (childList.item(t).getNodeName().equalsIgnoreCase(<span class="string">"Courses"</span>)) &#123;</span><br><span class="line">                            NodeList courses = childList.item(t).getChildNodes();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; courses.getLength(); j++) &#123;</span><br><span class="line">                                Node courseNode = courses.item(j);</span><br><span class="line">                                <span class="keyword">if</span> (courseNode.getNodeType() != Node.ELEMENT_NODE) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                NamedNodeMap namedNodeMap = courseNode.getAttributes();</span><br><span class="line">                                Course course = <span class="keyword">new</span> Course();</span><br><span class="line">                                student.addCourse(course);</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; namedNodeMap.getLength(); k++) &#123;</span><br><span class="line">                                    Node courseAttr = namedNodeMap.item(k);</span><br><span class="line">                                    <span class="keyword">if</span> (courseAttr.getNodeName().equals(<span class="string">"name"</span>)) &#123;</span><br><span class="line">                                        course.setName(courseAttr.getNodeValue());</span><br><span class="line">                                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (courseAttr.getNodeName().equals(<span class="string">"score"</span>)) &#123;</span><br><span class="line">                                        course.setScore(Float.parseFloat(courseAttr.getNodeValue()));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Node child = childList.item(t);</span><br><span class="line">                            <span class="keyword">if</span> (child.getNodeName().equals(<span class="string">"name"</span>)) &#123;</span><br><span class="line">                                student.setName(child.getTextContent());</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNodeName().equals(<span class="string">"age"</span>)) &#123;</span><br><span class="line">                                student.setAge(Integer.parseInt(child.getTextContent()));</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNodeName().equals(<span class="string">"sax"</span>)) &#123;</span><br><span class="line">                                student.setSax(child.getTextContent());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Log.i(<span class="string">"Zero"</span>, <span class="string">"解析完毕: "</span> + student);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException | SAXException | IOException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"Zero"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="特点及应用场景"><a href="#特点及应用场景" class="headerlink" title="特点及应用场景"></a>特点及应用场景</h3><ul><li>优点<ul><li>操作整个XML文档的效率高</li><li>可随时，多次访问已解析的文档          </li></ul></li><li>缺点<ul><li>耗内存，时间<br>应用场景</li><li>适合XML文档较小，需频繁操作 解析文档，多次访问文档的情况</li><li>对于移动端，内存资源非常宝贵，使用时需权衡利弊</li></ul></li></ul><h3 id="SAX方式"><a href="#SAX方式" class="headerlink" title="SAX方式"></a>SAX方式</h3><p>即 Simple API for XML，一种 基于事件流驱动、通过接口方法解析 的XML解析方法</p><h3 id="SAX解析原理"><a href="#SAX解析原理" class="headerlink" title="SAX解析原理"></a>SAX解析原理</h3><ul><li><p>核心思想<br>基于事件流驱动，根据不同需求事件(检索，修改，删除等)去执行不同解析操作，不需要把整个XML 文档加载到内存中</p></li><li><p>解析过程</p><ol><li>按顺序扫描XML文档</li><li>当扫描到(Document)文档的开始/结束标签，(Element)节点元素的开始/结束标签时，直接调用对应的方法，将状态信息以参数的方式传递到方法中</li><li>然后根据状态信息去执行相关的自定义操作<br>具体的操作</li><li>自定义Handler处理类，继承自DefaultHandler类</li><li>重写5个核心回调方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">startDocument()</span><br><span class="line">startElement()</span><br><span class="line">characters()</span><br><span class="line">endElement()</span><br><span class="line">endDocument()</span><br></pre></td></tr></table></figure></li></ul><h3 id="具体解析实例-1"><a href="#具体解析实例-1" class="headerlink" title="具体解析实例"></a>具体解析实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saxTest</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">      SAXParser sp = spf.newSAXParser();</span><br><span class="line">      sp.parse(context.getResources().openRawResource(R.raw.students), <span class="keyword">new</span> DefaultHandler() &#123;</span><br><span class="line"></span><br><span class="line">          String currentTag = <span class="keyword">null</span>;</span><br><span class="line">          Student student = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 文档解析开始时被调用</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@throws</span> SAXException</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.startDocument();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 文档解析结束时被调用</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@throws</span> SAXException</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.endDocument();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> uri 命名空间</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> localName 不带命名空间前缀的标签名</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> qName 带命名空间的标签名</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> attributes 标签的属性集合 &lt;student id="0"&gt;&lt;/student&gt;</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@throws</span> SAXException</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.startElement(uri, localName, qName, attributes);</span><br><span class="line">              currentTag = localName;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"student"</span>.equals(currentTag)) &#123;</span><br><span class="line">                  student = <span class="keyword">new</span> Student();</span><br><span class="line">                  student.setId(Integer.parseInt(attributes.getValue(<span class="string">"id"</span>)));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"course"</span>.equals(currentTag)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      Course course = <span class="keyword">new</span> Course();</span><br><span class="line">                      course.setName(attributes.getValue(<span class="string">"name"</span>));</span><br><span class="line">                      course.setScore(Float.parseFloat(attributes.getValue(<span class="string">"score"</span>)));</span><br><span class="line">                      student.addCourse(course);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *  解析到结束标签时被调用 '/&gt;'</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> localName</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> qName</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@throws</span> SAXException</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.endElement(uri, localName, qName);</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"student"</span>.equals(localName)) &#123;</span><br><span class="line">                  Log.i(TAG, <span class="string">"endElement: student: "</span> + student);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> ch 内容</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> start 起始位置</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> length 长度</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@throws</span> SAXException</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>.characters(ch, start, length);</span><br><span class="line">              String str =  <span class="keyword">new</span> String(ch, start, length).trim();</span><br><span class="line">              <span class="keyword">if</span> (TextUtils.isEmpty(str))</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"name"</span>.equals(currentTag) &amp;&amp; student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  student.setName(str);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"age"</span>.equals(currentTag)&amp;&amp;  student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  student.setAge(Integer.parseInt(str));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (<span class="string">"sax"</span>.equals(currentTag) &amp;&amp; student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  student.setSax(str);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="特点及应用场景-1"><a href="#特点及应用场景-1" class="headerlink" title="特点及应用场景"></a>特点及应用场景</h3><ul><li>优点<ul><li>解析效率高</li><li>内存占用少     </li></ul></li><li>缺点<ul><li>解析方法复杂，API接口方法复杂，代码量大</li><li>可扩展性差，无法修改XML树内容结构<br>应用场景</li><li>适合XML文档大，解析性能要求高，不需修改 多次访问解析的情况</li></ul></li></ul><h3 id="PULL方式"><a href="#PULL方式" class="headerlink" title="PULL方式"></a>PULL方式</h3><p>一种 基于事件流驱动 的XML解析方法，是Android系统特有的解析方式</p><h3 id="PULL解析原理"><a href="#PULL解析原理" class="headerlink" title="PULL解析原理"></a>PULL解析原理</h3><p>基于事件流驱动，根据不同需求事件(检索，修改，删除等)去执行不同解析操作，不需要把整个XML 文档加载到内存中</p><ul><li>解析过程<ol><li>首先按顺序扫描XML文档</li><li>解析器提供文档的开始/结束(START_DOCUMENT,END_DOCUMENT)，元素的开始/结束(START_TAG,END_TAG)</li><li>当某个元素开始时，通过调用parser.nextText()从XML文档中提取所有字符数据</li></ol></li></ul><h3 id="具体解析实例-2"><a href="#具体解析实例-2" class="headerlink" title="具体解析实例"></a>具体解析实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullTest</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       XmlPullParser parser = XmlPullParserFactory.newInstance().newPullParser();</span><br><span class="line">       parser.setInput(context.getResources().openRawResource(R.raw.students), <span class="string">"utf-8"</span>);<span class="comment">//设置数据源编码</span></span><br><span class="line">       <span class="keyword">int</span> eventCode = parser.getEventType();<span class="comment">//获取事件类型</span></span><br><span class="line">       Student student = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (eventCode != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">           <span class="keyword">switch</span> (eventCode) &#123;</span><br><span class="line">               <span class="keyword">case</span> XmlPullParser.START_DOCUMENT:<span class="comment">//开始读取XML文档</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> XmlPullParser.START_TAG:<span class="comment">//开始读取标签</span></span><br><span class="line">                   String name = parser.getName();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"student"</span>.equals(name)) &#123;</span><br><span class="line">                       student = <span class="keyword">new</span> Student();</span><br><span class="line">                       student.setId(Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"id"</span>)));</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"name"</span>.equals(name) &amp;&amp; student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       student.setName(parser.nextText());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"age"</span>.equals(name) &amp;&amp; student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       student.setAge(Integer.parseInt(parser.nextText().trim()));</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"sax"</span>.equals(name) &amp;&amp; student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       student.setSax(parser.nextText());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"course"</span>.equals(name) &amp;&amp; student != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       Course course = <span class="keyword">new</span> Course();</span><br><span class="line">                       course.setName(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"name"</span>));</span><br><span class="line">                       course.setScore(Float.parseFloat(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"score"</span>)));</span><br><span class="line">                       student.addCourse(course);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> XmlPullParser.END_TAG:<span class="comment">//结束原始事件</span></span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"student"</span>.equals(parser.getName())) &#123;</span><br><span class="line">                       Log.i(TAG, <span class="string">"pullTest: student: "</span> + student);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           eventCode = parser.next();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="特点及应用场景-2"><a href="#特点及应用场景-2" class="headerlink" title="特点及应用场景"></a>特点及应用场景</h3><ul><li>优点<ul><li>解析效率高</li><li>内存占用少 </li><li>灵活性高 可控制事件处理结束的时机(与SAX最大的区别)</li><li>使用比SAX方式简单    </li></ul></li><li>缺点<ul><li>可扩展性差，无法修改XML树内容结构<br>应用场景</li><li>适合XML文档大，解析性能要求高，不需修改 多次访问解析的情况</li><li>Pull使用比SAX更加简单，在Android中推荐使用Pull方式</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;XML，即 extensible Markup Language ，是一种数据标记语言 &amp;amp; 传输格式&lt;/p&gt;
&lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;对数据进行标记（结构化数据）、存储 &amp;amp; 传输&lt;/p&gt;
&lt;h2 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;灵活性: 可自定义标签，文档结构&lt;/li&gt;
&lt;li&gt;自我描叙性&lt;ul&gt;
&lt;li&gt;XML文档即 一个纯文本文件，代码结构清晰，适合人类阅读&lt;/li&gt;
&lt;li&gt;有文本处理能力的软件都可以处理XML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可扩展性: 可在不中断解析，应用程序的情况下进行扩展&lt;/li&gt;
&lt;li&gt;可跨平台数据传输: 可以不兼容的系统间交换数据，降低了复杂性&lt;/li&gt;
&lt;li&gt;数据共享: XML 以纯文本进行存储，独立于软硬件和应用程序的数据存储方式，使得不同的系统都能访问XML&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;元素要关闭标签&lt;/li&gt;
&lt;li&gt;对大小写敏感&lt;/li&gt;
&lt;li&gt;必须要有根元素(父元素）&lt;/li&gt;
&lt;li&gt;属性值必须加引号&lt;/li&gt;
&lt;li&gt;XML元素命名规则&lt;ul&gt;
&lt;li&gt;不能以数字或标点符号开头&lt;/li&gt;
&lt;li&gt;不能包含空格&lt;/li&gt;
&lt;li&gt;不能以xml开头    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDATA&lt;br&gt;不被解析器解析的文本数据，所有xml文档都会被解析器解析（cdata区段除外）&lt;br&gt;&amp;lt;![CDATA[“传输的文本 “]]&amp;gt;     &lt;/li&gt;
&lt;li&gt;PCDATA&lt;br&gt;被解析的字符数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;XML树形结构&quot;&gt;&lt;a href=&quot;#XML树形结构&quot; class=&quot;headerlink&quot; title=&quot;XML树形结构&quot;&gt;&lt;/a&gt;XML树形结构&lt;/h2&gt;&lt;p&gt;XML文档中的元素会形成一种树结构，从根部开始，然后拓展到每个树叶（节点）,下面将以实例说明XML的树结构。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--根节点 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;Av&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;age&lt;/span&gt;&amp;gt;&lt;/span&gt;23&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;age&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sax&lt;/span&gt;&amp;gt;&lt;/span&gt;男&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;sax&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;Courses&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;course&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;语文&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;score&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;90&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;course&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;数学&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;score&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;78&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;Courses&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;student&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;Lance&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;age&lt;/span&gt;&amp;gt;&lt;/span&gt;22&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;age&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sax&lt;/span&gt;&amp;gt;&lt;/span&gt;男&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;sax&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;Courses&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;course&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;语文&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;score&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;59&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;course&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;数学&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;score&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;38&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;Courses&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;student&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;classes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;树形结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之xml解析/1240-20200309133514278.png&quot; alt=&quot;xml.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;XML节点解释&lt;/p&gt;
&lt;p&gt;XML文件是由节点构成的。它的第一个节点为“根节点”。一个XML文件必须有且只能有一个根节点，其他节点都必须是它的子节点,每个子节点又可以有自己的子节点。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="xml" scheme="http://darryrzhong.xyz/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>Android之序列化详解</title>
    <link href="http://darryrzhong.xyz/2019/09/15/Android%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
    <id>http://darryrzhong.xyz/2019/09/15/Android之序列化详解/</id>
    <published>2019-09-15T09:19:10.000Z</published>
    <updated>2020-03-09T05:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="定义以及相关概念"><a href="#定义以及相关概念" class="headerlink" title="定义以及相关概念"></a>定义以及相关概念</h2><ol><li>由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象</li><li>无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。</li><li>从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。</li><li>这样来说，数据序列化相当于是将我们原先的对象序列化概念做出了扩展，在对象序列化和反序列化中，我们熟知的有两种方法，其一是Java语言中提供的Serializable接口，其二是Android提供的Parcelable接口。而在这里，因为我们对这个概念做出了扩展，因此也需要考虑几种专门针对数据结构进行序列化的方法，如现在那些个开放API一般返回的数据都是JSON格式的，又或者是我们Android原生的SQLite数据库来实现数据的本地存储，从广义上来说，这些都可以算做是数据的序列化</li></ol><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>将数据结构或对象转换成二进制串的过程。</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p><h3 id="数据结构、对象与二进制串"><a href="#数据结构、对象与二进制串" class="headerlink" title="数据结构、对象与二进制串"></a>数据结构、对象与二进制串</h3><p>不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p><p>数据结构和对象：对于类似 Java 这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在 Java 语言中最接近数据结构的概念，就是 POJO（Plain Old Java Object）或者 Javabean－－那些只有 setter/getter 方法的类。而在 C 二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C 语言的字符串可以直接被传输层使用，因为其本质上就是以’0’结尾的存储在内存中的二进制串。在 Java 语言里面，二进制串的概念容易和 String 混淆。实际上 String 是 Java 的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在 Java 里面所指的是 byte[]，byte 是 Java 的 8 中原生数据类型之一（Primitive data types）。</p><h3 id="序列化-反序列化的目的"><a href="#序列化-反序列化的目的" class="headerlink" title="序列化/反序列化的目的"></a>序列化/反序列化的目的</h3><p>简单的概括</p><ul><li>序列化:  主要用于网络传输，数据持久化，一般序列化也称为编码(Encode)</li><li>反序列化:  主要用于从网络，磁盘上读取字节数组还原成原始对象，一般反序列化也称为解码(Decode)</li></ul><p>具体的讲：</p><ul><li>永久的保存对象数据(将对象数据保存在文件当中,或者是磁盘中）</li><li>通过序列化操作将对象数据在网络上进行传输(由于网络传输是以字节流的方式对数据进行传输的.因此序列化的目的是将对象数据转换成字节流的形式)</li><li>将对象数据在进程之间进行传递(Activity之间传递对象数据时,需要在当前的Activity中对对象数据进行序列化操作.在另一个Activity中需要进行反序列化操作讲数据取出)</li><li>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长（即每个对象都在JVM中）但在现实应用中，就可能要停止JVM运行，但有要保存某些指定的对象，并在将来重新读取被保存的对象。这是Java对象序列化就能够实现该功能。（可选择入数据库、或文件的形式保存）</li><li>序列化对象的时候只是针对变量进行序列化,不针对方法进行序列化.</li><li>在Intent之间,基本的数据类型直接进行相关传递即可,但是一旦数据类型比较复杂的时候,就需要进行序列化操作了.</li></ul><a id="more"></a><h2 id="序列化协议特性"><a href="#序列化协议特性" class="headerlink" title="序列化协议特性"></a>序列化协议特性</h2><h3 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h3><ul><li>技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li><li>流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。</li></ul><h3 id="强健性-鲁棒性"><a href="#强健性-鲁棒性" class="headerlink" title="强健性 / 鲁棒性"></a>强健性 / 鲁棒性</h3><ul><li>成熟度不够</li><li>语言 / 平台的不公平性</li></ul><h3 id="可调试性-可读性"><a href="#可调试性-可读性" class="headerlink" title="可调试性 / 可读性"></a>可调试性 / 可读性</h3><ul><li>支持不到位</li><li>访问限制</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能包括两个方面，时间复杂度和空间复杂度。</p><ul><li>空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以 TB 为单位，巨大的的额外空间开销意味着高昂的成本。</li><li>时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li></ul><h3 id="可扩展性-兼容性"><a href="#可扩展性-兼容性" class="headerlink" title="可扩展性 / 兼容性"></a>可扩展性 / 兼容性</h3><p>移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</p><h3 id="安全性-访问限制"><a href="#安全性-访问限制" class="headerlink" title="安全性 / 访问限制"></a>安全性 / 访问限制</h3><p>在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于 HTTP/HTTPS 的 80 和 443 端口。如果使用的序列化协议没有兼容而成熟的 HTTP 传输层框架支持，可能会导致以下三种结果之一：</p><ul><li>因为访问限制而降低服务可用性；</li><li>被迫重新实现安全协议而导致实施成本大大提高；</li><li>开放更多的防火墙端口和协议访问，而牺牲安全性</li><li><strong>注意点：Android的Parcelable也有安全漏洞 </strong></li></ul><blockquote><p>最近几个月，Android安全公告公布了一系列系统框架层的高危提权漏洞，如下表所示。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.anquanke.com/post/id/103570" target="_blank" rel="noopener">https://www.anquanke.com/post/id/103570</a></p></blockquote><h2 id="几种常见的序列化和反序列化协议"><a href="#几种常见的序列化和反序列化协议" class="headerlink" title="几种常见的序列化和反序列化协议"></a>几种常见的序列化和反序列化协议</h2><h3 id="XML-amp-SOAP"><a href="#XML-amp-SOAP" class="headerlink" title="XML&amp;SOAP"></a>XML&amp;SOAP</h3><p>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p><h3 id="JSON（Javascript-Object-Notation）"><a href="#JSON（Javascript-Object-Notation）" class="headerlink" title="JSON（Javascript Object Notation）"></a>JSON（Javascript Object Notation）</h3><p>JSON 起源于弱类型语言 Javascript， 它的产生来自于一种称之为”Associative array”的概念，其本质是就是采用”Attribute－value”的方式来描述对象。实际上在 Javascript 和 PHP 等弱类型语言中，类的描述方式就是 Associative array。JSON 的如下优点，使得它快速成为最广泛使用的序列化协议之一。</p><ul><li>这种 Associative array 格式非常符合工程师对对象的理解。</li><li>它保持了 XML 的人眼可读（Human-readable）的优点。</li><li>相对于 XML 而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML 所产生序列化之后文件的大小接近 JSON 的两倍</li><li>它具备 Javascript 的先天性支持，所以被广泛应用于 Web browser 的应用常景中，是 Ajax 的事实标准协议。</li><li>与 XML 相比，其协议比较简单，解析速度比较快。</li><li>松散的 Associative array 使得其具有良好的可扩展性和兼容性</li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protobuf 具备了优秀的序列化协议的所需的众多典型特征。</p><ul><li>标准的 IDL 和 IDL 编译器，这使得其对工程师非常友好。</li><li>序列化数据非常简洁，紧凑，与 XML 相比，其序列化之后的数据量约为 1/3 到 1/10。</li><li>解析速度非常快，比对应的 XML 快约 20-100 倍。</li><li>提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</li></ul><h2 id="Android程序员该如何选择序列化方案"><a href="#Android程序员该如何选择序列化方案" class="headerlink" title="Android程序员该如何选择序列化方案"></a>Android程序员该如何选择序列化方案</h2><h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><p>是 Java 提供的序列化接口，它是一个空接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。</p><h3 id="Serializable入门"><a href="#Serializable入门" class="headerlink" title="Serializable入门"></a>Serializable入门</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//serialVersionUID唯一标识了一个可序列化的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2100492893943893602L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sax;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Course也需要实现Serializable接口</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用transient关键字标记的成员变量不参与序列化(在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Date createTime;</span><br><span class="line">    <span class="comment">//静态成员变量属于类不属于对象，所以不会参与序列化(对象序列化保存的是对象的“状态”，也就是它的成员变量，因此序列化不会关注静态变量)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student: empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String sax, Integer age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student: "</span> + name + <span class="string">" "</span> + sax + <span class="string">" "</span> + age);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sax = sax;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        courses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        createTime = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////Course也需要实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">667279791530738499L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serializable 有以下几个特点：</p><ul><li>可序列化类中，未实现 Serializable 的属性状态无法被序列化/反序列化</li><li>也就是说，反序列化一个类的过程中，它的非可序列化的属性将会调用无参构造函数重新创建</li><li>因此这个属性的无参构造函数必须可以访问，否者运行时会报错</li><li>一个实现序列化的类，它的子类也是可序列化的</li></ul><h3 id="serialVersionUID与兼容性"><a href="#serialVersionUID与兼容性" class="headerlink" title="serialVersionUID与兼容性"></a>serialVersionUID与兼容性</h3><ul><li>serialVersionUID的作用<br>serialVersionUID 用来表明类的不同版本间的兼容性。如果你修改了此类, 要修改此值。否则以前用老版本的类序列化的类恢复时会报错: InvalidClassException</li><li>设置方式<br>在JDK中，可以利用JDK的bin目录下的serialver.exe工具产生这个serialVersionUID，对于Test.class，执行命令：serialver Test</li><li>兼容性问题<br>为了在反序列化时，确保类版本的兼容性，最好在每个要序列化的类中加入 private static final long serialVersionUID这个属性，具体数值自己定义。这样，即使某个类在与之对应的对象 已经序列化出去后做了修改，该对象依然可以被正确反序列化。否则，如果不显式定义该属性，这个属性值将由JVM根据类的相关信息计算，而修改后的类的计算 结果与修改前的类的计算结果往往不同，从而造成对象的反序列化因为类版本不兼容而失败。<br>不显式定义这个属性值的另一个坏处是，不利于程序在不同的JVM之间的移植。因为不同的编译器实现该属性值的计算策略可能不同，从而造成虽然类没有改变，但是因为JVM不同，出现因类版本不兼容而无法正确反序列化的现象出现</li></ul><p>因此 JVM 规范强烈 建议我们手动声明一个版本号，这个数字可以是随机的，只要固定不变就可以。同时最好是 private 和 final 的，尽量保证不变。</p><h3 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">667279791530738499L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput objectOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"writeExternal"</span>);</span><br><span class="line">        objectOutput.writeObject(name);</span><br><span class="line">        objectOutput.writeFloat(score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput objectInput)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"readExternal"</span>);</span><br><span class="line">        name = (String)objectInput.readObject();</span><br><span class="line">        score = objectInput.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Course1 course = <span class="keyword">new</span> Course1(<span class="string">"英语"</span>, <span class="number">12f</span>);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        oos.writeObject(course);</span><br><span class="line">        course.setScore(<span class="number">78f</span>);</span><br><span class="line">);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bs));</span><br><span class="line">        Course1 course1 = (Course1) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">"course1: "</span> + course1);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="序列化与反序列化-Serializable"><a href="#序列化与反序列化-Serializable" class="headerlink" title="序列化与反序列化 Serializable"></a>序列化与反序列化 Serializable</h3><p>Serializable 的序列化与反序列化分别通过 ObjectOutputStream 和 ObjectInputStream 进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">saveObject</span><span class="params">(Object obj, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建序列化流对象</span></span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path));</span><br><span class="line">           <span class="comment">//序列化</span></span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line">            oos.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源</span></span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked "</span>)</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ojs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建反序列化对象</span></span><br><span class="line">            ojs = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path));</span><br><span class="line">            <span class="comment">// 还原对象</span></span><br><span class="line">            <span class="keyword">return</span> (T) ojs.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ojs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放资源</span></span><br><span class="line">                    ojs.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Java的序列化步骤与数据结构分析"><a href="#Java的序列化步骤与数据结构分析" class="headerlink" title="Java的序列化步骤与数据结构分析"></a>Java的序列化步骤与数据结构分析</h3><p>序列化算法一般会按步骤做如下事情：</p><ul><li>将对象实例相关的类元数据输出。</li><li>递归地输出类的超类描述直到不再有超类。</li><li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li><li>从上至下递归输出实例的数据</li></ul><p>格式化后以二进制打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">aced 0005 7372 002e 636f 6d2e 7a65 726f</span><br><span class="line">2e73 6572 6961 6c69 7a61 626c 6564 656d</span><br><span class="line">6f2e 7365 7269 616c 697a 6162 6c65 2e53</span><br><span class="line">7475 6465 6e74 e2d9 8cd7 833d f19e 0200</span><br><span class="line">044c 0003 6167 6574 0013 4c6a 6176 612f</span><br><span class="line">6c61 6e67 2f49 6e74 6567 6572 3b4c 0007</span><br><span class="line">636f 7572 7365 7374 0010 4c6a 6176 612f</span><br><span class="line">7574 696c 2f4c 6973 743b 4c00 046e 616d</span><br><span class="line">6574 0012 4c6a 6176 612f 6c61 6e67 2f53</span><br><span class="line">7472 696e 673b 4c00 0373 6178 7100 7e00</span><br><span class="line">0378 7073 7200 116a 6176 612e 6c61 6e67</span><br><span class="line">2e49 6e74 6567 6572 12e2 a0a4 f781 8738</span><br><span class="line">0200 0149 0005 7661 6c75 6578 7200 106a</span><br><span class="line">6176 612e 6c61 6e67 2e4e 756d 6265 7286</span><br><span class="line">ac95 1d0b 94e0 8b02 0000 7870 0000 0012</span><br><span class="line">7372 0013 6a61 7661 2e75 7469 6c2e 4172</span><br><span class="line">7261 794c 6973 7478 81d2 1d99 c761 9d03</span><br><span class="line">0001 4900 0473 697a 6578 7000 0000 0277</span><br><span class="line">0400 0000 0273 7200 2d63 6f6d 2e7a 6572</span><br><span class="line">6f2e 7365 7269 616c 697a 6162 6c65 6465</span><br><span class="line">6d6f 2e73 6572 6961 6c69 7a61 626c 652e</span><br><span class="line">436f 7572 7365 0942 a76f 5bfc 8343 0200</span><br><span class="line">0246 0005 7363 6f72 654c 0004 6e61 6d65</span><br><span class="line">7100 7e00 0378 7042 b466 6674 0006 e8af</span><br><span class="line">ade6 9687 7371 007e 000a 42b2 999a 7400</span><br><span class="line">06e6 95b0 e5ad a678 7400 045a 6572 6f74</span><br><span class="line">0003 e794 b7</span><br></pre></td></tr></table></figure><ul><li>AC ED: STREAM_MAGIC. 声明使用了序列化协议.</li><li>00 05: STREAM_VERSION. 序列化协议版本.</li><li>0x73: TC_OBJECT. 声明这是一个新的对象.  </li><li>0x72: TC_CLASSDESC. 声明这里开始一个新Class。</li><li>00 2e: Class名字的长度.</li></ul><h3 id="readObject-writeObject原理分析"><a href="#readObject-writeObject原理分析" class="headerlink" title="readObject/writeObject原理分析"></a>readObject/writeObject原理分析</h3><p>以<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. ObjectOutputStream的构造函数设置enableOverride = false</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> public ObjectOutputStream(OutputStream out) throws IOException &#123;</span><br><span class="line">        verifySubclass();</span><br><span class="line">        bout = new BlockDataOutputStream(out);</span><br><span class="line">        handles = new HandleTable(10, (float) 3.00);</span><br><span class="line">        subs = new ReplaceTable(10, (float) 3.00);</span><br><span class="line">        enableOverride = false;//enableOverride = false</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>所以writeObject方法执行的是writeObject0(obj, false);</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//enableOverride=false,不走这里</span></span><br><span class="line">       <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">           writeObjectOverride(obj);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;<span class="comment">//一般情况都走这里</span></span><br><span class="line">           writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在writeObject0方法中,代码非常多，看重点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Underlying writeObject/writeUnshared implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">       ...</span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">            <span class="comment">// remaining cases</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(obj <span class="keyword">instanceof</span> String)</span> </span>&#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            <span class="comment">//看这里</span></span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有实现Serializable接口，会报NotSerializableException</span></span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在writeOrdinaryObject(obj, desc, unshared)方法中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(desc.isExternalizable()</span> &amp;&amp; !desc.<span class="title">isProxy</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//如果对象实现了Externalizable接口，那么执行writeExternalData((Externalizable) obj)方法</span></span><br><span class="line">                writeExternalData((Externalizable) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果对象实现的是Serializable接口，那么执行的是writeSerialData(obj, desc)</span></span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里我们看看writeExternalData</span></span><br></pre></td></tr></table></figure><ol start="5"><li>writeSerialData方法，主要执行方法：defaultWriteFields(obj, slotDesc)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Writes instance data for each serializable class of given object, from</span></span><br><span class="line"><span class="comment">     * superclass to subclass.</span></span><br><span class="line"><span class="comment">     * 最终写序列化的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">                <span class="comment">//如果writeObjectMethod != null（目标类中定义了私有的writeObject方法），那么将调用目标类中的writeObject方法</span></span><br><span class="line">                ...</span><br><span class="line">                    slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                 ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果如果writeObjectMethod == null， 那么将调用默认的defaultWriteFields方法来读取目标类中的属性</span></span><br><span class="line">                defaultWriteFields(obj, slotDesc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>在ObjectStreamClass中,ObjectOutputStream（ObjectInputStream）会寻找目标类中的私有的writeObject（readObject）方法，赋值给变量writeObjectMethod（readObjectMethod）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates local class descriptor representing given class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">                        cons = getExternalizableConstructor(cl);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//，在序列化（反序列化）的时候，ObjectOutputStream（ObjectInputStream）</span></span><br><span class="line">                        <span class="comment">// 会寻找目标类中的私有的writeObject（readObject）方法，</span></span><br><span class="line">                        <span class="comment">// 赋值给变量writeObjectMethod（readObjectMethod）</span></span><br><span class="line">                        cons = getSerializableConstructor(cl);</span><br><span class="line">                        writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;,</span><br><span class="line">                            Void.TYPE);</span><br><span class="line">                        readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;,</span><br><span class="line">                            Void.TYPE);</span><br><span class="line">                        readObjectNoDataMethod = getPrivateMethod(</span><br><span class="line">                            cl, <span class="string">"readObjectNoData"</span>, <span class="keyword">null</span>, Void.TYPE);</span><br><span class="line">                        hasWriteObjectData = (writeObjectMethod != <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    domains = getProtectionDomains(cons, cl);</span><br><span class="line">                    writeReplaceMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"writeReplace"</span>, <span class="keyword">null</span>, Object.class);</span><br><span class="line">                    readResolveMethod = getInheritableMethod(</span><br><span class="line">                        cl, <span class="string">"readResolve"</span>, <span class="keyword">null</span>, Object.class);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//ObjectStreamClass类中的一个判断方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWriteObjectMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">return</span> (writeObjectMethod != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serializable需要注意的坑"><a href="#Serializable需要注意的坑" class="headerlink" title="Serializable需要注意的坑"></a>Serializable需要注意的坑</h3><ul><li>多引用写入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">667279791530738499L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> score;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Course course = <span class="keyword">new</span> Course(<span class="string">"英语"</span>, <span class="number">12f</span>);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        oos.writeObject(course);</span><br><span class="line">        course.setScore(<span class="number">78f</span>);</span><br><span class="line"><span class="comment">//        oos.reset();</span></span><br><span class="line">        oos.writeUnshared(course);</span><br><span class="line"><span class="comment">//        oos.writeObject(course);</span></span><br><span class="line">        <span class="keyword">byte</span>[] bs = out.toByteArray();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bs));</span><br><span class="line">        Course course1 = (Course) ois.readObject();</span><br><span class="line">        Course course2 = (Course) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">"course1: "</span> + course1);</span><br><span class="line">        System.out.println(<span class="string">"course2: "</span> + course2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course1: Course&#123;name=&apos;英语&apos;, score=12.0&#125;</span><br><span class="line">course2: Course&#123;name=&apos;英语&apos;, score=12.0&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下， 对于一个实例的多个引用，为了节省空间，只会写入一次，后面会追加几个字节代表某个实例的引用。</p><ul><li>子类实现序列化，父类不实现序列化/ 对象引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sax;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public Person() &#123;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String sax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sax = sax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student1</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2100492893943893602L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courses;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student1</span><span class="params">(String name, String sax, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,sax);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Student1 student = <span class="keyword">new</span> Student1(<span class="string">"Zero"</span>, <span class="string">"男"</span>, <span class="number">18</span>);</span><br><span class="line">        student.addCourse(<span class="keyword">new</span> Course(<span class="string">"语文"</span>, <span class="number">90.2f</span>));</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = SerializeableUtils.serialize(student);</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="comment">//在readObject时抛出java.io.NotSerializableException异常。</span></span><br><span class="line">        <span class="comment">//需要Person添加一个无参数构造器</span></span><br><span class="line">        Student1 student1 = SerializeableUtils.deserialize(bytes);</span><br><span class="line">        System.out.println(<span class="string">"Student: "</span> + student1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在readObject时抛出java.io.NotSerializableException异常。</p><ul><li>类的演化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反序列化目标类多一个字段(height)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2100492893943893602L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sax;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courses;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sax='"</span> + sax + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">   <span class="comment">//             ", height=" + height +</span></span><br><span class="line">                <span class="string">", courses="</span> + courses +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private float height;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        String path = System.getProperty(<span class="string">"user.dir"</span>) +<span class="string">"/a.out"</span>;</span><br><span class="line"><span class="comment">//        Student student = new Student("Zero", "男", 18);</span></span><br><span class="line"><span class="comment">//        student.addCourse(new Course("语文", 90.2f));</span></span><br><span class="line"><span class="comment">//        //序列化</span></span><br><span class="line"><span class="comment">//        SerializeableUtils.saveObject(student,path);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Student student1 = SerializeableUtils.readObject(path);</span><br><span class="line">        System.out.println(<span class="string">"Student: "</span> + student1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//序列化的时候</span><br><span class="line">Student: Zero 男 18</span><br><span class="line">Course: 语文 90.2</span><br><span class="line">//反序列化的时候 添加一个float height</span><br><span class="line">Student: Student&#123;name=&apos;Zero&apos;, sax=&apos;男&apos;, age=18, height=0.0, courses=[Course&#123;name=&apos;语文&apos;, score=90.2&#125;]&#125;</span><br></pre></td></tr></table></figure><p>可以看出反序列化之后，并没有报错，只是height实赋成了默认值。类似的其它对象也会赋值为默认值。<br>还有 相反，如果写入的多一个字段，读出的少一个字段，也是不会报错的<br>其它演化，比如更改类型等，这种演化本身就有问题，没必再探讨</p><ul><li>枚举类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Num &#123;</span><br><span class="line">    TWO, ONE, THREE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(ONE + <span class="string">" ONE.ordinal "</span> + ONE.ordinal());</span><br><span class="line">        System.out.println(TWO + <span class="string">" TWO.ordinal "</span> + TWO.ordinal());</span><br><span class="line">        System.out.println(THREE + <span class="string">" THREE.ordinal "</span> + THREE.ordinal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"p.dat"</span>);</span><br><span class="line"><span class="comment">//        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));</span></span><br><span class="line"><span class="comment">//        oos.writeObject(Num.ONE);</span></span><br><span class="line"><span class="comment">//        oos.close();</span></span><br><span class="line">        Num.ONE.printValues();</span><br><span class="line">        System.out.println(<span class="string">"=========反序列化后======="</span>);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        Num s1 = (Num) ois.readObject();</span><br><span class="line">        s1.printValues();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        testSerializable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  ONE ONE.ordinal 1</span><br><span class="line">  TWO TWO.ordinal 0</span><br><span class="line">  THREE THREE.ordinal 2</span><br><span class="line"> =========反序列化后=======</span><br><span class="line">//调换(ONE,TWO)的位置: TWO, ONE, THREE; -&gt;ONE, TWO, THREE;</span><br><span class="line">  ONE ONE.ordinal 0</span><br><span class="line">  TWO TWO.ordinal 1</span><br><span class="line">  THREE THREE.ordinal 2</span><br></pre></td></tr></table></figure><p>可以看到ONE的值变成了0.<br>事实上序列化Enum对象时，并不会保存元素的值，只会保存元素的name。这样，在不依赖元素值的前提下，ENUM对象如何更改都会保持兼容性。</p><h3 id="重写readObject-writeObject"><a href="#重写readObject-writeObject" class="headerlink" title="重写readObject,writeObject"></a>重写readObject,writeObject</h3><blockquote><p>“只有当你自行设计的自定义序列化形式与默认的序列化形式基本相同时，才能接受默认的序列化&gt;  形式”.“当一个对象的物理表示方法与它的逻辑数据内容有实质性差别时，使用默认序列化形式有&gt; &gt;  N种缺陷”.其实从effective java的角度来讲，是强烈建议我们重写的，这样有助于我们更好地把控&gt; &gt;  序列化过程，防范未知风险</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course3</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">667279791530738499L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> score;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream inputStream)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"readObject"</span>);</span><br><span class="line">        inputStream.defaultReadObject();</span><br><span class="line">        name = (String)inputStream.readObject();</span><br><span class="line">        score = inputStream.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"writeObject"</span>);</span><br><span class="line">        outputStream.defaultWriteObject();</span><br><span class="line">        outputStream.writeObject(name);</span><br><span class="line">        outputStream.writeFloat(score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"readResolve"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Course3(name, <span class="number">85f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"writeReplace"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Course3(name +<span class="string">"replace"</span>,score);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Course3 course = <span class="keyword">new</span> Course3(<span class="string">"英语"</span>, <span class="number">12f</span>);</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        oos.writeObject(course);</span><br><span class="line">        <span class="keyword">byte</span>[] bs = out.toByteArray();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bs));</span><br><span class="line">        Course3 course1 = (Course3) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">"course1: "</span> + course1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Course: 英语 12.0</span><br><span class="line">writeReplace</span><br><span class="line">Course: 英语replace 12.0</span><br><span class="line">writeObject</span><br><span class="line">readObject</span><br><span class="line">readResolve</span><br><span class="line">Course: 英语replace 85.0</span><br><span class="line">course1: Course&#123;name=&apos;英语replace&apos;, score=85.0&#125;</span><br></pre></td></tr></table></figure><ul><li>writeReplace 先于writeObject</li><li>readResolve后于readObject</li></ul><h3 id="单例模式的序列化问题-反射问题"><a href="#单例模式的序列化问题-反射问题" class="headerlink" title="单例模式的序列化问题/反射问题"></a>单例模式的序列化问题/反射问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String CurPath = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Single instance = Single.getInstance();</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(copyInstance(instance).hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=================反射======================"</span>);</span><br><span class="line">        <span class="comment">//使用反射方式直接调用私有构造器</span></span><br><span class="line">        Class&lt;Single&gt; clazz = (Class&lt;Single&gt;)Class.forName(<span class="string">"com.zero.serializabledemo.serializable.Single"</span>);</span><br><span class="line">        Constructor&lt;Single&gt; con = clazz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);<span class="comment">//绕过权限管理，即在true的情况下，可以通过构造函数新建对象</span></span><br><span class="line">        Single instance1 = con.newInstance();</span><br><span class="line">        Single instance2 = con.newInstance();</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">        System.out.println(instance2.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Single <span class="title">copyInstance</span><span class="params">(Single instance)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//序列化会导致单例失效</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(CurPath+<span class="string">"/a.txt"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(CurPath+<span class="string">"/a.txt"</span>));</span><br><span class="line">        Single single2 = (Single)ois.readObject();</span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="keyword">return</span> single2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Single.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"><span class="comment">//                flag = true;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式被侵犯！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( single == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( single == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    single = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果不重写readResolve,会导致单例模式在序列化-&gt;反序列化后失败</span></span><br><span class="line"><span class="comment">//    private Object readResolve() &#123;</span></span><br><span class="line"><span class="comment">//        return single;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h2><p>介绍Parcelable不得不先提一下Serializable接口,Serializable是Java为我们提供的一个标准化的序列化接口,那什么是序列化呢? —- 简单来说就是将对象转换为可以传输的二进制流(二进制序列)的过程,这样我们就可以通过序列化,转化为可以在网络传输或者保存到本地的流(序列),从而进行传输数据 ,那反序列化就是从二进制流(序列)转化为对象的过程.</p><p>Parcelable是Android为我们提供的序列化的接口,Parcelable相对于Serializable的使用相对复杂一些,但Parcelable的效率相对Serializable也高很多,这一直是Google工程师引以为傲的,有时间的可以看一下Parcelable和Serializable的效率对比 Parcelable vs Serializable 号称快10倍的效率</p><p>Parcelable是Android SDK提供的，它是基于内存的，由于内存读写速度高于硬盘，因此Android中的跨进程对象的传递一般使用Parcelable</p><h3 id="Parcelable入门"><a href="#Parcelable入门" class="headerlink" title="Parcelable入门"></a>Parcelable入门</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> score;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述当前 Parcelable 实例的对象类型</span></span><br><span class="line"><span class="comment">     * 比如说，如果对象中有文件描述符，这个方法就会返回上面的 CONTENTS_FILE_DESCRIPTOR</span></span><br><span class="line"><span class="comment">     * 其他情况会返回一个位掩码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象转换成一个 Parcel 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest 表示要写入的 Parcel 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flags 示这个对象将如何写入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(<span class="keyword">this</span>.name);</span><br><span class="line">        dest.writeFloat(<span class="keyword">this</span>.score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Course</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = in.readString();</span><br><span class="line">        <span class="keyword">this</span>.score = in.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现类必须有一个 Creator 属性，用于反序列化，将 Parcel 对象转换为 Parcelable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Course&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Course&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化的方法，将Parcel还原成Java对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Course <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Course(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供给外部类反序列化这个数组使用。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Course[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Course[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Parcel的简介"><a href="#Parcel的简介" class="headerlink" title="Parcel的简介"></a>Parcel的简介</h3><p>在介绍之前我们需要先了解Parcel是什么?Parcel翻译过来是打包的意思,其实就是包装了我们需要传输的数据,然后在Binder中传输,也就是用于跨进程传输数据<br>简单来说，Parcel提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过Parcel可以从这块共享内存中读出字节流，并反序列化成对象,下图是这个过程的模型。</p><p><img src="//darryrzhong.xyz/2019/09/15/Android之序列化详解/1240-20200309133227097.png" alt="parcel.png"></p><p>Parcel可以包含原始数据类型（用各种对应的方法写入，比如writeInt(),writeFloat()等），可以包含Parcelable对象，它还包含了一个活动的IBinder对象的引用，这个引用导致另一端接收到一个指向这个IBinder的代理IBinder。</p><p>Parcelable通过Parcel实现了read和write的方法,从而实现序列化和反序列化,</p><h2 id="Parcelable与Serializable的性能比较"><a href="#Parcelable与Serializable的性能比较" class="headerlink" title="Parcelable与Serializable的性能比较"></a>Parcelable与Serializable的性能比较</h2><h3 id="Serializable性能分析"><a href="#Serializable性能分析" class="headerlink" title="Serializable性能分析"></a>Serializable性能分析</h3><p>Serializable是Java中的序列化接口，其使用起来简单但开销较大（因为Serializable在序列化过程中使用了反射机制，故而会产生大量的临时变量，从而导致频繁的GC），并且在读写数据过程中，它是通过IO流的形式将数据写入到硬盘或者传输到网络上。</p><h3 id="Parcelable性能分析"><a href="#Parcelable性能分析" class="headerlink" title="Parcelable性能分析"></a>Parcelable性能分析</h3><p>Parcelable则是以IBinder作为信息载体，在内存上开销比较小，因此在内存之间进行数据传递时，推荐使用Parcelable,而Parcelable对数据进行持久化或者网络传输时操作复杂，一般这个时候推荐使用Serializable。</p><h3 id="性能比较总结描述"><a href="#性能比较总结描述" class="headerlink" title="性能比较总结描述"></a>性能比较总结描述</h3><p>首先Parcelable的性能要强于Serializable的原因我需要简单的阐述一下</p><ul><li>在内存的使用中,前者在性能方面要强于后者</li><li>后者在序列化操作的时候会产生大量的临时变量,(原因是使用了反射机制)从而导致GC的频繁调用,因此在性能上会稍微逊色</li><li>Parcelable是以Ibinder作为信息载体的.在内存上的开销比较小,因此在内存之间进行数据传递的时候,Android推荐使用Parcelable,既然是内存方面比价有优势,那么自然就要优先选择.</li><li>在读写数据的时候,Parcelable是在内存中直接进行读写,而Serializable是通过使用IO流的形式将数据读写入在硬盘上.<br>但是：虽然Parcelable的性能要强于Serializable,但是仍然有特殊的情况需要使用Serializable,而不去使用Parcelable,因为Parcelable无法将数据进行持久化,因此在将数据保存在磁盘的时候,仍然需要使用后者,因为前者无法很好的将数据进行持久化.(原因是在不同的Android版本当中,Parcelable可能会不同,因此数据的持久化方面仍然是使用Serializable)</li></ul><h3 id="性能测试方法分析"><a href="#性能测试方法分析" class="headerlink" title="性能测试方法分析"></a>性能测试方法分析</h3><ul><li><ul><li>通过将一个对象放到一个bundle里面然后调用Bundle#writeToParcel(Parcel, int)方法来模拟传递对象给一个activity的过程，然后再把这个对象取出来。</li></ul></li><li>在一个循环里面运行1000 次。</li><li>两种方法分别运行10次来减少内存整理，cpu被其他应用占用等情况的干扰。</li><li>参与测试的对象就是上面的相关代码</li><li>在多种Android软硬件环境上进行测试</li></ul><h3 id="两种如何选择"><a href="#两种如何选择" class="headerlink" title="两种如何选择"></a>两种如何选择</h3><ul><li>在使用内存方面，Parcelable比Serializable性能高，所以推荐使用Parcelable。</li><li>Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。</li><li>Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性，在外界有变化的情况下，建议使用Serializable</li></ul><h2 id="SQLite-与-SharedPreferences"><a href="#SQLite-与-SharedPreferences" class="headerlink" title="SQLite 与 SharedPreferences"></a>SQLite 与 SharedPreferences</h2><ul><li>SQLite主要用于存储复杂的关系型数据，Android支持原生支持SQLite数据库相关操作（SQLiteOpenHelper）,不过由于原生API接口并不友好，所以产生了不少封装了SQLite的ORM框架。</li><li>SharedPreferences是Android平台上提供的一个轻量级存储API，一般用于存储常用的配置信息，其本质是一个键值对存储，支持常用的数据类型如boolean、float、int、long以及String的存储和读取。</li></ul><h2 id="最后附带的几个面试相关的问题"><a href="#最后附带的几个面试相关的问题" class="headerlink" title="最后附带的几个面试相关的问题"></a>最后附带的几个面试相关的问题</h2><ul><li><p>Android里面为什么要设计出Bundle而不是直接用Map结构</p><p>Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。<br>另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。</p></li><li><p>Android中Intent/Bundle的通信原理及大小限制</p><p>Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限制的（有些手机是 2 M），而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区就更小了（ 有人以前做过测试，大约一个线程可以占用 128 KB）。所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时，你应该知道怎么解决了</p></li><li><p>为何Intent不能直接在组件间传递对象而要通过序列化机制？</p><p>Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程（intent.prepareToLeaveProcess()），这也就意味着，Intent所携带的数据要能够在不同进程间传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输，所以我们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间传输。<br>而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel容器，后者也是Android系统专门推出的用于进程间通信等的接口</p><p><img src="//darryrzhong.xyz/2019/09/15/Android之序列化详解/1240-20200309133230824.jpeg" alt="start_activity_process.jpg"></p></li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">http://gityuan.com/2016/03/12/start-activity/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h1&gt;&lt;h2 id=&quot;定义以及相关概念&quot;&gt;&lt;a href=&quot;#定义以及相关概念&quot; class=&quot;headerlink&quot; title=&quot;定义以及相关概念&quot;&gt;&lt;/a&gt;定义以及相关概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象&lt;/li&gt;
&lt;li&gt;无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。&lt;/li&gt;
&lt;li&gt;从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。&lt;/li&gt;
&lt;li&gt;这样来说，数据序列化相当于是将我们原先的对象序列化概念做出了扩展，在对象序列化和反序列化中，我们熟知的有两种方法，其一是Java语言中提供的Serializable接口，其二是Android提供的Parcelable接口。而在这里，因为我们对这个概念做出了扩展，因此也需要考虑几种专门针对数据结构进行序列化的方法，如现在那些个开放API一般返回的数据都是JSON格式的，又或者是我们Android原生的SQLite数据库来实现数据的本地存储，从广义上来说，这些都可以算做是数据的序列化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;序列化-1&quot;&gt;&lt;a href=&quot;#序列化-1&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h3&gt;&lt;p&gt;将数据结构或对象转换成二进制串的过程。&lt;/p&gt;
&lt;h3 id=&quot;反序列化&quot;&gt;&lt;a href=&quot;#反序列化&quot; class=&quot;headerlink&quot; title=&quot;反序列化&quot;&gt;&lt;/a&gt;反序列化&lt;/h3&gt;&lt;p&gt;将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程&lt;/p&gt;
&lt;h3 id=&quot;数据结构、对象与二进制串&quot;&gt;&lt;a href=&quot;#数据结构、对象与二进制串&quot; class=&quot;headerlink&quot; title=&quot;数据结构、对象与二进制串&quot;&gt;&lt;/a&gt;数据结构、对象与二进制串&lt;/h3&gt;&lt;p&gt;不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。&lt;/p&gt;
&lt;p&gt;数据结构和对象：对于类似 Java 这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在 Java 语言中最接近数据结构的概念，就是 POJO（Plain Old Java Object）或者 Javabean－－那些只有 setter/getter 方法的类。而在 C 二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C 语言的字符串可以直接被传输层使用，因为其本质上就是以’0’结尾的存储在内存中的二进制串。在 Java 语言里面，二进制串的概念容易和 String 混淆。实际上 String 是 Java 的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在 Java 里面所指的是 byte[]，byte 是 Java 的 8 中原生数据类型之一（Primitive data types）。&lt;/p&gt;
&lt;h3 id=&quot;序列化-反序列化的目的&quot;&gt;&lt;a href=&quot;#序列化-反序列化的目的&quot; class=&quot;headerlink&quot; title=&quot;序列化/反序列化的目的&quot;&gt;&lt;/a&gt;序列化/反序列化的目的&lt;/h3&gt;&lt;p&gt;简单的概括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列化:  主要用于网络传输，数据持久化，一般序列化也称为编码(Encode)&lt;/li&gt;
&lt;li&gt;反序列化:  主要用于从网络，磁盘上读取字节数组还原成原始对象，一般反序列化也称为解码(Decode)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的讲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永久的保存对象数据(将对象数据保存在文件当中,或者是磁盘中）&lt;/li&gt;
&lt;li&gt;通过序列化操作将对象数据在网络上进行传输(由于网络传输是以字节流的方式对数据进行传输的.因此序列化的目的是将对象数据转换成字节流的形式)&lt;/li&gt;
&lt;li&gt;将对象数据在进程之间进行传递(Activity之间传递对象数据时,需要在当前的Activity中对对象数据进行序列化操作.在另一个Activity中需要进行反序列化操作讲数据取出)&lt;/li&gt;
&lt;li&gt;Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长（即每个对象都在JVM中）但在现实应用中，就可能要停止JVM运行，但有要保存某些指定的对象，并在将来重新读取被保存的对象。这是Java对象序列化就能够实现该功能。（可选择入数据库、或文件的形式保存）&lt;/li&gt;
&lt;li&gt;序列化对象的时候只是针对变量进行序列化,不针对方法进行序列化.&lt;/li&gt;
&lt;li&gt;在Intent之间,基本的数据类型直接进行相关传递即可,但是一旦数据类型比较复杂的时候,就需要进行序列化操作了.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="序列化" scheme="http://darryrzhong.xyz/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java系列之设计模式(单例模式)</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之设计模式-单例模式/</id>
    <published>2019-09-15T09:17:15.000Z</published>
    <updated>2019-09-15T09:18:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.饿汉<br>如果应用程序总是创建并使用单例实例或在创建和运行时开销不大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single= <span class="keyword">new</span> Single();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.懒汉<br>如果开销比较大，希望用到时才创建就要考虑延迟实例化<br>Singleton的初始化需要某些外部资源(比如网络或存储设备)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single= <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( single == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Single.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( single == <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    single = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHandler</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Single single = <span class="keyword">new</span> Single();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Single.SingleHandler.single;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>4.枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> SingleEnum &#123;</span><br><span class="line">        singleHandler;</span><br><span class="line">        <span class="keyword">private</span> Single single;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingleEnum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            single = <span class="keyword">new</span> Single();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Single <span class="title">getSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstacne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleEnum.singleHandler.getSingle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.饿汉&lt;br&gt;如果应用程序总是创建并使用单例实例或在创建和运行时开销不大&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single single= &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Single();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; single;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.懒汉&lt;br&gt;如果开销比较大，希望用到时才创建就要考虑延迟实例化&lt;br&gt;Singleton的初始化需要某些外部资源(比如网络或存储设备)&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single single= &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( single == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (Single.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( single == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    single = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Single();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; single;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.静态内部类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingleHandler&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single single = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Single();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Single.SingleHandler.single;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://darryrzhong.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://darryrzhong.xyz/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android之Dagger2详解</title>
    <link href="http://darryrzhong.xyz/2019/09/15/Android%E4%B9%8BDagger2%E8%AF%A6%E8%A7%A3/"/>
    <id>http://darryrzhong.xyz/2019/09/15/Android之Dagger2详解/</id>
    <published>2019-09-15T09:12:39.000Z</published>
    <updated>2020-03-09T05:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h1><p>Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p><p>起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p><h3 id="Dagger2注解"><a href="#Dagger2注解" class="headerlink" title="Dagger2注解"></a>Dagger2注解</h3><p>Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p><ul><li>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</li><li>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</li><li>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</li><li>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</li><li>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。—-一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</li><li>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</li><li>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</li></ul><p>我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p><ul><li>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</li><li>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。</li><li><ul><li>a：若存在参数，则按从步骤1开始依次初始化每个参数；</li><li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li></ul></li></ul><ul><li>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。</li><li><ul><li>a：若存在参数，则从步骤1开始依次初始化每一个参数</li><li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li></ul></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d34344c7088691?w=711&amp;h=575&amp;f=webp&amp;s=9466" alt></p><a id="more"></a><h3 id="Dagger2使用入门"><a href="#Dagger2使用入门" class="headerlink" title="Dagger2使用入门"></a>Dagger2使用入门</h3><p><strong>1、案例A</strong></p><p>Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。<br>Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二是用来标记构造函数，Dagger2通过<span class="doctag">@Inject</span>注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，</span></span><br><span class="line"><span class="comment">     * 以此来为被<span class="doctag">@Inject</span>标记了的变量提供依赖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Engine&#123;&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Inject</span>：<span class="doctag">@Inject</span>有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        System.out.println(car.getEngine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、案例B</strong></p><p>如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</p><p>同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Engine(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Engine&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了<span class="doctag">@Inject</span>的变量赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上modules = {MarkCarModule.class}，用来告诉Dagger2提供依赖的是MarkCarModule这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = MarkCarModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Car类的构造函数我们也需要修改，相比之前多了个markCarModule(new MarkCarModule())方法，这就相当于告诉了注入器DaggerCarComponent把MarkCarModule提供的依赖注入到了Car类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们提到<span class="doctag">@Inject</span>和<span class="doctag">@Module</span>都可以提供依赖，那如果我们即在构造函数上通过标记<span class="doctag">@Inject</span>提供依赖，有通过<span class="doctag">@Module</span>提供依赖Dagger2会如何选择呢？具体规则如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 步骤1：首先查找<span class="doctag">@Module</span>标注的类中是否存在提供依赖的方法。</span></span><br><span class="line"><span class="comment">     * 步骤2：若存在提供依赖的方法，查看该方法是否存在参数。</span></span><br><span class="line"><span class="comment">     * a：若存在参数，则按从步骤1开始依次初始化每个参数；</span></span><br><span class="line"><span class="comment">     * b：若不存在，则直接初始化该类实例，完成一次依赖注入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 步骤3：若不存在提供依赖的方法，则查找<span class="doctag">@Inject</span>标注的构造函数，看构造函数是否存在参数。</span></span><br><span class="line"><span class="comment">     * a：若存在参数，则从步骤1开始依次初始化每一个参数</span></span><br><span class="line"><span class="comment">     * b：若不存在，则直接初始化该类实例，完成一次依赖注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</span><br><span class="line">                .build().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        System.out.println(car.getEngine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。<br>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Engine&#123;name=&apos;gear&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>3、案例C</strong></p><p>那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于自定义注解，也就是说<span class="doctag">@Qulifier</span>就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用<span class="doctag">@Module</span>来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被<span class="doctag">@Inject</span>标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。<span class="doctag">@Qulifier</span>的存在正式为了解决这个问题，我们使用<span class="doctag">@Qulifier</span>来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被<span class="doctag">@Inject</span>标注的变量），这样Dagger2就知道为谁提供依赖了。----一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示</span></span><br><span class="line"><span class="comment">     * 1. 使用<span class="doctag">@Qulifier</span>定义两个注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> QualifierA &#123; &#125;</span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> QualifierB &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Engine(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Engine&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们需要对依赖提供方做出修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 同时我们需要对依赖提供方做出修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Engine</span>.QualifierA</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Engine <span class="title">provideEngineA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Engine</span>.QualifierB</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Engine <span class="title">provideEngineB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来依赖需求方Car类同样需要修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 接下来依赖需求方Car类同样需要修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Engine</span>.QualifierA</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine engineA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Engine</span>.QualifierB</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine engineB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</span><br><span class="line">                .build().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        System.out.println(car.getEngineA());</span><br><span class="line">        System.out.println(car.getEngineB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Engine&#123;name=&apos;gearA&apos;&#125;</span><br><span class="line">Engine&#123;name=&apos;gearB&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>4、案例D</strong><br>接下来我们看看@Scope是如何限定作用域，实现局部单例的。<br>首先我们需要通过@Scope定义一个CarScope注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于自定义注解，我能可以通过<span class="doctag">@Scope</span>自定义的注解来限定注解作用域，实现局部的单例</span></span><br><span class="line"><span class="comment">     * 1. <span class="doctag">@Scope</span>定义一个CarScope注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scope</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> CarScope &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Engine(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">"Engine create: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Engine&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. <span class="doctag">@CarScope</span>去标记依赖提供方MarkCarModule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Engine</span>.CarScope</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还需要使用@Scope去标注注入器Compoent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 同时还需要使用<span class="doctag">@Scope</span>去标注注入器Compoent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Engine</span>.CarScope</span><br><span class="line"><span class="meta">@Component</span>(modules = MarkCarModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine engineA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Engine engineB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</span><br><span class="line">                .build().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        System.out.println(car.getEngineA());</span><br><span class="line">        System.out.println(car.getEngineB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次”Create Engine”输出。现在我们在有@Scope的情况测试下劳动成果：<br>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Engine create: gear</span><br><span class="line">Engine&#123;name=&apos;gear&apos;&#125;</span><br><span class="line">Engine&#123;name=&apos;gear&apos;&#125;</span><br></pre></td></tr></table></figure><h1 id="Dagger与MVP"><a href="#Dagger与MVP" class="headerlink" title="Dagger与MVP"></a>Dagger与MVP</h1><p>　对于一个应用而言我们需要对它抽象出各个层面，而在MVP架构中它将UI界面和数据进行隔离，所以我们的应用也就分为三个层次。</p><ul><li>View: 对于View层也是视图层，在View层中只负责对数据的展示，提供友好的界面与用户进行交互。在Android开发中通常将Activity或者Fragment作为View层。</li><li>Model: 对于Model层也是数据层。它区别于MVC架构中的Model，在这里不仅仅只是数据模型。在MVP架构中Model它负责对数据的存取操作，例如对数据库的读写，网络的数据的请求等。</li><li>Presenter:对于Presenter层他是连接View层与Model层的桥梁并对业务逻辑进行处理。在MVP架构中Model与View无法直接进行交互。所以在Presenter层它会从Model层获得所需要的数据，进行一些适当的处理后交由View层进行显示。这样通过Presenter将View与Model进行隔离，使得View和Model之间不存在耦合，同时也将业务逻辑从View中抽离。</li></ul><p>　　下面通过MVP结构图来看一下MVP中各个层次之间的关系。 </p><p><img src="//darryrzhong.xyz/2019/09/15/Android之Dagger2详解/1240-20200309132747788.jpeg" alt="mvp.png"></p><p>在MVP架构中将这三层分别抽象到各自的接口当中。通过接口将层次之间进行隔离，而Presenter对View和Model的相互依赖也是依赖于各自的接口。这点符合了接口隔离原则，也正是面向接口编程。在Presenter层中包含了一个View接口，并且依赖于Model接口，从而将Model层与View层联系在一起。而对于View层会持有一个Presenter成员变量并且只保留对Presenter接口的调用，具体业务逻辑全部交由Presenter接口实现类中处理。</p><p>如果你的项目是采用MVP架构的，那么结合Dagger2将会是一件非常棒的体验，它让M-V-P进一步解藕，架构更清晰。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dagger2&quot;&gt;&lt;a href=&quot;#Dagger2&quot; class=&quot;headerlink&quot; title=&quot;Dagger2&quot;&gt;&lt;/a&gt;Dagger2&lt;/h1&gt;&lt;p&gt;Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。&lt;/p&gt;
&lt;p&gt;起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。&lt;/p&gt;
&lt;h3 id=&quot;Dagger2注解&quot;&gt;&lt;a href=&quot;#Dagger2注解&quot; class=&quot;headerlink&quot; title=&quot;Dagger2注解&quot;&gt;&lt;/a&gt;Dagger2注解&lt;/h3&gt;&lt;p&gt;Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；&lt;/li&gt;
&lt;li&gt;@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。&lt;/li&gt;
&lt;li&gt;@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；&lt;/li&gt;
&lt;li&gt;@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；&lt;/li&gt;
&lt;li&gt;@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。—-一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；&lt;/li&gt;
&lt;li&gt;@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；&lt;/li&gt;
&lt;li&gt;@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。&lt;/li&gt;
&lt;li&gt;步骤2：若存在提供依赖的方法，查看该方法是否存在参数。&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;a：若存在参数，则按从步骤1开始依次初始化每个参数；&lt;/li&gt;
&lt;li&gt;b：若不存在，则直接初始化该类实例，完成一次依赖注入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;a：若存在参数，则从步骤1开始依次初始化每一个参数&lt;/li&gt;
&lt;li&gt;b：若不存在，则直接初始化该类实例，完成一次依赖注入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d34344c7088691?w=711&amp;amp;h=575&amp;amp;f=webp&amp;amp;s=9466&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="dagger2" scheme="http://darryrzhong.xyz/tags/dagger2/"/>
    
  </entry>
  
  <entry>
    <title>java系列之注解详解</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之注解详解/</id>
    <published>2019-09-15T09:08:47.000Z</published>
    <updated>2020-03-09T05:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。</p><h2 id="注解即标签"><a href="#注解即标签" class="headerlink" title="注解即标签"></a>注解即标签</h2><p>如果把代码想象成一个具有生命的个体，注解就是给这些代码的某些个体打标签</p><h2 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h2><ul><li>注解通过 @interface关键字进行定义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 Test 的注解。<br>你可以简单理解为创建了一张名字为 Test的标签。</p><ul><li>使用注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个类 TestAnnotation,然后在类定义的地方加上 @Test就可以用 Test注解这个类了</p><p>你可以简单理解为将 Test 这张标签贴到 TestAnnotation这个类上面。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。</p><p>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</p><ul><li><p>@Retention</p><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。</p><p>它的取值如下：</p><ol><li><p>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</p></li><li><p>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</p></li><li><p>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们</p><p>java  - source被丢弃 -&gt; class - class被丢弃 &gt; jvm （runtime）</p></li></ol></li></ul><ul><li><p>@Target</p><p>Target 是目标的意思，@Target 指定了注解运用的地方<br>你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。<br>类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值</p><ol><li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li><li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li><li>ElementType.FIELD 可以给属性进行注解</li><li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li><li>ElementType.METHOD 可以给方法进行注解</li><li>ElementType.PACKAGE 可以给一个包进行注解</li><li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li></ol></li><li><p>@Documented</p><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</p></li><li><p>@Inherited</p><p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p></li><li><p>@Repeatable</p><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p></li></ul><a id="more"></a><h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。<br>需要注意的是，在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组<br>注解中属性可以有默认值，默认值需要用 default 关键值指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"><span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。<br>赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(id=<span class="number">1</span>,msg=<span class="string">"hello annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h2><p>注解与反射。<br>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>或者是 getAnnotations() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> hasAnnotation =  TestDemo.class.isAnnotationPresent(Test.class);</span><br><span class="line"><span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">TestAnnotation testAnnotation = TestDemo.class.getAnnotation(Test.class);</span><br><span class="line">System.out.println(<span class="string">"id:"</span>+testAnnotation.id());</span><br><span class="line">System.out.println(<span class="string">"msg:"</span>+testAnnotation.msg());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解的使用场景"><a href="#注解的使用场景" class="headerlink" title="注解的使用场景"></a>注解的使用场景</h2><ul><li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li><li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。</li><li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取<br>值得注意的是，注解不是代码本身的一部分。</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性<br>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。<br>Java 反射主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法<br>重点：<strong>是运行时而不是编译时</strong></li></ul><h2 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h2><h3 id="获得-Class-对象"><a href="#获得-Class-对象" class="headerlink" title="获得 Class 对象"></a>获得 Class 对象</h3><ul><li>使用 Class 类的 <code>forName</code> 静态方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure><ul><li>直接获取某一个对象的 class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure><ul><li>调用某个对象的 <code>getClass()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>一般地，我们用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><ul><li>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure><ul><li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h3 id="获取构造器信息"><a href="#获取构造器信息" class="headerlink" title="获取构造器信息"></a>获取构造器信息</h3><p>得到构造器的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特殊的参数类型的公共构造函数， </span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getConstructors</span><span class="params">()</span> -- 获得类的所有公共构造函数 </span></span><br><span class="line"><span class="function">Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class[] params)</span> -- 获得使用特定参数类型的构造函数<span class="params">(与接入级别无关)</span> </span></span><br><span class="line"><span class="function">Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> -- 获得类的所有构造函数<span class="params">(与接入级别无关)</span></span></span><br></pre></td></tr></table></figure><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br></pre></td></tr></table></figure><h3 id="获取类的成员变量（字段）信息"><a href="#获取类的成员变量（字段）信息" class="headerlink" title="获取类的成员变量（字段）信息"></a>获取类的成员变量（字段）信息</h3><p>获得字段信息的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> -- 获得命名的公共字段 </span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span> -- 获得类的所有公共字段 </span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> -- 获得类声明的命名的字段 </span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> -- 获得类声明的所有字段</span></span><br></pre></td></tr></table></figure><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>获得方法信息的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特定的参数类型，获得命名的公共方法 </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> -- 获得类的所有公共方法 </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特写的参数类型，获得类声明的命名的方法 </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> -- 获得类声明的所有方法</span></span><br></pre></td></tr></table></figure><p>当我们从类中获取了一个方法后，我们就可以用 <code>invoke()</code> 方法来调用这个方法。<code>invoke</code> 方法的原型为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span></span><br></pre></td></tr></table></figure><h3 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference<br>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而 <code>newArray</code> 方法是一个 native 方法，它在 HotSpot JVM 里的具体实现我们后边再研究，这里先把源码贴出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newArray</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NegativeArraySizeException</span>;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射</li><li>反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题</li></ul><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h3 id="什么是依赖（Dependency）？"><a href="#什么是依赖（Dependency）？" class="headerlink" title="什么是依赖（Dependency）？"></a>什么是依赖（Dependency）？</h3><p>依赖是类与类之间的连接，依赖关系表示一个类依赖于另一个类的定义，通俗来讲</p><p>就是一种需要，例如一个人(Person)可以买车(Car)和房子(House),Person类依赖于Car类和House类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line"></span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    person.buy(<span class="keyword">new</span> House());</span><br><span class="line">    person.buy(<span class="keyword">new</span> Car());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示依赖House</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(House house)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//表示依赖Car</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(Car car)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖倒置-Dependency-inversion-principle"><a href="#依赖倒置-Dependency-inversion-principle" class="headerlink" title="依赖倒置 (Dependency inversion principle)"></a>依赖倒置 (Dependency inversion principle)</h3><p>依赖倒置是面向对象设计领域的一种软件设计原则</p><p>软件设计有 6 大设计原则，合称 <strong>SOLID</strong></p><p><strong>1、单一职责原则（Single Responsibility Principle，简称SRP ）</strong></p><ul><li><strong>核心思想:</strong> 应该有且仅有一个原因引起类的变更</li><li><strong>问题描述：</strong> 假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。</li><li><strong>好处：</strong> 类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。</li><li><strong>需注意：</strong> 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。</li></ul><p><strong>2、里氏替换原则（Liskov Substitution Principle,简称LSP）</strong></p><ul><li><strong>核心思想：</strong> 在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。</li><li><strong>通俗来讲：</strong> 只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。</li><li><strong>好处：</strong> 增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。</li><li><strong>需注意：</strong> 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。</li></ul><p><strong>3、依赖倒置原则（Dependence Inversion Principle,简称DIP）</strong></p><ul><li><strong>核心思想</strong>：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；</li><li><strong>说明</strong>：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。</li><li><strong>通俗来讲：</strong> 依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。</li><li><strong>问题描述：</strong> 类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</li><li><strong>解决方案：</strong> 将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。</li><li><strong>好处</strong>：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。</li></ul><p><strong>4、接口隔离原则（Interface Segregation Principle,简称ISP）</strong></p><ul><li><strong>核心思想</strong>：类间的依赖关系应该建立在最小的接口上</li><li><strong>通俗来讲：</strong> 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</li><li><strong>问题描述：</strong> 类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</li><li><strong>需注意：</strong></li><li><strong>接口尽量小，但是要有限度</strong>。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度</li><li><strong>提高内聚，减少对外交互</strong>。使接口用最少的方法去完成最多的事情</li><li><strong>为依赖接口的类定制服务</strong>。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li></ul><p><strong>5、迪米特法则（Law of Demeter,简称LoD）</strong></p><ul><li><strong>核心思想：</strong> 类间解耦。</li><li><strong>通俗来讲：</strong> 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</li></ul><p><strong>6、开放封闭原则（Open Close Principle,简称OCP）</strong></p><ul><li><strong>核心思想：</strong> 尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li><li><strong>通俗来讲：</strong> 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li></ul><p>依赖倒置原则的定义如下：</p><blockquote><ol><li>上层模块不应该依赖底层模块，它们都应该依赖于抽象。</li><li>抽象不应该依赖于细节，细节应该依赖于抽象。</li></ol></blockquote><h3 id="什么是上层模块和底层模块？"><a href="#什么是上层模块和底层模块？" class="headerlink" title="什么是上层模块和底层模块？"></a>什么是上层模块和底层模块？</h3><p>不管你承认不承认，“有人的地方就有江湖”，我们都说人人平等，但是对于任何一个组织机构而言，它一定有架构的设计有职能的划分。按照职能的重要性，自然而然就有了上下之分。并且，随着模块的粒度划分不同这种上层与底层模块会进行变动，也许某一模块相对于另外一模块它是底层，但是相对于其他模块它又可能是上层</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之注解详解/1240-20200309131827858.png" alt="组织架构.png"></p><p>公司管理层就是上层，CEO 是整个事业群的上层，那么 CEO 职能之下就是底层。</p><p>然后，我们再以事业群为整个体系划分模块，各个部门经理以上部分是上层，那么之下的组织都可以称为底层。</p><p>由此，我们可以看到，在一个特定体系中，上层模块与底层模块可以按照决策能力高低为准绳进行划分。</p><p>那么，映射到我们软件实际开发中，一般我们也会将软件进行模块划分，比如业务层、逻辑层和数据层。 </p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之注解详解/1240-20200309131833217.png" alt="业务模块.png"></p><p>业务层中是软件真正要进行的操作，也就是<strong>做什么</strong>。<br>逻辑层是软件现阶段为了业务层的需求提供的实现细节，也就是<strong>怎么做</strong>。<br>数据层指业务层和逻辑层所需要的数据模型。</p><p>因此，如前面所总结，按照决策能力的高低进行模块划分。业务层自然就处于上层模块，逻辑层和数据层自然就归类为底层。 </p><h3 id="什么是抽象和细节？"><a href="#什么是抽象和细节？" class="headerlink" title="什么是抽象和细节？"></a>什么是抽象和细节？</h3><p>象如其名字一样，是一件很抽象的事物。抽象往往是相对于具体而言的，具体也可以被称为细节，当然也被称为具象。</p><p>比如： </p><ol><li>这是一幅画。画是抽象，而油画、素描、国画而言就是具体。 </li><li>这是一件艺术品，艺术品是抽象，而画、照片、瓷器等等就是具体了。 </li><li>交通工具是抽象，而公交车、单车、火车等就是具体了。 </li><li>表演是抽象，而唱歌、跳舞、小品等就是具体。</li></ol><p>上面可以知道，抽象可以是物也可以是行为。</p><p>具体映射到软件开发中，抽象可以是接口或者抽象类形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Driveable 是接口，所以它是抽象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Driveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 而 Bike 实现了接口，它们被称为具体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">Driveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bike drive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 而 Car实现了接口，它们被称为具体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Driveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Car drive."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖倒置的好处"><a href="#依赖倒置的好处" class="headerlink" title="依赖倒置的好处"></a>依赖倒置的好处</h3><p>在平常的开发中，我们大概都会这样编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bike mBike;</span><br><span class="line">    <span class="keyword">private</span> Car mCar;</span><br><span class="line">    <span class="keyword">private</span> Train mTrain;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mBike = <span class="keyword">new</span> Bike();</span><br><span class="line">        <span class="comment">//mCar = new Car();</span></span><br><span class="line"><span class="comment">//        mTrain = new Train();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出门啦"</span>);</span><br><span class="line">        mBike.drive();</span><br><span class="line">        <span class="comment">//mCar.drive();</span></span><br><span class="line"><span class="comment">//        mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建了一个 Person 类，它拥有一台自行车，出门的时候就骑自行车。</p><p>不过，自行车适应很短的距离。如果，我要出门逛街呢？自行车就不大合适了。于是就要改成汽车。</p><p>不过，如果我要到北京去，那么汽车也不合适了。</p><p>有没有一种方法能让 Person 的变动少一点呢？因为这是最基础的演示代码，如果工程大了，代码复杂了，Person 面对需求变动时改动的地方会更多。</p><p>而依赖倒置原则正好适用于解决这类情况。</p><p>下面，我们尝试运用依赖倒置原则对代码进行改造。</p><p>我们再次回顾下它的定义。</p><p>上层模块不应该依赖底层模块，它们都应该依赖于抽象。<br>抽象不应该依赖于细节，细节应该依赖于抽象。<br>首先是上层模块和底层模块的拆分。</p><p>按照决策能力高低或者重要性划分，Person 属于上层模块，Bike、Car 和 Train 属于底层模块。</p><p>上层模块不应该依赖于底层模块。<br><img src="//darryrzhong.xyz/2019/09/15/java系列之注解详解/1240-20200309131839551.png" alt="person架构.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private Bike mBike;</span></span><br><span class="line">    <span class="keyword">private</span> Car mCar;</span><br><span class="line">    <span class="keyword">private</span> Train mTrain;</span><br><span class="line">    <span class="keyword">private</span> Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        mBike = new Bike();</span></span><br><span class="line">        <span class="comment">//mCar = new Car();</span></span><br><span class="line">       mDriveable = <span class="keyword">new</span> Train();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出门啦"</span>);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        <span class="comment">//mCar.drive();</span></span><br><span class="line"><span class="comment">//        mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，依赖倒置实质上是<strong>面向接口编程的体现</strong>。</p><h3 id="控制反转-（IoC）"><a href="#控制反转-（IoC）" class="headerlink" title="控制反转 （IoC）"></a>控制反转 （IoC）</h3><p>控制反转 IoC 是 Inversion of Control的缩写，意思就是对于控制权的反转，对么控制权是什么控制权呢？ </p><p>Person自己掌控着内部 mDriveable 的实例化。<br>现在，我们可以更改一种方式。将 mDriveable 的实例化移到 Person 外面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">(Driveable driveable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDriveable = driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出门啦"</span>);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        <span class="comment">//mCar.drive();</span></span><br><span class="line"><span class="comment">//        mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Person2 person = <span class="keyword">new</span> Person2(<span class="keyword">new</span> Car());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样无论出行方式怎么变化，Person 这个类都不需要更改代码了。</p><p>在上面代码中，Person 把内部依赖的创建权力移交给了 Person2这个类中的 main() 方法。也就是说 Person 只关心依赖提供的功能，但并不关心依赖的创建。</p><p>这种思想其实就是 IoC，IoC 是一种新的设计模式，它对上层模块与底层模块进行了更进一步的解耦。控制反转的意思是反转了上层模块对于底层模块的依赖控制。 </p><p>比如上面代码，Person 不再亲自创建 Driveable 对象，它将依赖的实例化的权力交接给了 Person2。而 Person2在 IoC 中又指代了 <strong>IoC 容器</strong> 这个概念。</p><h3 id="依赖注入（Dependency-injection）"><a href="#依赖注入（Dependency-injection）" class="headerlink" title="依赖注入（Dependency injection）"></a>依赖注入（Dependency injection）</h3><p>依赖注入，也经常被简称为 DI，其实在上一节中，我们已经见到了它的身影。它是一种实现 IoC 的手段。什么意思呢？</p><p>为了不因为依赖实现的变动而去修改 Person，也就是说以可能在 Driveable 实现类的改变下不改动 Person 这个类的代码，尽可能减少两者之间的耦合。我们需要采用上一节介绍的 IoC 模式来进行改写代码。</p><p>这个需要我们移交出对于依赖实例化的控制权，那么依赖怎么办？Person 无法实例化依赖了，它就需要在外部（IoC 容器）赋值给它，这个赋值的动作有个专门的术语叫做注入（injection），需要注意的是在 IoC 概念中，这个注入依赖的地方被称为 IoC 容器，但在依赖注入概念中，一般被称为注射器 （injector)。</p><p><strong>表达通俗一点就是：我不想自己实例化依赖，你（injector）创建它们，然后在合适的时候注入给我</strong></p><p>实现依赖注入有 3 种方式： </p><ol><li>构造函数中注入 </li><li>setter 方式注入 </li><li>接口注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口方式注入</span></span><br><span class="line"><span class="comment"> * 接口的存在，表明了一种依赖配置的能力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepedencySetter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Driveable driveable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span>  <span class="keyword">implements</span> <span class="title">DepedencySetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口方式注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Driveable driveable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDriveable = mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">(Driveable driveable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDriveable = driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setter 方式注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriveable</span><span class="params">(Driveable mDriveable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDriveable = mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出门啦"</span>);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        <span class="comment">//mCar.drive();</span></span><br><span class="line"><span class="comment">//        mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        Person2 person = <span class="keyword">new</span> Person2(<span class="keyword">new</span> Car());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java-依赖注入标准"><a href="#Java-依赖注入标准" class="headerlink" title="Java 依赖注入标准"></a>Java 依赖注入标准</h1><p>JSR-330 是 Java 的依赖注入标准。定义了如下的术语描述依赖注入：</p><ul><li>A 类型依赖 B类型（或者说 B 被 A 依赖），则 A类型 称为”依赖(物) dependency”</li><li>运行时查找依赖的过程，称为”解析 resolving“依赖</li><li>如果找不到依赖的实例，称该依赖是”不能满足的 unsatisfied”</li><li>在”依赖注入 dependency injection”机制中，提供依赖的工具称为”依赖注入器 dependency injector，注射器”</li></ul><blockquote><p>在标准中, 依赖是类型而不是实例/对象; 在程序中（运行时）, 需要的是依赖的实例.</p></blockquote><h3 id="javax-inject"><a href="#javax-inject" class="headerlink" title="javax.inject"></a>javax.inject</h3><p> 包 javax.inject 指定了获取对象的一种方法，该方法与构造器、工厂以及服务定位器（例如 JNDI））这些传统方法相比可以获得更好的可重用性、可测试性以及可维护性。此方法的处理过程就是大家熟知的依赖注入，它对于大多数应用是非常有价值的。</p><h3 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h3><p> 注解 @Inject<br>标识了可注入的构造器、方法或字段。可以用于静态或实例成员。一个可注入的成员可以被任何访问修饰符（private、package-<br>private、protected、public）修饰。注入顺序为构造器，字段，最后是方法。超类的字段、方法将优先于子类的字段、方法被注入。对于<br>同一个类的字段是不区分注入顺序的，同一个类的方法亦同</p><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider<t></t></h3><p> 接口 Provider 用于提供类型 T 的实列。Provider 是一般情况是由注入器实现的。对于任何可注入的 T 而言，您也可以注入 Provider<t>。与直接注入 T 相比，注入 Provider<t> 使得：</t></t></p><ul><li>可以返回多个实例。</li><li>实例的返回可以延迟化或可选</li><li>打破循环依赖。</li><li>可以在一个已知作用域的实例内查询一个更小作用域内的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Inject</span> Car(Provider&lt;Seat&gt; seatProvider) &#123;</span><br><span class="line">            Seat driver = seatProvider.get();</span><br><span class="line">            Seat passenger = seatProvider.get();</span><br><span class="line">           …</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get()<br>用于提供一个完全构造的类型 T 的实例。<br>异常抛出：RuntimeException —— 当注入器在提供实例时遇到错误将抛出此异常。例如，对于一个可注入的成员 T<br>抛出了一个异常，注入器将包装此异常并将它抛给 get()<br>的调用者。调用者不应该尝试处理此类异常，因为不同注入器实现的行为不一样，即使是同一个注入器，也会因为配置不同而表现的行为不同。</li></ul><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>用于标识限定器注解。任何人都可以定义新的限定器注解。一个限定器注解：</p><ul><li>是被 @Qualifier、@Retention(RUNTIME) 标注的，通常也被 @Documented 标注。</li><li>可以拥有属性。</li><li>可能是公共 API 的一部分，就像依赖类型一样，而不像类型实现那样不作为公共 API 的一部分。</li><li>如果标注了 @Target 可能会有一些用法限制。本规范只是指定了限定器注解可以被使用在字段和参数上，但一些注入器配置可能使用限定器注解在其他一些地方（例如方法或类）上。</li></ul><h3 id="Named"><a href="#Named" class="headerlink" title="@Named"></a>@Named</h3><ul><li>基于 String 的[限定器]</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><ul><li>用于标识作用域注解。一个作用域注解是被标识在包含一个可注入构造器的类上的，用于控制该类型的实例如何被注入器重用。缺省情况下，如果没有标识作用域注解，注入器将为每一次注入都创建（通过注入类型的构造器）新实例，并不重用已有实例。如果多个线程都能够访问一个作用域内的实例，该实例实现应该是线程安全的。作用域实现由注入器完成。</li></ul><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="@Singleton"></a>@Singleton</h3><ul><li>标识了注入器只实例化一次的类型。该注解不能被继承</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h1&gt;&lt;h2 id=&quot;注解的定义&quot;&gt;&lt;a href=&quot;#注解的定义&quot; class=&quot;headerlink&quot; title=&quot;注解的定义&quot;&gt;&lt;/a&gt;注解的定义&lt;/h2&gt;&lt;p&gt;Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。&lt;/p&gt;
&lt;h2 id=&quot;注解即标签&quot;&gt;&lt;a href=&quot;#注解即标签&quot; class=&quot;headerlink&quot; title=&quot;注解即标签&quot;&gt;&lt;/a&gt;注解即标签&lt;/h2&gt;&lt;p&gt;如果把代码想象成一个具有生命的个体，注解就是给这些代码的某些个体打标签&lt;/p&gt;
&lt;h2 id=&quot;如何自定义注解&quot;&gt;&lt;a href=&quot;#如何自定义注解&quot; class=&quot;headerlink&quot; title=&quot;如何自定义注解&quot;&gt;&lt;/a&gt;如何自定义注解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;注解通过 @interface关键字进行定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 Test 的注解。&lt;br&gt;你可以简单理解为创建了一张名字为 Test的标签。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用注解&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestAnnotation&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;创建一个类 TestAnnotation,然后在类定义的地方加上 @Test就可以用 Test注解这个类了&lt;/p&gt;
&lt;p&gt;你可以简单理解为将 Test 这张标签贴到 TestAnnotation这个类上面。&lt;/p&gt;
&lt;h2 id=&quot;元注解&quot;&gt;&lt;a href=&quot;#元注解&quot; class=&quot;headerlink&quot; title=&quot;元注解&quot;&gt;&lt;/a&gt;元注解&lt;/h2&gt;&lt;p&gt;元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。&lt;/p&gt;
&lt;p&gt;如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。&lt;/p&gt;
&lt;p&gt;元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;@Retention&lt;/p&gt;
&lt;p&gt;Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。&lt;/p&gt;
&lt;p&gt;它的取值如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们&lt;/p&gt;
&lt;p&gt;java  - source被丢弃 -&amp;gt; class - class被丢弃 &amp;gt; jvm （runtime）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;@Target&lt;/p&gt;
&lt;p&gt;Target 是目标的意思，@Target 指定了注解运用的地方&lt;br&gt;你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。&lt;br&gt;类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ElementType.ANNOTATION_TYPE 可以给一个注解进行注解&lt;/li&gt;
&lt;li&gt;ElementType.CONSTRUCTOR 可以给构造方法进行注解&lt;/li&gt;
&lt;li&gt;ElementType.FIELD 可以给属性进行注解&lt;/li&gt;
&lt;li&gt;ElementType.LOCAL_VARIABLE 可以给局部变量进行注解&lt;/li&gt;
&lt;li&gt;ElementType.METHOD 可以给方法进行注解&lt;/li&gt;
&lt;li&gt;ElementType.PACKAGE 可以给一个包进行注解&lt;/li&gt;
&lt;li&gt;ElementType.PARAMETER 可以给一个方法内的参数进行注解&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Documented&lt;/p&gt;
&lt;p&gt;顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Inherited&lt;/p&gt;
&lt;p&gt;Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Repeatable&lt;/p&gt;
&lt;p&gt;Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。&lt;/p&gt;
&lt;p&gt;什么样的注解会多次应用呢？通常是注解的值可以同时取多个。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="注解" scheme="http://darryrzhong.xyz/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android之Rxjava总结指南</title>
    <link href="http://darryrzhong.xyz/2019/09/15/Android%E4%B9%8BRxjava%E6%80%BB%E7%BB%93%E6%8C%87%E5%8D%97/"/>
    <id>http://darryrzhong.xyz/2019/09/15/Android之Rxjava总结指南/</id>
    <published>2019-09-15T09:01:56.000Z</published>
    <updated>2020-03-09T05:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rxjava"><a href="#rxjava" class="headerlink" title="rxjava"></a>rxjava</h1><h2 id="Rx介绍"><a href="#Rx介绍" class="headerlink" title="Rx介绍"></a>Rx介绍</h2><h3 id="ReactiveX的历史"><a href="#ReactiveX的历史" class="headerlink" title="ReactiveX的历史"></a>ReactiveX的历史</h3><p>ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是 <a href="http://reactivex.io/" target="_blank" rel="noopener">reactivex.io</a>。</p><h3 id="什么是ReactiveX"><a href="#什么是ReactiveX" class="headerlink" title="什么是ReactiveX"></a>什么是ReactiveX</h3><p>微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。</p><p>ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。</p><h3 id="ReactiveX的应用"><a href="#ReactiveX的应用" class="headerlink" title="ReactiveX的应用"></a>ReactiveX的应用</h3><p>很多公司都在使用ReactiveX，例如Microsoft、Netflix、Github、Trello、SoundCloud。</p><h3 id="ReactiveX宣言"><a href="#ReactiveX宣言" class="headerlink" title="ReactiveX宣言"></a>ReactiveX宣言</h3><p>ReactiveX不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。</p><h2 id="Rx模式"><a href="#Rx模式" class="headerlink" title="Rx模式"></a>Rx模式</h2><h3 id="使用观察者模式"><a href="#使用观察者模式" class="headerlink" title="使用观察者模式"></a>使用观察者模式</h3><ul><li>创建：Rx可以方便的创建事件流和数据流</li><li>组合：Rx使用查询式的操作符组合和变换数据流</li><li>监听：Rx可以订阅任何可观察的数据流并执行操作</li></ul><h3 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h3><ul><li>函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态</li><li>简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码</li><li>异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制</li><li>轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题</li></ul><h3 id="使用Observable的优势"><a href="#使用Observable的优势" class="headerlink" title="使用Observable的优势"></a>使用Observable的优势</h3><p>Rx扩展了观察者模式用于支持数据和事件序列，添加了一些操作符，它让你可以声明式的组合这些序列，而无需关注底层的实现：如线程、同步、线程安全、并发数据结构和非阻塞IO。</p><p>Observable通过使用最佳的方式访问异步数据序列填补了这个间隙</p><table><thead><tr><th></th><th><strong>单个数据</strong></th><th><strong>多个数据</strong></th></tr></thead><tbody><tr><td>同步</td><td><code>T getData()</code></td><td><code>Iterable&lt;T&gt; getData()</code></td></tr><tr><td>异步</td><td><code>Future&lt;T&gt; getData()</code></td><td><code>Observable&lt;T&gt; getData()</code></td></tr></tbody></table><p>Rx的Observable模型让你可以像使用集合数据一样操作异步事件流，对异步事件流使用各种简单、可组合的操作。</p><a id="more"></a><h4 id="Observable可组合"><a href="#Observable可组合" class="headerlink" title="Observable可组合"></a>Observable可组合</h4><p>对于单层的异步操作来说，Java中Future对象的处理方式是非常简单有效的，但是一旦涉及到嵌套，它们就开始变得异常繁琐和复杂。使用Future很难很好的组合带条件的异步执行流程（考虑到运行时各种潜在的问题，甚至可以说是不可能的），当然，要想实现还是可以做到的，但是非常困难，或许你可以用<code>Future.get()</code>，但这样做，异步执行的优势就完全没有了。从另一方面说，Rx的Observable一开始就是为组合异步数据流准备的。</p><h4 id="Observable更灵活"><a href="#Observable更灵活" class="headerlink" title="Observable更灵活"></a>Observable更灵活</h4><p>Rx的Observable不仅支持处理单独的标量值（就像Future可以做的），也支持数据序列，甚至是无穷的数据流。<code>Observable</code>是一个抽象概念，适用于任何场景。Observable拥有它的近亲Iterable的全部优雅与灵活。</p><p>Observable是异步的双向push，Iterable是同步的单向pull，对比：</p><table><thead><tr><th>事件</th><th>Iterable(pull)</th><th>Observable(push)</th></tr></thead><tbody><tr><td>获取数据</td><td><code>T next()</code></td><td><code>onNext(T)</code></td></tr><tr><td>异常处理</td><td>throws <code>Exception</code></td><td><code>onError(Exception)</code></td></tr><tr><td>任务完成</td><td><code>!hasNext()</code></td><td><code>onCompleted()</code></td></tr></tbody></table><h4 id="Observable无偏见"><a href="#Observable无偏见" class="headerlink" title="Observable无偏见"></a>Observable无偏见</h4><p>Rx对于对于并发性或异步性没有任何特殊的偏好，Observable可以用任何方式实现，线程池、事件循环、非阻塞IO、Actor模式，任何满足你的需求的，你擅长或偏好的方式都可以。无论你选择怎样实现它，无论底层实现是阻塞的还是非阻塞的，客户端代码将所有与Observable的交互都当做是异步的。</p><p><strong>Observable是如何实现的？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Observable&lt;data&gt; getData();</span><br></pre></td></tr></table></figure><ul><li>它能与调用者在同一线程同步执行吗？</li><li>它能异步地在单独的线程执行吗？</li><li>它会将工作分发到多个线程，返回数据的顺序是任意的吗？</li><li>它使用Actor模式而不是线程池吗？</li><li>它使用NIO和事件循环执行异步网络访问吗？</li><li>它使用事件循环将工作线程从回调线程分离出来吗？</li></ul><p>从Observer的视角看，这些都无所谓，重要的是：使用Rx，你可以改变你的观念，你可以在完全不影响Observable程序库使用者的情况下，彻底的改变Observable的底层实现。</p><h4 id="使用回调存在很多问题"><a href="#使用回调存在很多问题" class="headerlink" title="使用回调存在很多问题"></a>使用回调存在很多问题</h4><p>回调在不阻塞任何事情的情况下，解决了<code>Future.get()</code>过早阻塞的问题。由于响应结果一旦就绪Callback就会被调用，它们天生就是高效率的。不过，就像使用Future一样，对于单层的异步执行来说，回调很容易使用，对于嵌套的异步组合，它们显得非常笨拙。</p><h4 id="Rx是一个多语言的实现"><a href="#Rx是一个多语言的实现" class="headerlink" title="Rx是一个多语言的实现"></a>Rx是一个多语言的实现</h4><p>Rx在大量的编程语言中都有实现，并尊重实现语言的风格，而且更多的实现正在飞速增加。</p><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p>Rx提供了一系列的操作符，你可以使用它们来过滤(filter)、选择(select)、变换(transform)、结合(combine)和组合(compose)多个Observable，这些操作符让执行和复合变得非常高效。</p><p>你可以把Observable当做Iterable的推送方式的等价物，使用Iterable，消费者从生产者那拉取数据，线程阻塞直至数据准备好。使用Observable，在数据准备好时，生产者将数据推送给消费者。数据可以同步或异步的到达，这种方式更灵活。</p><p>下面的例子展示了相似的高阶函数在Iterable和Observable上的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Iterable</span><br><span class="line">getDataFromLocalMemory()</span><br><span class="line">  .skip(10)</span><br><span class="line">  .take(5)</span><br><span class="line">  .map(&#123; s -&gt; return s + &quot; transformed&quot; &#125;)</span><br><span class="line">  .forEach(&#123; println &quot;next =&gt; &quot; + it &#125;)</span><br><span class="line"></span><br><span class="line">// Observable</span><br><span class="line">getDataFromNetwork()</span><br><span class="line">  .skip(10)</span><br><span class="line">  .take(5)</span><br><span class="line">  .map(&#123; s -&gt; return s + &quot; transformed&quot; &#125;)</span><br><span class="line">  .subscribe(&#123; println &quot;onNext =&gt; &quot; + it &#125;)</span><br></pre></td></tr></table></figure><p>Observable类型给GOF的观察者模式添加了两种缺少的语义，这样就和Iterable类型中可用的操作一致了：</p><ol><li>生产者可以发信号给消费者，通知它没有更多数据可用了（对于Iterable，一个for循环正常完成表示没有数据了；对于Observable，就是调用观察者的<code>onCompleted</code>方法）</li><li>生产者可以发信号给消费者，通知它遇到了一个错误（对于Iterable，迭代过程中发生错误会抛出异常；对于Observable，就是调用观察者(Observer)的<code>onError</code>方法）</li></ol><p>有了这两种功能，Rx就能使Observable与Iterable保持一致了，唯一的不同是数据流的方向。任何对Iterable的操作，你都可以对Observable使用。</p><h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>这里给出一些名词的翻译</p><ul><li>Reactive 直译为反应性的，有活性的，根据上下文一般翻译为反应式、响应式</li><li>Iterable 可迭代对象，支持以迭代器的形式遍历，许多语言中都存在这个概念</li><li>Observable 可观察对象，在Rx中定义为更强大的Iterable，在观察者模式中是被观察的对象，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者</li><li>Observer 观察者对象，监听Observable发射的数据并做出响应，Subscriber是它的一个特殊实现</li><li>emit 直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法，文章里一律译为发射</li><li>items 直译为项目，条目，在Rx里是指Observable发射的数据项，文章里一律译为数据，数据项</li></ul><h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在ReactiveX中，一个观察者(Observer)订阅一个可观察对象(Observable)。观察者对Observable发射的数据或数据序列作出响应。这种模式可以极大地简化并发操作，因为它创建了一个处于待命状态的观察者哨兵，在未来某个时刻响应Observable的通知，不需要阻塞等待Observable发射数据。</p><p>这篇文章会解释什么是响应式编程模式(reactive pattern)，以及什么是可观察对象(Observables)和观察者(observers)，其它几篇文章会展示如何用操作符组合和改变Observable的行为。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/legend.png" alt="Observable"></p><h4 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h4><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Single.html" target="_blank" rel="noopener">Single</a> - 一个特殊的Observable，只发射单个数据。</li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在很多软件编程任务中，或多或少你都会期望你写的代码能按照编写的顺序，一次一个的顺序执行和完成。但是在ReactiveX中，很多指令可能是并行执行的，之后他们的执行结果才会被观察者捕获，顺序是不确定的。为达到这个目的，你定义一种获取和变换数据的机制，而不是调用一个方法。在这种机制下，存在一个可观察对象(Observable)，观察者(Observer)订阅(Subscribe)它，当数据就绪时，之前定义的机制就会分发数据给一直处于等待状态的观察者哨兵。</p><p>这种方法的优点是，如果你有大量的任务要处理，它们互相之间没有依赖关系。你可以同时开始执行它们，不用等待一个完成再开始下一个（用这种方式，你的整个任务队列能耗费的最长时间，不会超过任务里最耗时的那个）。</p><p>有很多术语可用于描述这种异步编程和设计模式，在在本文里我们使用这些术语：<strong>一个观察者订阅一个可观察对象</strong> (<em>An observer subscribes to an Observable</em>)。通过调用观察者的方法，Observable发射数据或通知给它的观察者。</p><p>在其它的文档和场景里，有时我们也将<strong>Observer</strong>叫做<em>Subscriber</em>、<em>Watcher</em>、<em>Reactor</em>。这个模型通常被称作<em>Reactor模式</em>。</p><h2 id="创建观察者"><a href="#创建观察者" class="headerlink" title="创建观察者"></a>创建观察者</h2><p>本文使用类似于Groovy的伪代码举例，但是ReactiveX有多种语言的实现。</p><p>普通的方法调用（不是某种异步方法，也不是Rx中的并行调用），流程通常是这样的：</p><ol><li>调用某一个方法</li><li>用一个变量保存方法返回的结果</li><li>使用这个变量和它的新值做些有用的事</li></ol><p>用代码描述就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// make the call, assign its return value to `returnVal`</span><br><span class="line">returnVal = someMethod(itsParameters);</span><br><span class="line">// do something useful with returnVal</span><br></pre></td></tr></table></figure><p>在异步模型中流程更像这样的：</p><ol><li>定义一个方法，这个方法拿着某个异步调用的返回值做一些有用的事情。这个方法是观察者的一部分。</li><li>将这个异步调用本身定义为一个Observable</li><li>观察者通过订阅(Subscribe)操作关联到那个Observable</li><li>继续你的业务逻辑，等方法返回时，Observable会发射结果，观察者的方法会开始处理结果或结果集</li></ol><p>用代码描述就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// defines, but does not invoke, the Subscriber&apos;s onNext handler</span><br><span class="line">// (in this example, the observer is very simple and has only an onNext handler)</span><br><span class="line">def myOnNext = &#123; it -&gt; do something useful with it &#125;;</span><br><span class="line">// defines, but does not invoke, the Observable</span><br><span class="line">def myObservable = someObservable(itsParameters);</span><br><span class="line">// subscribes the Subscriber to the Observable, and invokes the Observable</span><br><span class="line">myObservable.subscribe(myOnNext);</span><br><span class="line">// go on about my business</span><br></pre></td></tr></table></figure><h3 id="回调方法-onNext-onCompleted-onError"><a href="#回调方法-onNext-onCompleted-onError" class="headerlink" title="回调方法 (onNext, onCompleted, onError)"></a>回调方法 (onNext, onCompleted, onError)</h3><p>Subscribe方法用于将观察者连接到Observable，你的观察者需要实现以下方法的一个子集：</p><ul><li><p><strong>onNext(T item)</strong></p><p>Observable调用这个方法发射数据，方法的参数就是Observable发射的数据，这个方法可能会被调用多次，取决于你的实现。</p></li><li><p><strong>onError(Exception ex)</strong></p><p>当Observable遇到错误或者无法返回期望的数据时会调用这个方法，这个调用会终止Observable，后续不会再调用onNext和onCompleted，onError方法的参数是抛出的异常。</p></li><li><p><strong>onComplete</strong></p><p>正常终止，如果没有遇到错误，Observable在最后一次调用onNext之后调用此方法。</p></li></ul><p>根据Observable协议的定义，onNext可能会被调用零次或者很多次，最后会有一次onCompleted或onError调用（不会同时），传递数据给onNext通常被称作发射，onCompleted和onError被称作通知。</p><p>下面是一个更完整的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def myOnNext     = &#123; item -&gt; /* do something useful with item */ &#125;;</span><br><span class="line">def myError      = &#123; throwable -&gt; /* react sensibly to a failed call */ &#125;;</span><br><span class="line">def myComplete   = &#123; /* clean up after the final response */ &#125;;</span><br><span class="line">def myObservable = someMethod(itsParameters);</span><br><span class="line">myObservable.subscribe(myOnNext, myError, myComplete);</span><br><span class="line">// go on about my business</span><br></pre></td></tr></table></figure><h3 id="取消订阅-Unsubscribing"><a href="#取消订阅-Unsubscribing" class="headerlink" title="取消订阅 (Unsubscribing)"></a>取消订阅 (Unsubscribing)</h3><p>在一些ReactiveX实现中，有一个特殊的观察者接口<em>Subscriber</em>，它有一个<em>unsubscribe</em>方法。调用这个方法表示你不关心当前订阅的Observable了，因此Observable可以选择停止发射新的数据项（如果没有其它观察者订阅）。</p><p>取消订阅的结果会传递给这个Observable的操作符链，而且会导致这个链条上的每个环节都停止发射数据项。这些并不保证会立即发生，然而，对一个Observable来说，即使没有观察者了，它也可以在一个while循环中继续生成并尝试发射数据项。</p><h3 id="关于命名约定"><a href="#关于命名约定" class="headerlink" title="关于命名约定"></a>关于命名约定</h3><p>ReactiveX的每种特定语言的实现都有自己的命名偏好，虽然不同的实现之间有很多共同点，但并不存在一个统一的命名标准。</p><p>而且，在某些场景中，一些名字有不同的隐含意义，或者在某些语言看来比较怪异。</p><p>例如，有一个<em>onEvent</em>命名模式(onNext, onCompleted, onError)，在一些场景中，这些名字可能意味着事件处理器已经注册。然而在ReactiveX里，他们是事件处理器的名字。</p><h2 id="Observables的”热”和”冷”"><a href="#Observables的”热”和”冷”" class="headerlink" title="Observables的”热”和”冷”"></a>Observables的”热”和”冷”</h2><p>Observable什么时候开始发射数据序列？这取决于Observable的实现，一个”热”的Observable可能一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</p><p>在一些ReactiveX实现里，还存在一种被称作<em>Connectable</em>的Observable，不管有没有观察者订阅它，这种Observable都不会开始发射数据，除非Connect方法被调用。</p><h2 id="用操作符组合Observable"><a href="#用操作符组合Observable" class="headerlink" title="用操作符组合Observable"></a>用操作符组合Observable</h2><p>对于ReactiveX来说，Observable和Observer仅仅是个开始，它们本身不过是标准观察者模式的一些轻量级扩展，目的是为了更好的处理事件序列。</p><p>ReactiveX真正强大的地方在于它的操作符，操作符让你可以变换、组合、操纵和处理Observable发射的数据。</p><p>Rx的操作符让你可以用声明式的风格组合异步操作序列，它拥有回调的所有效率优势，同时又避免了典型的异步系统中嵌套回调的缺点。</p><p>下面是常用的操作符列表：</p><ol><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Creating-Observables.html" target="_blank" rel="noopener">创建操作</a> Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, Timer</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Transforming-Observables.html" target="_blank" rel="noopener">变换操作</a> Buffer, FlatMap, GroupBy, Map, Scan和Window</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Filtering-Observables.html" target="_blank" rel="noopener">过滤操作</a> Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, TakeLast</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Combining-Observables.html" target="_blank" rel="noopener">组合操作</a> And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, Zip</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Error-Handling-Operators.html" target="_blank" rel="noopener">错误处理</a> Catch和Retry</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Observable-Utility-Operators.html" target="_blank" rel="noopener">辅助操作</a> Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, Using</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional-and-Boolean-Operators.html" target="_blank" rel="noopener">条件和布尔操作</a> All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, TakeWhile</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical-and-Aggregate-Operators.html" target="_blank" rel="noopener">算术和集合操作</a> Average, Concat, Count, Max, Min, Reduce, Sum</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener">转换操作</a> To</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Connectable-Observable-Operators.html" target="_blank" rel="noopener">连接操作</a> Connect, Publish, RefCount, Replay</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Backpressure.html" target="_blank" rel="noopener">反压操作</a>，用于增加特殊的流程控制策略的操作符</li></ol><p>这些操作符并不全都是ReactiveX的核心组成部分，有一些是语言特定的实现或可选的模块。</p><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p>在RxJava中，一个实现了<em>Observer</em>接口的对象可以订阅(<em>subscribe</em>)一个<em>Observable</em> 类的实例。订阅者(subscriber)对Observable发射(<em>emit</em>)的任何数据或数据序列作出响应。这种模式简化了并发操作，因为它不需要阻塞等待Observable发射数据，而是创建了一个处于待命状态的观察者哨兵，哨兵在未来某个时刻响应Observable的通知。</p><h1 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>RxJava（以及它派生出来的RxGroovy和RxScala）中有一个名为<strong>Single</strong>的Observable变种。</p><p>Single类似于Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值。</p><p>因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两个方法：</p><ul><li>onSuccess - Single发射单个的值到这个方法</li><li>onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法</li></ul><p>Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关系终止。</p><h3 id="Single的操作符"><a href="#Single的操作符" class="headerlink" title="Single的操作符"></a>Single的操作符</h3><p>Single也可以组合使用多种操作，一些操作符让你可以混合使用Observable和Single：</p><table><thead><tr><th>操作符</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>compose</td><td>Single</td><td>创建一个自定义的操作符</td></tr><tr><td>concat and concatWith</td><td>Observable</td><td>连接多个Single和Observable发射的数据</td></tr><tr><td>create</td><td>Single</td><td>调用观察者的create方法创建一个Single</td></tr><tr><td>error</td><td>Single</td><td>返回一个立即给订阅者发射错误通知的Single</td></tr><tr><td>flatMap</td><td>Single</td><td>返回一个Single，它发射对原Single的数据执行flatMap操作后的结果</td></tr><tr><td>flatMapObservable</td><td>Observable</td><td>返回一个Observable，它发射对原Single的数据执行flatMap操作后的结果</td></tr><tr><td>from</td><td>Single</td><td>将Future转换成Single</td></tr><tr><td>just</td><td>Single</td><td>返回一个发射一个指定值的Single</td></tr><tr><td>map</td><td>Single</td><td>返回一个Single，它发射对原Single的数据执行map操作后的结果</td></tr><tr><td>merge</td><td>Single</td><td>将一个Single(它发射的数据是另一个Single，假设为B)转换成另一个Single(它发射来自另一个Single(B)的数据)</td></tr><tr><td>merge and mergeWith</td><td>Observable</td><td>合并发射来自多个Single的数据</td></tr><tr><td>observeOn</td><td>Single</td><td>指示Single在指定的调度程序上调用订阅者的方法</td></tr><tr><td>onErrorReturn</td><td>Single</td><td>将一个发射错误通知的Single转换成一个发射指定数据项的Single</td></tr><tr><td>subscribeOn</td><td>Single</td><td>指示Single在指定的调度程序上执行操作</td></tr><tr><td>timeout</td><td>Single</td><td>它给原有的Single添加超时控制，如果超时了就发射一个错误通知</td></tr><tr><td>toSingle</td><td>Single</td><td>将一个发射单个值的Observable转换为一个Single</td></tr><tr><td>zip and zipWith</td><td>Single</td><td>将多个Single转换为一个，后者发射的数据是对前者应用一个函数后的结果</td></tr></tbody></table><h3 id="操作符图示"><a href="#操作符图示" class="headerlink" title="操作符图示"></a>操作符图示</h3><p>详细的图解可以参考英文文档：<a href="http://reactivex.io/documentation/single.html" target="_blank" rel="noopener">Single</a></p><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p>Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。</p><p>由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是”冷”的–就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject可以把原来那个”冷”的Observable变成”热”的。</p><h2 id="Subject的种类"><a href="#Subject的种类" class="headerlink" title="Subject的种类"></a>Subject的种类</h2><p>针对不同的场景一共有四种类型的Subject。他们并不是在所有的实现中全部都存在，而且一些实现使用其它的命名约定（例如，在RxScala中Subject被称作PublishSubject）。</p><h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><p>一个AsyncSubject只在原始Observable完成后，发射来自原始Observable的最后一个值。（如果原始Observable没有发射任何值，AsyncObject也不发射任何值）它会把这最后一个值发射给任何后续的观察者。 <img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.png" alt="img"></p><p>然而，如果原始的Observable因为发生了错误而终止，AsyncSubject将不会发射任何数据，只是简单的向前传递这个错误通知。 <img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.e.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.e.png" alt="img"></p><h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p>当观察者订阅BehaviorSubject时，它开始发射原始Observable最近发射的数据（如果此时还没有收到任何数据，它会发射一个默认值），然后继续发射其它任何来自原始Observable的数据。 <img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.png" alt="img"></p><p>然而，如果原始的Observable因为发生了一个错误而终止，BehaviorSubject将不会发射任何数据，只是简单的向前传递这个错误通知。 <img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.e.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.e.png" alt="img"></p><h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><p>PublishSubject只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者。需要注意的是，PublishSubject可能会一创建完成就立刻开始发射数据（除非你可以阻止它发生），因此这里有一个风险：在Subject被创建后到有观察者订阅它之前这个时间段内，一个或多个数据可能会丢失。如果要确保来自原始Observable的所有数据都被分发，你需要这样做：或者使用Create创建那个Observable以便手动给它引入”冷”Observable的行为（当所有观察者都已经订阅时才开始发射数据），或者改用ReplaySubject。 <img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.png" alt="img"></p><p>如果原始的Observable因为发生了一个错误而终止，PublishSubject将不会发射任何数据，只是简单的向前传递这个错误通知。 <img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.e.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.e.png" alt="img"></p><h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p>ReplaySubject会发射所有来自原始Observable的数据给观察者，无论它们是何时订阅的。也有其它版本的ReplaySubject，在重放缓存增长到一定大小的时候或过了一段时间后会丢弃旧的数据（原始Observable发射的）。</p><p>如果你把ReplaySubject当作一个观察者使用，注意不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.ReplaySubject.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.ReplaySubject.png" alt="img"></p><h3 id="RxJava的对应类"><a href="#RxJava的对应类" class="headerlink" title="RxJava的对应类"></a>RxJava的对应类</h3><p>假设你有一个Subject，你想把它传递给其它的代理或者暴露它的Subscriber接口，你可以调用它的asObservable方法，这个方法返回一个Observable。具体使用方法可以参考Javadoc文档。</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>如果你把 <code>Subject</code> 当作一个 <code>Subscriber</code> 使用，注意不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。</p><p>要避免此类问题，你可以将 <code>Subject</code> 转换为一个 <a href="http://reactivex.io/RxJava/javadoc/rx/subjects/SerializedSubject.html" target="_blank" rel="noopener"><code>SerializedSubject</code></a> ，类似于这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySafeSubject = new SerializedSubject( myUnsafeSubject );</span><br></pre></td></tr></table></figure><h1 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 Scheduler</h1><p>如果你想给Observable操作符链添加多线程功能，你可以指定操作符（或者特定的Observable）在特定的调度器(Scheduler)上执行。</p><p>某些ReactiveX的Observable操作符有一些变体，它们可以接受一个Scheduler参数。这个参数指定操作符将它们的部分或全部任务放在一个特定的调度器上执行。</p><p>使用ObserveOn和SubscribeOn操作符，你可以让Observable在一个特定的调度器上执行，ObserveOn指示一个Observable在一个特定的调度器上调用观察者的onNext, onError和onCompleted方法，SubscribeOn更进一步，它指示Observable将全部的处理过程（包括发射数据和通知）放在特定的调度器上执行。</p><h2 id="RxJava示例"><a href="#RxJava示例" class="headerlink" title="RxJava示例"></a>RxJava示例</h2><h3 id="调度器的种类"><a href="#调度器的种类" class="headerlink" title="调度器的种类"></a>调度器的种类</h3><p>下表展示了RxJava中可用的调度器种类：</p><table><thead><tr><th>调度器类型</th><th>效果</th></tr></thead><tbody><tr><td>Schedulers.computation( )</td><td>用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.immediate( )</td><td>在当前线程立即开始执行任务</td></tr><tr><td>Schedulers.io( )</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.newThread( )</td><td>为每个任务创建一个新线程</td></tr><tr><td>Schedulers.trampoline( )</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr></tbody></table><h3 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h3><p>在RxJava中，某些Observable操作符的变体允许你设置用于操作执行的调度器，其它的则不在任何特定的调度器上执行，或者在一个指定的默认调度器上执行。下面的表格个列出了一些操作符的默认调度器：</p><table><thead><tr><th>操作符</th><th>调度器</th></tr></thead><tbody><tr><td>buffer(timespan)</td><td>computation</td></tr><tr><td>buffer(timespan, count)</td><td>computation</td></tr><tr><td>buffer(timespan, timeshift)</td><td>computation</td></tr><tr><td>debounce(timeout, unit)</td><td>computation</td></tr><tr><td>delay(delay, unit)</td><td>computation</td></tr><tr><td>delaySubscription(delay, unit)</td><td>computation</td></tr><tr><td>interval</td><td>computation</td></tr><tr><td>repeat</td><td>trampoline</td></tr><tr><td>replay(time, unit)</td><td>computation</td></tr><tr><td>replay(buffersize, time, unit)</td><td>computation</td></tr><tr><td>replay(selector, time, unit)</td><td>computation</td></tr><tr><td>replay(selector, buffersize, time, unit)</td><td>computation</td></tr><tr><td>retry</td><td>trampoline</td></tr><tr><td>sample(period, unit)</td><td>computation</td></tr><tr><td>skip(time, unit)</td><td>computation</td></tr><tr><td>skipLast(time, unit)</td><td>computation</td></tr><tr><td>take(time, unit)</td><td>computation</td></tr><tr><td>takeLast(time, unit)</td><td>computation</td></tr><tr><td>takeLast(count, time, unit)</td><td>computation</td></tr><tr><td>takeLastBuffer(time, unit)</td><td>computation</td></tr><tr><td>takeLastBuffer(count, time, unit)</td><td>computation</td></tr><tr><td>throttleFirst</td><td>computation</td></tr><tr><td>throttleLast</td><td>computation</td></tr><tr><td>throttleWithTimeout</td><td>computation</td></tr><tr><td>timeInterval</td><td>immediate</td></tr><tr><td>timeout(timeoutSelector)</td><td>immediate</td></tr><tr><td>timeout(firstTimeoutSelector, timeoutSelector)</td><td>immediate</td></tr><tr><td>timeout(timeoutSelector, other)</td><td>immediate</td></tr><tr><td>timeout(timeout, timeUnit)</td><td>computation</td></tr><tr><td>timeout(firstTimeoutSelector, timeoutSelector, other)</td><td>immediate</td></tr><tr><td>timeout(timeout, timeUnit, other)</td><td>computation</td></tr><tr><td>timer</td><td>computation</td></tr><tr><td>timestamp</td><td>immediate</td></tr><tr><td>window(timespan)</td><td>computation</td></tr><tr><td>window(timespan, count)</td><td>computation</td></tr><tr><td>window(timespan, timeshift)</td><td>computation</td></tr></tbody></table><h3 id="使用调度器"><a href="#使用调度器" class="headerlink" title="使用调度器"></a>使用调度器</h3><p>除了将这些调度器传递给RxJava的Observable操作符，你也可以用它们调度你自己的任务。下面的示例展示了Scheduler.Worker的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">worker = Schedulers.newThread().createWorker();</span><br><span class="line">worker.schedule(new Action0() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        yourWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">// some time later...</span><br><span class="line">worker.unsubscribe();</span><br></pre></td></tr></table></figure><h4 id="递归调度器"><a href="#递归调度器" class="headerlink" title="递归调度器"></a>递归调度器</h4><p>要调度递归的方法调用，你可以使用schedule，然后再用schedule(this)，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">worker = Schedulers.newThread().createWorker();</span><br><span class="line">worker.schedule(new Action0() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        yourWork();</span><br><span class="line">        // recurse until unsubscribed (schedule will do nothing if unsubscribed)</span><br><span class="line">        worker.schedule(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">// some time later...</span><br><span class="line">worker.unsubscribe();</span><br></pre></td></tr></table></figure><h4 id="检查或设置取消订阅状态"><a href="#检查或设置取消订阅状态" class="headerlink" title="检查或设置取消订阅状态"></a>检查或设置取消订阅状态</h4><p>Worker类的对象实现了Subscription接口，使用它的isUnsubscribed和unsubscribe方法，所以你可以在订阅取消时停止任务，或者从正在调度的任务内部取消订阅，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Worker worker = Schedulers.newThread().createWorker();</span><br><span class="line">Subscription mySubscription = worker.schedule(new Action0() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        while(!worker.isUnsubscribed()) &#123;</span><br><span class="line">            status = yourWork();</span><br><span class="line">            if(QUIT == status) &#123; worker.unsubscribe(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Worker同时是Subscription，因此你可以（通常也应该）调用它的unsubscribe方法通知可以挂起任务和释放资源了。</p><h4 id="延时和周期调度器"><a href="#延时和周期调度器" class="headerlink" title="延时和周期调度器"></a>延时和周期调度器</h4><p>你可以使用schedule(action,delayTime,timeUnit)在指定的调度器上延时执行你的任务，下面例子中的任务将在500毫秒之后开始执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>使用另一个版本的schedule，schedulePeriodically(action,initialDelay,period,timeUnit)方法让你可以安排一个定期执行的任务，下面例子的任务将在500毫秒之后执行，然后每250毫秒执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someScheduler.schedulePeriodically(someAction, 500, 250, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h3 id="测试调度器"><a href="#测试调度器" class="headerlink" title="测试调度器"></a>测试调度器</h3><p>TestScheduler让你可以对调度器的时钟表现进行手动微调。这对依赖精确时间安排的任务的测试很有用处。这个调度器有三个额外的方法：</p><ul><li>advanceTimeTo(time,unit) 向前波动调度器的时钟到一个指定的时间点</li><li>advanceTimeBy(time,unit) 将调度器的时钟向前拨动一个指定的时间段</li><li>triggerActions( ) 开始执行任何计划中的但是未启动的任务，如果它们的计划时间等于或者早于调度器时钟的当前时间</li></ul><h1 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h1><p>ReactiveX的每种编程语言的实现都实现了一组操作符的集合。不同的实现之间有很多重叠的部分，也有一些操作符只存在特定的实现中。每种实现都倾向于用那种编程语言中他们熟悉的上下文中相似的方法给这些操作符命名。</p><p>本文首先会给出ReactiveX的核心操作符列表和对应的文档链接，后面还有一个决策树用于帮助你根据具体的场景选择合适的操作符。最后有一个语言特定实现的按字母排序的操作符列表。</p><p>如果你想实现你自己的操作符，可以参考这里：<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Implementing-Your-Own-Operators.html" target="_blank" rel="noopener"><code>实现自定义操作符</code></a></p><h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><p>用于创建Observable的操作符</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Create.html" target="_blank" rel="noopener"><code>Create</code></a> — 通过调用观察者的方法从头创建一个Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Defer.html" target="_blank" rel="noopener"><code>Defer</code></a> — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Empty.html" target="_blank" rel="noopener"><code>Empty/Never/Throw</code></a> — 创建行为受限的特殊Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/From.html" target="_blank" rel="noopener"><code>From</code></a> — 将其它的对象或数据结构转换为Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Interval.html" target="_blank" rel="noopener"><code>Interval</code></a> — 创建一个定时发射整数序列的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Just.html" target="_blank" rel="noopener"><code>Just</code></a> — 将对象或者对象集合转换为一个会发射这些对象的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Range.html" target="_blank" rel="noopener"><code>Range</code></a> — 创建发射指定范围的整数序列的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Repeat.html" target="_blank" rel="noopener"><code>Repeat</code></a> — 创建重复发射特定的数据或数据序列的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html" target="_blank" rel="noopener"><code>Start</code></a> — 创建发射一个函数的返回值的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Timer.html" target="_blank" rel="noopener"><code>Timer</code></a> — 创建在一个指定的延迟之后发射单个数据的Observable</li></ul><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><p>这些操作符可用于对Observable发射的数据进行变换，详细解释可以看每个操作符的文档</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Buffer.html" target="_blank" rel="noopener"><code>Buffer</code></a> — 缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/FlatMap.html" target="_blank" rel="noopener"><code>FlatMap</code></a> — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/GroupBy.html" target="_blank" rel="noopener"><code>GroupBy</code></a> — 分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html" target="_blank" rel="noopener"><code>Map</code></a> — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Scan.html" target="_blank" rel="noopener"><code>Scan</code></a> — 扫描，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射这些值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Window.html" target="_blank" rel="noopener"><code>Window</code></a> — 窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集</li></ul><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><p>这些操作符用于从Observable发射的数据中进行选择</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Debounce.html" target="_blank" rel="noopener"><code>Debounce</code></a> — 只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Distinct.html" target="_blank" rel="noopener"><code>Distinct</code></a> — 去重，过滤掉重复数据项</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/ElementAt.md" target="_blank" rel="noopener"><code>ElementAt</code></a> — 取值，取特定位置的数据项</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Filter.html" target="_blank" rel="noopener"><code>Filter</code></a> — 过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html" target="_blank" rel="noopener"><code>First</code></a> — 首项，只发射满足条件的第一条数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/IgnoreElements.html" target="_blank" rel="noopener"><code>IgnoreElements</code></a> — 忽略所有的数据，只保留终止通知(onError或onCompleted)</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Last.html" target="_blank" rel="noopener"><code>Last</code></a> — 末项，只发射最后一条数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Sample.html" target="_blank" rel="noopener"><code>Sample</code></a> — 取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirst</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Skip.html" target="_blank" rel="noopener"><code>Skip</code></a> — 跳过前面的若干项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SkipLast.html" target="_blank" rel="noopener"><code>SkipLast</code></a> — 跳过后面的若干项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Take.html" target="_blank" rel="noopener"><code>Take</code></a> — 只保留前面的若干项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/TakeLast.html" target="_blank" rel="noopener"><code>TakeLast</code></a> — 只保留后面的若干项数据</li></ul><h2 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h2><p>组合操作符用于将多个Observable组合成一个单一的Observable</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/And.html" target="_blank" rel="noopener"><code>And/Then/When</code></a> — 通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/CombineLatest.html" target="_blank" rel="noopener"><code>CombineLatest</code></a> — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Join.html" target="_blank" rel="noopener"><code>Join</code></a> — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Merge.html" target="_blank" rel="noopener"><code>Merge</code></a> — 将两个Observable发射的数据组合并成一个</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/StartWith.html" target="_blank" rel="noopener"><code>StartWith</code></a> — 在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Switch.html" target="_blank" rel="noopener"><code>Switch</code></a> — 将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Zip.html" target="_blank" rel="noopener"><code>Zip</code></a> — 打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>这些操作符用于从错误通知中恢复</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html" target="_blank" rel="noopener"><code>Catch</code></a> — 捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Retry.html" target="_blank" rel="noopener"><code>Retry</code></a> — 重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止</li></ul><h2 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h2><p>一组用于处理Observable的操作符</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Delay.html" target="_blank" rel="noopener"><code>Delay</code></a> — 延迟一段时间发射结果数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><code>Do</code></a> — 注册一个动作占用一些Observable的生命周期事件，相当于Mock某个操作</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Materialize.html" target="_blank" rel="noopener"><code>Materialize/Dematerialize</code></a> — 将发射的数据和通知都当做数据发射，或者反过来</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/ObserveOn.html" target="_blank" rel="noopener"><code>ObserveOn</code></a> — 指定观察者观察Observable的调度程序（工作线程）</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Serialize.html" target="_blank" rel="noopener"><code>Serialize</code></a> — 强制Observable按次序发射数据并且功能是有效的</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Subscribe.html" target="_blank" rel="noopener"><code>Subscribe</code></a> — 收到Observable发射的数据和通知后执行的操作</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SubscribeOn.html" target="_blank" rel="noopener"><code>SubscribeOn</code></a> — 指定Observable应该在哪个调度程序上执行</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/TimeInterval.html" target="_blank" rel="noopener"><code>TimeInterval</code></a> — 将一个Observable转换为发射两个数据之间所耗费时间的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Timeout.html" target="_blank" rel="noopener"><code>Timeout</code></a> — 添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Timestamp.html" target="_blank" rel="noopener"><code>Timestamp</code></a> — 给Observable发射的每个数据项添加一个时间戳</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Using.html" target="_blank" rel="noopener"><code>Using</code></a> — 创建一个只在Observable的生命周期内存在的一次性资源</li></ul><h2 id="条件和布尔操作"><a href="#条件和布尔操作" class="headerlink" title="条件和布尔操作"></a>条件和布尔操作</h2><p>这些操作符可用于单个或多个数据项，也可用于Observable</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#All" target="_blank" rel="noopener"><code>All</code></a> — 判断Observable发射的所有的数据项是否都满足某个条件</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Amb" target="_blank" rel="noopener"><code>Amb</code></a> — 给定多个Observable，只让第一个发射数据的Observable发射全部数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Contains" target="_blank" rel="noopener"><code>Contains</code></a> — 判断Observable是否会发射一个指定的数据项</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#DefaultIfEmpty" target="_blank" rel="noopener"><code>DefaultIfEmpty</code></a> — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#SequenceEqual" target="_blank" rel="noopener"><code>SequenceEqual</code></a> — 判断两个Observable是否按相同的数据序列</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#SkipUntil" target="_blank" rel="noopener"><code>SkipUntil</code></a> — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#SkipWhile" target="_blank" rel="noopener"><code>SkipWhile</code></a> — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#TakeUntil" target="_blank" rel="noopener"><code>TakeUntil</code></a> — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#TakeWhile" target="_blank" rel="noopener"><code>TakeWhile</code></a> — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据</li></ul><h2 id="算术和聚合操作"><a href="#算术和聚合操作" class="headerlink" title="算术和聚合操作"></a>算术和聚合操作</h2><p>这些操作符可用于整个数据序列</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Average" target="_blank" rel="noopener"><code>Average</code></a> — 计算Observable发射的数据序列的平均值，然后发射这个结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Concat" target="_blank" rel="noopener"><code>Concat</code></a> — 不交错的连接多个Observable的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Count" target="_blank" rel="noopener"><code>Count</code></a> — 计算Observable发射的数据个数，然后发射这个结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Max" target="_blank" rel="noopener"><code>Max</code></a> — 计算并发射数据序列的最大值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Min" target="_blank" rel="noopener"><code>Min</code></a> — 计算并发射数据序列的最小值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Reduce" target="_blank" rel="noopener"><code>Reduce</code></a> — 按顺序对数据序列的每一个应用某个函数，然后返回这个值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Sum" target="_blank" rel="noopener"><code>Sum</code></a> — 计算并发射数据序列的和</li></ul><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><p>一些有精确可控的订阅行为的特殊Observable</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Connect.html" target="_blank" rel="noopener"><code>Connect</code></a> — 指示一个可连接的Observable开始发射数据给订阅者</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Publish.html" target="_blank" rel="noopener"><code>Publish</code></a> — 将一个普通的Observable转换为可连接的</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/RefCount.html" target="_blank" rel="noopener"><code>RefCount</code></a> — 使一个可连接的Observable表现得像一个普通的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Replay.html" target="_blank" rel="noopener"><code>Replay</code></a> — 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅</li></ul><h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener"><code>To</code></a> — 将Observable转换为其它的对象或数据结构</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Blocking-Observable-Operators.html" target="_blank" rel="noopener"><code>Blocking</code></a> 阻塞Observable的操作符</li></ul><h2 id="操作符决策树"><a href="#操作符决策树" class="headerlink" title="操作符决策树"></a>操作符决策树</h2><p>几种主要的需求</p><ul><li>直接创建一个Observable（创建操作）</li><li>组合多个Observable（组合操作）</li><li>对Observable发射的数据执行变换操作（变换操作）</li><li>从Observable发射的数据中取特定的值（过滤操作）</li><li>转发Observable的部分值（条件/布尔/过滤操作）</li><li>对Observable发射的数据序列求值（算术/聚合操作）</li></ul><p>这个页面展示了创建Observable的各种方法。</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Just.html" target="_blank" rel="noopener"><strong>just( )</strong></a> — 将一个或多个对象转换成发射这个或这些对象的一个Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/From.html" target="_blank" rel="noopener"><strong>from( )</strong></a> — 将一个Iterable, 一个Future, 或者一个数组转换成一个Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Repeat.html" target="_blank" rel="noopener"><strong>repeat( )</strong></a> — 创建一个重复发射指定数据或数据序列的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Repeat.html" target="_blank" rel="noopener"><strong>repeatWhen( )</strong></a> — 创建一个重复发射指定数据或数据序列的Observable，它依赖于另一个Observable发射的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Create.html" target="_blank" rel="noopener"><strong>create( )</strong></a> — 使用一个函数从头创建一个Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Defer.html" target="_blank" rel="noopener"><strong>defer( )</strong></a> — 只有当订阅者订阅才创建Observable；为每个订阅创建一个新的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Range.html" target="_blank" rel="noopener"><strong>range( )</strong></a> — 创建一个发射指定范围的整数序列的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Interval.html" target="_blank" rel="noopener"><strong>interval( )</strong></a> — 创建一个按照给定的时间间隔发射整数序列的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Timer.html" target="_blank" rel="noopener"><strong>timer( )</strong></a> — 创建一个在给定的延时之后发射单个数据的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Empty.html" target="_blank" rel="noopener"><strong>empty( )</strong></a> — 创建一个什么都不做直接通知完成的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Empty.html" target="_blank" rel="noopener"><strong>error( )</strong></a> — 创建一个什么都不做直接通知错误的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Empty.html" target="_blank" rel="noopener"><strong>never( )</strong></a> — 创建一个不发射任何数据的Observable</li></ul><h1 id="创建操作-1"><a href="#创建操作-1" class="headerlink" title="创建操作"></a>创建操作</h1><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>使用一个函数从头开始创建一个Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/create.c.png" alt="create"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/create.c.png" alt="img"></p><p>你可以使用<code>Create</code>操作符从头开始创建一个Observable，给这个操作符传递一个接受观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable–恰当的调用观察者的onNext，onError和onCompleted方法。</p><p>一个形式正确的有限Observable必须尝试调用观察者的onCompleted正好一次或者它的onError正好一次，而且此后不能再调用观察者的任何其它方法。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/create.png" alt="create"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/create.png" alt="img"></p><p>RxJava将这个操作符实现为 <code>create</code> 方法。</p><p>建议你在传递给<code>create</code>方法的函数中检查观察者的<code>isUnsubscribed</code>状态，以便在没有观察者的时候，让你的Observable停止发射数据或者做昂贵的运算。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Subscriber&lt;? super Integer&gt; observer) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">                    observer.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">                observer.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            observer.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; ).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Next: 4</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><p><code>create</code>方法默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe" target="_blank" rel="noopener"><code>create(OnSubscribe)</code></a>)</li></ul><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>直到有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/defer.c.png" alt="defer"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/defer.c.png" alt="img"></p><p><code>Defer</code>操作符会一直等待直到有观察者订阅它，然后它使用Observable工厂方法生成一个Observable。它对每个观察者都这样做，因此尽管每个订阅者都以为自己订阅的是同一个Observable，事实上每个订阅者获取的是它们自己的单独的数据序列。</p><p>在某些情况下，等待直到最后一分钟（就是知道订阅发生时）才生成Observable可以确保Observable包含最新的数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/defer.png" alt="defer"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/defer.png" alt="img"></p><p>RxJava将这个操作符实现为 <code>defer</code> 方法。这个操作符接受一个你选择的Observable工厂函数作为单个参数。这个函数没有参数，返回一个Observable。</p><p><code>defer</code>方法默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0" target="_blank" rel="noopener"><code>defer(Func0)</code></a>)</li></ul><h3 id="switchCase"><a href="#switchCase" class="headerlink" title="switchCase"></a>switchCase</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/switchCase.png" alt="switchCase"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/switchCase.png" alt="img"></p><p>可选包 <code>rxjava-computation-expressions</code> 中有一个类似的操作符。<code>switchCase</code>操作符有条件的创建并返回一个可能的Observables集合中的一个。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ifThen.png" alt="ifThen"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ifThen.png" alt="img"></p><p>可选包 <code>rxjava-computation-expressions</code> 中还有一个更简单的操作符叫<code>ifThen</code>。这个操作符检查某个条件，然后根据结果，返回原始Observable的镜像，或者返回一个空Observable。</p><h2 id="Empty-Never-Throw"><a href="#Empty-Never-Throw" class="headerlink" title="Empty/Never/Throw"></a>Empty/Never/Throw</h2><h3 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h3><p>创建一个不发射任何数据但是正常终止的Observable</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>创建一个不发射数据也不终止的Observable</p><h3 id="Throw"><a href="#Throw" class="headerlink" title="Throw"></a>Throw</h3><p>创建一个不发射数据以一个错误终止的Observable</p><p>这三个操作符生成的Observable行为非常特殊和受限。测试的时候很有用，有时候也用于结合其它的Observables，或者作为其它需要Observable的操作符的参数。</p><p>RxJava将这些操作符实现为 <code>empty</code>，<code>never</code>和<code>error</code>。<code>error</code>操作符需要一个<code>Throwable</code>参数，你的Observable会以此终止。这些操作符默认不在任何特定的调度器上执行，但是<code>empty</code>和<code>error</code>有一个可选参数是Scheduler，如果你传递了Scheduler参数，它们会在这个调度器上发送通知。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#empty(" target="_blank" rel="noopener">empty()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#never(" target="_blank" rel="noopener">never()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#error(java.lang.Throwable" target="_blank" rel="noopener">error(java.lang.Throwable)</a>)</li></ul><h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><p>将其它种类的对象和数据类型转换为Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/from.c.png" alt="from"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/from.c.png" alt="img"></p><p>当你使用Observable时，如果你要处理的数据都可以转换成展现为Observables，而不是需要混合使用Observables和其它类型的数据，会非常方便。这让你在数据流的整个生命周期中，可以使用一组统一的操作符来管理它们。</p><p>例如，Iterable可以看成是同步的Observable；Future，可以看成是总是只发射单个数据的Observable。通过显式地将那些数据转换为Observables，你可以像使用Observable一样与它们交互。</p><p>因此，大部分ReactiveX实现都提供了将语言特定的对象和数据结构转换为Observables的方法。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/from.png" alt="from"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/from.png" alt="img"></p><p>在RxJava中，<code>from</code>操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Integer[] items = &#123; 0, 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">Observable myObservable = Observable.from(items);</span><br><span class="line"></span><br><span class="line">myObservable.subscribe(</span><br><span class="line">    new Action1&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Integer item) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    new Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Throwable error) &#123;</span><br><span class="line">            System.out.println(&quot;Error encountered: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    new Action0() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Sequence complete</span><br></pre></td></tr></table></figure><p>对于Future，它会发射Future.get()方法返回的单个数据。<code>from</code>方法有一个可接受两个可选参数的版本，分别指定超时时长和时间单位。如果过了指定的时长Future还没有返回一个值，这个Observable会发射错误通知并终止。</p><p><code>from</code>默认不在任何特定的调度器上执行。然而你可以将Scheduler作为可选的第二个参数传递给Observable，它会在那个调度器上管理这个Future。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(T[]" target="_blank" rel="noopener">from(array)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.lang.Iterable" target="_blank" rel="noopener">from(Iterable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future" target="_blank" rel="noopener">from(Future)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future, rx.Scheduler" target="_blank" rel="noopener">from(Future,Scheduler)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">from(Future,timeout, timeUnit)</a>)</li></ul><h3 id="RxJavaAsyncUtil"><a href="#RxJavaAsyncUtil" class="headerlink" title="RxJavaAsyncUtil"></a>RxJavaAsyncUtil</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromFunc0.png" alt="from func)"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromFunc0.png" alt="img"></p><p>此外，在可选包 <code>RxJavaAsyncUtil</code> 中，你还可以用下面这些操作符将actions，callables，functions和runnables转换为发射这些动作的执行结果的Observable：</p><ul><li>fromAction</li><li>fromCallable</li><li>fromFunc0</li><li>fromRunnable</li></ul><p>在这个页面 <a href="http://reactivex.io/documentation/operators/start.html" target="_blank" rel="noopener">Start</a> 查看关于这些操作符的更多信息。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.from.png" alt="from"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.from.png" alt="img"></p><p>注意：还有一个可选的<code>StringObservable</code>类中也有一个<code>from</code>方法，它将一个字符流或者一个REader转换为一个发射字节数组或字符串的Observable。</p><h3 id="runAsync2"><a href="#runAsync2" class="headerlink" title="runAsync2"></a>runAsync2</h3><p>注意：这里与后面<code>start</code>操作符里的<code>runAsync</code>说明重复了</p><p>在单独的<code>RxJavaAsyncUtil</code>包中（默认不包含在RxJava中）,还有一个<code>runAsync</code>函数。传递一个<code>Action</code>和一个<code>Scheduler</code>给<code>runAsync</code>，它会返回一个<code>StoppableObservable</code>，这个Observable使用<code>Action</code>产生发射的数据项。</p><p>传递一个<code>Action</code>和一个<code>Scheduler</code>给<code>runAsync</code>，它返回一个使用这个<code>Action</code>产生数据的<code>StoppableObservable</code>。这个<code>Action</code>接受一个<code>Observable</code>和一个<code>Subscription</code>作为参数，它使用<code>Subscription</code>检查<code>unsubscribed</code>条件，一旦发现条件为真就立即停止发射数据。在任何时候你都可以使用<code>unsubscribe</code>方法手动停止一个<code>StoppableObservable</code>（这会同时取消订阅与这个<code>StoppableObservable</code>关联的<code>Subscription</code>）。</p><p>由于<code>runAsync</code>会立即调用<code>Action</code>并开始发射数据，在你创建StoppableObservable之后到你的观察者准备好接受数据之前这段时间里，可能会有一部分数据会丢失。如果这不符合你的要求，可以使用<code>runAsync</code>的一个变体，它也接受一个<code>Subject</code>参数，传递一个<code>ReplaySubject</code>给它，你可以获取其它丢失的数据了。</p><h3 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.decode.png" alt="decode"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.decode.png" alt="img"></p><p><code>StringObservable</code>类不是默认RxJava的一部分，包含一个<code>decode</code>操作符，这个操作符将一个多字节字符流转换为一个发射字节数组的Observable，这些字节数组按照字符的边界划分。</p><h2 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a>Interval</h2><p>创建一个按固定时间间隔发射整数序列的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.c.png" alt="interval"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.c.png" alt="img"></p><p><code>Interval</code>操作符返回一个Observable，它按固定的时间间隔发射一个无限递增的整数序列。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.png" alt="interval"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.png" alt="img"></p><p>RxJava将这个操作符实现为<code>interval</code>方法。它接受一个表示时间间隔的参数和一个表示时间单位的参数。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">interval(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long, java.util.concurrent.TimeUnit rx.Scheduler" target="_blank" rel="noopener">interval(long,TimeUnit,Scheduler)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timer.p.png" alt="timer"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timer.p.png" alt="img"></p><p>还有一个版本的<code>interval</code>返回一个Observable，它在指定延迟之后先发射一个零值，然后再按照指定的时间间隔发射递增的数字。这个版本的<code>interval</code>在RxJava 1.0.0中叫做<code>timer</code>，但是那个方法已经不建议使用了，因为一个名叫<code>interval</code>的操作符有同样的功能。</p><p>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">interval(long,long,TimeUnit)</a>) Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long, long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">interval(long,long,TimeUnit,Scheduler)</a>)</p><p><code>interval</code>默认在<code>computation</code>调度器上执行。你也可以传递一个可选的Scheduler参数来指定调度器。</p><h2 id="Just"><a href="#Just" class="headerlink" title="Just"></a>Just</h2><p>创建一个发射指定值的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/just.png" alt="just"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/just.png" alt="img"></p><p>Just将单个数据转换为发射那个数据的Observable。</p><p>Just类似于From，但是From会将数组或Iterable的数据取出然后逐个发射，而Just只是简单的原样发射，将数组或Iterable当做单个数据。</p><p>注意：如果你传递<code>null</code>给Just，它会返回一个发射<code>null</code>值的Observable。不要误认为它会返回一个空Observable（完全不发射任何数据的Observable），如果需要空Observable你应该使用<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Just.html#Empty" target="_blank" rel="noopener">Empty</a>操作符。</p><p>RxJava将这个操作符实现为<code>just</code>函数，它接受一至九个参数，返回一个按参数列表顺序发射这些数据的Observable。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">          .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#just(T" target="_blank" rel="noopener">just(item)</a>) (还有其它接受二到九个参数的版本)</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>创建一个发射特定整数序列的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/range.png" alt="range"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/range.png" alt="img"></p><p>Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。</p><p>RxJava将这个操作符实现为<code>range</code>函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。</p><p><code>range</code>默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#range(int, int" target="_blank" rel="noopener">range(int,int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#range(int, int rx.Scheduler" target="_blank" rel="noopener">range(int,int,Scheduler)</a>)</li></ul><h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h2><p>创建一个发射特定数据重复多次的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/repeat.c.png" alt="repeat"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/repeat.c.png" alt="img"></p><p>Repeat重复地发射数据。某些实现允许你重复的发射某个数据序列，还有一些允许你限制重复的次数。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/repeat.o.png" alt="repeat"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/repeat.o.png" alt="img"></p><p>RxJava将这个操作符实现为<code>repeat</code>方法。它不是创建一个Observable，而是重复发射原始Observable的数据序列，这个序列或者是无限的，或者通过<code>repeat(n)</code>指定重复次数。</p><p><code>repeat</code>操作符默认在<code>trampoline</code>调度器上执行。有一个变体可以通过可选参数指定Scheduler。</p><p>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(" target="_blank" rel="noopener">repeat()</a>) Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(long" target="_blank" rel="noopener">repeat(long)</a>) Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(rx.Scheduler" target="_blank" rel="noopener">repeat(Scheduler)</a>) Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeat(long, rx.Scheduler" target="_blank" rel="noopener">repeat(long,Scheduler)</a>)</p><h3 id="repeatWhen"><a href="#repeatWhen" class="headerlink" title="repeatWhen"></a>repeatWhen</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/repeatWhen.f.png" alt="repeatWhen"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/repeatWhen.f.png" alt="img"></p><p>还有一个叫做<code>repeatWhen</code>的操作符，它不是缓存和重放原始Observable的数据序列，而是有条件的重新订阅和发射原来的Observable。</p><p>将原始Observable的终止通知（完成或错误）当做一个<code>void</code>数据传递给一个通知处理器，它以此来决定是否要重新订阅和发射原来的Observable。这个通知处理器就像一个Observable操作符，接受一个发射<code>void</code>通知的Observable为输入，返回一个发射<code>void</code>数据（意思是，重新订阅和发射原始Observable）或者直接终止（意思是，使用<code>repeatWhen</code>终止发射数据）的Observable。</p><p><code>repeatWhen</code>操作符默认在<code>trampoline</code>调度器上执行。有一个变体可以通过可选参数指定Scheduler。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeatWhen(rx.functions.Func1" target="_blank" rel="noopener">repeatWhen(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#repeatWhen(rx.functions.Func1, rx.Scheduler" target="_blank" rel="noopener">repeatWhen(Func1,Scheduler)</a>)</li></ul><h3 id="doWhile"><a href="#doWhile" class="headerlink" title="doWhile"></a>doWhile</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doWhile.png" alt="doWhile"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doWhile.png" alt="img"></p><p><code>doWhile</code> 属于可选包<code>rxjava-computation-expressions</code>，不是RxJava标准操作符的一部分。<code>doWhile</code>在原始序列的每次重复后检查某个条件，如果满足条件才重复发射。</p><h3 id="whileDo"><a href="#whileDo" class="headerlink" title="whileDo"></a>whileDo</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/whileDo.png" alt="whileDo"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/whileDo.png" alt="img"></p><p><code>whileDo</code> 属于可选包<code>rxjava-computation-expressions</code>，不是RxJava标准操作符的一部分。<code>whileDo</code>在原始序列的每次重复前检查某个条件，如果满足条件才重复发射</p><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>返回一个Observable，它发射一个类似于函数声明的值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/start.png" alt="Start"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/start.png" alt="img"></p><p>编程语言有很多种方法可以从运算结果中获取值，它们的名字一般叫<code>functions, futures, actions, callables, runnables</code>等等。在<code>Start</code>目录下的这组操作符可以让它们表现得像Observable，因此它们可以在Observables调用链中与其它Observable搭配使用。</p><p><code>Start</code>操作符的多种RxJava实现都属于可选的<code>rxjava-async</code>模块。</p><p><code>rxjava-async</code>模块包含<code>start</code>操作符，它接受一个函数作为参数，调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable。</p><p>注意：这个函数只会被执行一次，即使多个观察者订阅这个返回的Observable。</p><h3 id="toAsync"><a href="#toAsync" class="headerlink" title="toAsync"></a>toAsync</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toAsync.png" alt="toAsync"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toAsync.png" alt="img"></p><p><code>rxjava-async</code>模块还包含这几个操作符：<code>toAsync</code>, <code>asyncAction</code>, 和<code>asyncFunc</code>。它们接受一个函数或一个Action作为参数。</p><p>对于函数(functions)，这个操作符调用这个函数获取一个值，然后返回一个会发射这个值给后续观察者的Observable（和<code>start</code>一样）。对于动作(Action)，过程类似，但是没有返回值，在这种情况下，这个操作符在终止前会发射一个<code>null</code>值。</p><p>注意：这个函数或动作只会被执行一次，即使多个观察者订阅这个返回的Observable。</p><h3 id="startFuture"><a href="#startFuture" class="headerlink" title="startFuture"></a>startFuture</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startFuture.png" alt="startFuture"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startFuture.png" alt="img"></p><p><code>rxjava-async</code>模块还包含一个<code>startFuture</code>操作符，传递给它一个返回<code>Future</code>的函数，<code>startFuture</code>会立即调用这个函数获取<code>Future</code>对象，然后调用<code>Future</code>的<code>get()</code>方法尝试获取它的值。它返回一个发射这个值给后续观察者的Observable。</p><h3 id="deferFuture"><a href="#deferFuture" class="headerlink" title="deferFuture"></a>deferFuture</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/deferFuture.png" alt="deferFuture"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/deferFuture.png" alt="img"></p><p><code>rxjava-async</code>模块还包含一个<code>deferFuture</code>操作符，传递给它一个返回<code>Future</code>的函数（这个<code>Future</code>返回一个<code>Observable</code>），<code>deferFuture</code>返回一个Observable，但是不会调用你提供的函数，直到有观察者订阅它返回的Observable。这时，它立即调用<code>Future</code>的<code>get()</code>方法，然后镜像发射<code>get()</code>方法返回的Observable发射的数据。</p><p>用这种方法，你可以在Observables调用链中包含一个返回Observable的<code>Future</code>对象。</p><h3 id="fromAction"><a href="#fromAction" class="headerlink" title="fromAction"></a>fromAction</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromCallable.png" alt="fromAction"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromCallable.png" alt="img"></p><p><code>rxjava-async</code>模块还包含一个<code>fromAction</code>操作符，它接受一个<code>Action</code>作为参数，返回一个Observable，一旦Action终止，它发射这个你传递给<code>fromAction</code>的数据。</p><h3 id="fromCallable"><a href="#fromCallable" class="headerlink" title="fromCallable"></a>fromCallable</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromCallable.png" alt="fromCallable"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromCallable.png" alt="img"></p><p><code>rxjava-async</code>模块还包含一个<code>fromCallable</code>操作符，它接受一个<code>Callable</code>作为参数，返回一个发射这个<code>Callable</code>的结果的Observable。</p><h3 id="fromRunnable"><a href="#fromRunnable" class="headerlink" title="fromRunnable"></a>fromRunnable</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromRunnable.png" alt="fromRunnable"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/fromRunnable.png" alt="img"></p><p><code>rxjava-async</code>模块还包含一个<code>fromRunnable</code>操作符，它接受一个<code>Runnable</code>作为参数，返回一个Observable，一旦Runnable终止，它发射这个你传递给<code>fromRunnable</code>的数据。</p><h3 id="forEachFuture"><a href="#forEachFuture" class="headerlink" title="forEachFuture"></a>forEachFuture</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/forEachFuture.png" alt="forEachFuture"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/forEachFuture.png" alt="img"></p><p><code>rxjava-async</code>模块还包含一个<code>forEachFuture</code>操作符。它其实不算<code>Start</code>操作符的一个变体，而是有一些自己的特点。你传递一些典型的观察者方法（如onNext, onError和onCompleted）给它，Observable会以通常的方式调用它。但是<code>forEachFuture</code>自己返回一个<code>Future</code>并且在<code>get()</code>方法处阻塞，直到原始Observable执行完成，然后它返回，完成还是错误依赖于原始Observable是完成还是错误。</p><p>如果你想要一个函数阻塞直到Observable执行完成，可以使用这个操作符。</p><h3 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h3><p><code>rxjava-async</code>模块还包含一个<code>runAsync</code>操作符。它很特殊，返回一个叫做<code>StoppableObservable</code>的特殊Observable。</p><p>传递一个<code>Action</code>和一个<code>Scheduler</code>给<code>runAsync</code>，它返回一个使用这个<code>Action</code>产生数据的<code>StoppableObservable</code>。这个<code>Action</code>接受一个<code>Observable</code>和一个<code>Subscription</code>作为参数，它使用<code>Subscription</code>检查<code>unsubscribed</code>条件，一旦发现条件为真就立即停止发射数据。在任何时候你都可以使用<code>unsubscribe</code>方法手动停止一个<code>StoppableObservable</code>（这会同时取消订阅与这个<code>StoppableObservable</code>关联的<code>Subscription</code>）。</p><p>由于<code>runAsync</code>会立即调用<code>Action</code>并开始发射数据，在你创建StoppableObservable之后到你的观察者准备好接受数据之前这段时间里，可能会有一部分数据会丢失。如果这不符合你的要求，可以使用<code>runAsync</code>的一个变体，它也接受一个<code>Subject</code>参数，传递一个<code>ReplaySubject</code>给它，你可以获取其它丢失的数据了。</p><p>在RxJava中还有一个版本的<code>From</code>操作符可以将Future转换为Observable，与<code>start</code>相似。</p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>创建一个Observable，它在一个给定的延迟后发射一个特殊的值。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timer.png" alt="timer"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timer.png" alt="img"></p><p><code>Timer</code>操作符创建一个在给定的时间段之后返回一个特殊值的Observable。</p><p>RxJava将这个操作符实现为<code>timer</code>函数。</p><p><code>timer</code>返回一个Observable，它在延迟一段给定的时间后发射一个简单的数字0。</p><p><code>timer</code>操作符默认在<code>computation</code>调度器上执行。有一个变体可以通过可选参数指定Scheduler。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timer(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">timer(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timer(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">timer(long,TimeUnit,Scheduler)</a>)</li></ul><h1 id="变换操作-1"><a href="#变换操作-1" class="headerlink" title="变换操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">变换操作</a></h1><p>这个页面展示了可用于对Observable发射的数据执行变换操作的各种操作符。</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html" target="_blank" rel="noopener"><strong>map( )</strong></a> — 对序列的每一项都应用一个函数来变换Observable发射的数据序列</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/FlatMap.html" target="_blank" rel="noopener"><strong>flatMap( ), concatMap( ), and flatMapIterable( )</strong></a> — 将Observable发射的数据集合变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/FlatMap.html" target="_blank" rel="noopener"><strong>switchMap( )</strong></a> — 将Observable发射的数据集合变换为Observables集合，然后只发射这些Observables最近发射的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Scan.html" target="_blank" rel="noopener"><strong>scan( )</strong></a> — 对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/GroupBy.html" target="_blank" rel="noopener"><strong>groupBy( )</strong></a> — 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Buffer.html" target="_blank" rel="noopener"><strong>buffer( )</strong></a> — 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Window.html" target="_blank" rel="noopener"><strong>window( )</strong></a> — 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html" target="_blank" rel="noopener"><strong>cast( )</strong></a> — 在发射之前强制将Observable发射的所有数据转换为指定类型</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>定期收集Observable的数据放进一个数据包裹，然后发射这些数据包裹，而不是一次发射一个值。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer.png" alt="buffer"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer.png" alt="img"></p><p><code>Buffer</code>操作符将一个Observable变换为另一个，原来的Observable正常发射数据，变换产生的Observable发射这些数据的缓存集合。<code>Buffer</code>操作符在很多语言特定的实现中有很多种变体，它们在如何缓存这个问题上存在区别。</p><p>注意：如果原来的Observable发射了一个<code>onError</code>通知，<code>Buffer</code>会立即传递这个通知，而不是首先发射缓存的数据，即使在这之前缓存中包含了原始Observable发射的数据。</p><p><code>Window</code>操作符与<code>Buffer</code>类似，但是它在发射之前把收集到的数据放进单独的Observable，而不是放进一个数据结构。</p><p>在RxJava中有许多<code>Buffer</code>的变体：</p><h3 id="buffer-count"><a href="#buffer-count" class="headerlink" title="buffer(count)"></a>buffer(count)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer3.png" alt="buffer3"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer3.png" alt="img"></p><p><code>buffer(count)</code>以列表(List)的形式发射非重叠的缓存，每一个缓存至多包含来自原始Observable的count项数据（最后发射的列表数据可能少于count项）</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int" target="_blank" rel="noopener">buffer(int)</a>)</li></ul><h3 id="buffer-count-skip"><a href="#buffer-count-skip" class="headerlink" title="buffer(count, skip)"></a>buffer(count, skip)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer4.png" alt="buffer4"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer4.png" alt="img"></p><p><code>buffer(count, skip)</code>从原始Observable的第一项数据开始创建新的缓存，此后每当收到<code>skip</code>项数据，用<code>count</code>项数据填充缓存：开头的一项和后续的<code>count-1</code>项，它以列表(List)的形式发射缓存，取决于<code>count</code>和<code>skip</code>的值，这些缓存可能会有重叠部分（比如skip &lt; count时），也可能会有间隙（比如skip &gt; count时）。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int, int" target="_blank" rel="noopener">buffer(int,int)</a>)</li></ul><h3 id="buffer-bufferClosingSelector"><a href="#buffer-bufferClosingSelector" class="headerlink" title="buffer(bufferClosingSelector)"></a>buffer(bufferClosingSelector)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer1.png" alt="buffer1"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer1.png" alt="img"></p><p>当它订阅原来的Observable时，<code>buffer(bufferClosingSelector)</code>开始将数据收集到一个<code>List</code>，然后它调用<code>bufferClosingSelector</code>生成第二个Observable，当第二个Observable发射一个<code>TClosing</code>时，<code>buffer</code>发射当前的<code>List</code>，然后重复这个过程：开始组装一个新的<code>List</code>，然后调用<code>bufferClosingSelector</code>创建一个新的Observable并监视它。它会一直这样做直到原来的Observable执行完成。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0" target="_blank" rel="noopener">buffer(Func0)</a>)</li></ul><h3 id="buffer-boundary"><a href="#buffer-boundary" class="headerlink" title="buffer(boundary)"></a>buffer(boundary)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer8.png" alt="buffer8"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer8.png" alt="img"></p><p><code>buffer(boundary)</code>监视一个名叫<code>boundary</code>的Observable，每当这个Observable发射了一个值，它就创建一个新的<code>List</code>开始收集来自原始Observable的数据并发射原来的<code>List</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable" target="_blank" rel="noopener">buffer(Observable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable, int" target="_blank" rel="noopener">buffer(Observable,int)</a>)</li></ul><h3 id="buffer-bufferOpenings-bufferClosingSelector"><a href="#buffer-bufferOpenings-bufferClosingSelector" class="headerlink" title="buffer(bufferOpenings, bufferClosingSelector)"></a>buffer(bufferOpenings, bufferClosingSelector)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer2.png" alt="buffer2"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer2.png" alt="img"></p><p><code>buffer(bufferOpenings, bufferClosingSelector)</code>监视这个叫<code>bufferOpenings</code>的Observable（它发射<code>BufferOpening</code>对象），每当<code>bufferOpenings</code>发射了一个数据时，它就创建一个新的<code>List</code>开始收集原始Observable的数据，并将<code>bufferOpenings</code>传递给<code>closingSelector</code>函数。这个函数返回一个Observable。<code>buffer</code>监视这个Observable，当它检测到一个来自这个Observable的数据时，就关闭<code>List</code>并且发射它自己的数据（之前的那个List）。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable, rx.functions.Func1" target="_blank" rel="noopener">buffer(Observable,Func1)</a>)</li></ul><h3 id="buffer-timespan-unit-scheduler"><a href="#buffer-timespan-unit-scheduler" class="headerlink" title="buffer(timespan, unit[, scheduler])"></a>buffer(timespan, unit[, scheduler])</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer5.png" alt="buffer5"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer5.png" alt="img"></p><p><code>buffer(timespan, unit)</code>定期以<code>List</code>的形式发射新的数据，每个时间段，收集来自原始Observable的数据（从前面一个数据包裹之后，或者如果是第一个数据包裹，从有观察者订阅原来的Observale之后开始）。还有另一个版本的<code>buffer</code>接受一个<code>Scheduler</code>参数，默认情况下会使用<code>computation</code>调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">buffer(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">buffer(long,TimeUnit,Scheduler)</a>)</li></ul><h3 id="buffer-timespan-unit-count-scheduler"><a href="#buffer-timespan-unit-count-scheduler" class="headerlink" title="buffer(timespan, unit, count[, scheduler])"></a>buffer(timespan, unit, count[, scheduler])</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer6.png" alt="buffer6"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer6.png" alt="img"></p><p>每当收到来自原始Observable的count项数据，或者每过了一段指定的时间后，<code>buffer(timespan, unit, count)</code>就以<code>List</code>的形式发射这期间的数据，即使数据项少于count项。还有另一个版本的<code>buffer</code>接受一个<code>Scheduler</code>参数，默认情况下会使用<code>computation</code>调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, int" target="_blank" rel="noopener">buffer(long,TimeUnit,int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, int, rx.Scheduler" target="_blank" rel="noopener">buffer(long,TimeUnit,int,Scheduler)</a>)</li></ul><h3 id="buffer-timespan-timeshift-unit-scheduler"><a href="#buffer-timespan-timeshift-unit-scheduler" class="headerlink" title="buffer(timespan, timeshift, unit[, scheduler])"></a>buffer(timespan, timeshift, unit[, scheduler])</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer7.png" alt="buffer7"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/buffer7.png" alt="img"></p><p><code>buffer(timespan, timeshift, unit)</code>在每一个<code>timeshift</code>时期内都创建一个新的<code>List</code>,然后用原始Observable发射的每一项数据填充这个列表（在把这个<code>List</code>当做自己的数据发射前，从创建时开始，直到过了<code>timespan</code>这么长的时间）。如果<code>timespan</code>长于<code>timeshift</code>，它发射的数据包将会重叠，因此可能包含重复的数据项。</p><p>还有另一个版本的<code>buffer</code>接受一个<code>Scheduler</code>参数，默认情况下会使用<code>computation</code>调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">buffer(long,long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long, long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">buffer(long,long,TimeUnit,Scheduler)</a>)</li></ul><h3 id="buffer-backpressure"><a href="#buffer-backpressure" class="headerlink" title="buffer-backpressure"></a>buffer-backpressure</h3><p>你可以使用<code>Buffer</code>操作符实现反压<code>backpressure</code>（意思是，处理这样一个Observable：它产生数据的速度可能比它的观察者消费数据的速度快）。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.buffer2.png" alt="bp.buffer2"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.buffer2.png" alt="img"></p><p>Buffer操作符可以将大量的数据序列缩减为较少的数据缓存序列，让它们更容易处理。例如，你可以按固定的时间间隔，定期关闭和发射来自一个爆发性Observable的数据缓存。这相当于一个缓冲区。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.buffer1.png" alt="bp.buffer1"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.buffer1.png" alt="img"></p><p>或者，如果你想更进一步，可以在爆发期将数据收集到缓存，然后在爆发期终止时发射这些数据，使用 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Filtering-Operators#Debounce" target="_blank" rel="noopener"><code>Debounce</code></a> 操作符给<code>buffer</code>操作符发射一个缓存关闭指示器(<code>buffer closing indicator</code>)可以做到这一点。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// we have to multicast the original bursty Observable so we can use it</span><br><span class="line">// both as our source and as the source for our buffer closing selector:</span><br><span class="line">Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();</span><br><span class="line">// burstyDebounced will be our buffer closing selector:</span><br><span class="line">Observable&lt;Integer&gt; burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);</span><br><span class="line">// and this, finally, is the Observable of buffers we&apos;re interested in:</span><br><span class="line">Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);</span><br></pre></td></tr></table></figure><h3 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h3><h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p><code>FlatMap</code>将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/flatMap.png" alt="flatMap"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/flatMap.png" alt="img"></p><p><code>FlatMap</code>操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后<code>FlatMap</code>合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。</p><p>这个方法是很有用的，例如，当你有一个这样的Observable：它发射一个数据序列，这些数据本身包含Observable成员或者可以变换为Observable，因此你可以创建一个新的Observable发射这些次级Observable发射的数据的完整集合。</p><p>注意：<code>FlatMap</code>对这些Observables发射的数据做的是合并(<code>merge</code>)操作，因此它们可能是交错的。</p><p>在许多语言特定的实现中，还有一个操作符不会让变换后的Observables发射的数据交错，它按照严格的顺序发射这些数据，这个操作符通常被叫作<code>ConcatMap</code>或者类似的名字。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMap.png" alt="mergeMap"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMap.png" alt="img"></p><p>RxJava将这个操作符实现为<code>flatMap</code>函数。</p><p>注意：如果任何一个通过这个<code>flatMap</code>操作产生的单独的Observable调用<code>onError</code>异常终止了，这个Observable自身会立即调用<code>onError</code>并终止。</p><p>这个操作符有一个接受额外的<code>int</code>参数的一个变体。这个参数设置<code>flatMap</code>从原来的Observable映射Observables的最大同时订阅数。当达到这个限制时，它会等待其中一个终止然后再订阅另一个。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1" target="_blank" rel="noopener">flatMap(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1, int" target="_blank" rel="noopener">flatMap(Func1,int)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMap.nce.png" alt="mergeMap.nce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMap.nce.png" alt="img"></p><p>还有一个版本的<code>flatMap</code>为原始Observable的每一项数据和每一个通知创建一个新的Observable（并对数据平坦化）。</p><p>它也有一个接受额外<code>int</code>参数的变体。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0" target="_blank" rel="noopener">flatMap(Func1,Func1,Func0)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0, int" target="_blank" rel="noopener">flatMap(Func1,Func1,Func0,int)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMap.r.png" alt="mergeMap.r"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMap.r.png" alt="img"></p><p>还有一个版本的<code>flatMap</code>会使用原始Observable的数据触发的Observable组合这些数据，然后发射这些数据组合。它也有一个接受额外<code>int</code>参数的版本。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1, rx.functions.Func2" target="_blank" rel="noopener">flatMap(Func1,Func2)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1, rx.functions.Func2, int" target="_blank" rel="noopener">flatMap(Func1,Func2,int)</a>)</li></ul><h3 id="flatMapIterable"><a href="#flatMapIterable" class="headerlink" title="flatMapIterable"></a>flatMapIterable</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMapIterable.png" alt="mergeMapIterable"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeMapIterable.png" alt="img"></p><p><code>flatMapIterable</code>这个变体成对的打包数据，然后生成Iterable而不是原始数据和生成的Observables，但是处理方式是相同的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1" target="_blank" rel="noopener">flatMapIterable(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#flatMapIterable(rx.functions.Func1, rx.functions.Func2" target="_blank" rel="noopener">flatMapIterable(Func1,Func2)</a>)</li></ul><h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/concatMap.png" alt="concatMap"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/concatMap.png" alt="img"></p><p>还有一个<code>concatMap</code>操作符，它类似于最简单版本的<code>flatMap</code>，但是它按次序连接而不是合并那些生成的Observables，然后产生自己的数据序列。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1" target="_blank" rel="noopener">concatMap(Func1)</a>)</li></ul><h3 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/switchMap.png" alt="switchMap"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/switchMap.png" alt="img"></p><p>RxJava还实现了<code>switchMap</code>操作符。它和<code>flatMap</code>很像，除了一点：当原始Observable发射一个新的数据（Observable）时，它将取消订阅并停止监视产生执之前那个数据的Observable，只监视当前这一个。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchMap(rx.functions.Func1" target="_blank" rel="noopener">switchMap(Func1)</a>)</li></ul><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.split.png" alt="St.split"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.split.png" alt="img"></p><p>在特殊的<code>StringObservable</code>类（默认没有包含在RxJava中）中还有一个<code>split</code>操作符。它将一个发射字符串的Observable转换为另一个发射字符串的Observable，只不过，后者将原始的数据序列当做一个数据流，使用一个正则表达式边界分割它们，然后合并发射分割的结果。</p><h2 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h2><p>将一个Observable分拆为一些Observables集合，它们中的每一个发射原始Observable的一个子序列</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/groupBy.c.png" alt="groupBy"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/groupBy.c.png" alt="img"></p><p><code>GroupBy</code>操作符将原始Observable分拆为一些Observables集合，它们中的每一个发射原始Observable数据序列的一个子序列。哪个数据项由哪一个Observable发射是由一个函数判定的，这个函数给每一项指定一个Key，Key相同的数据会被同一个Observable发射。</p><p>RxJava实现了<code>groupBy</code>操作符。它返回Observable的一个特殊子类<code>GroupedObservable</code>，实现了<code>GroupedObservable</code>接口的对象有一个额外的方法<code>getKey</code>，这个Key用于将数据分组到指定的Observable。</p><p>有一个版本的<code>groupBy</code>允许你传递一个变换函数，这样它可以在发射结果<code>GroupedObservable</code>之前改变数据项。</p><p>注意：<code>groupBy</code>将原始Observable分解为一个发射多个<code>GroupedObservable</code>的Observable，一旦有订阅，每个<code>GroupedObservable</code>就开始缓存数据。因此，如果你忽略这些<code>GroupedObservable</code>中的任何一个，这个缓存可能形成一个潜在的内存泄露。因此，如果你不想观察，也不要忽略<code>GroupedObservable</code>。你应该使用像<code>take(0)</code>这样会丢弃自己的缓存的操作符。</p><p>如果你取消订阅一个<code>GroupedObservable</code>，那个Observable将会终止。如果之后原始的Observable又发射了一个与这个Observable的Key匹配的数据，<code>groupBy</code>将会为这个Key创建一个新的<code>GroupedObservable</code>。</p><p><code>groupBy</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1" target="_blank" rel="noopener">groupBy(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1, rx.functions.Func1" target="_blank" rel="noopener">groupBy(Func1,Func1)</a>)</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>对Observable发射的每一项数据应用一个函数，执行变换操作</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/map.png" alt="map"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/map.png" alt="img"></p><p><code>Map</code>操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。</p><p>RxJava将这个操作符实现为<code>map</code>函数。这个操作符默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#map(rx.functions.Func1" target="_blank" rel="noopener">map(Func1)</a>)</li></ul><h3 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/cast.png" alt="cast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/cast.png" alt="img"></p><p><code>cast</code>操作符将原始Observable发射的每一项数据都强制转换为一个指定的类型，然后再发射数据，它是<code>map</code>的一个特殊版本。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class" target="_blank" rel="noopener">cast(Class)</a>)</li></ul><h3 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.encode.png" alt="encode"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.encode.png" alt="img"></p><p><code>encode</code>在<code>StringObservable</code>类中，不是标准RxJava的一部分，它也是一个特殊的<code>map</code>操作符。<code>encode</code>将一个发射字符串的Observable变换为一个发射字节数组（这个字节数组按照原始字符串中的多字节字符边界划分）的Observable。</p><h3 id="byLine"><a href="#byLine" class="headerlink" title="byLine"></a>byLine</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.byLine.png" alt="byLine"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.byLine.png" alt="img"></p><p><code>byLine</code>同样在<code>StringObservable</code>类中，也不是标准RxJava的一部分，它也是一个特殊的<code>map</code>操作符。<code>byLine</code>将一个发射字符串的Observable变换为一个按行发射来自原始Observable的字符串的Observable。</p><h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p>连续地对数据序列的每一项应用一个函数，然后连续发射结果</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.c.png" alt="scan"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.c.png" alt="img"></p><p><code>Scan</code>操作符对原始Observable发射的第一项数据应用一个函数，然后将那个函数的结果作为自己的第一项数据发射。它将函数的结果同第二项数据一起填充给这个函数来产生它自己的第二项数据。它持续进行这个过程来产生剩余的数据序列。这个操作符在某些情况下被叫做<code>accumulator</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.png" alt="scan"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.png" alt="img"></p><p>RxJava实现了<code>scan</code>操作符。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4, 5)</span><br><span class="line">    .scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call(Integer sum, Integer item) &#123;</span><br><span class="line">            return sum + item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 3</span><br><span class="line">Next: 6</span><br><span class="line">Next: 10</span><br><span class="line">Next: 15</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#scan(rx.functions.Func2" target="_blank" rel="noopener">scan(Func2)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scanSeed.png" alt="scanSeed"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scanSeed.png" alt="img"></p><p>有一个<code>scan</code>操作符的变体，你可以传递一个种子值给累加器函数的第一次调用（Observable发射的第一项数据）。如果你使用这个版本，<code>scan</code>将发射种子值作为自己的第一项数据。注意：传递<code>null</code>作为种子值与不传递是不同的，<code>null</code>种子值是合法的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#scan(R, rx.functions.Func2" target="_blank" rel="noopener">scan(R,Func2)</a>)</li></ul><p>这个操作符默认不在任何特定的调度器上执行。</p><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>定期将来自原始Observable的数据分解为一个Observable窗口，发射这些窗口，而不是每次发射一项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window.C.png" alt="window"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window.C.png" alt="img"></p><p><code>Window</code>和<code>Buffer</code>类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个<code>onCompleted</code>通知。</p><p>和<code>Buffer</code>一样，<code>Window</code>有很多变体，每一种都以自己的方式将原始Observable分解为多个作为结果的Observable，每一个都包含一个映射原始数据的<code>window</code>。用<code>Window</code>操作符的术语描述就是，当一个窗口打开(when a window “opens”)意味着一个新的Observable已经发射（产生）了，而且这个Observable开始发射来自原始Observable的数据；当一个窗口关闭(when a window “closes”)意味着发射(产生)的Observable停止发射原始Observable的数据，并且发射终止通知<code>onCompleted</code>给它的观察者们。</p><p>在RxJava中有许多种<code>Window</code>操作符的变体。</p><h3 id="window-closingSelector"><a href="#window-closingSelector" class="headerlink" title="window(closingSelector)"></a>window(closingSelector)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window1.png" alt="window1"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window1.png" alt="img"></p><p><code>window</code>的这个变体会立即打开它的第一个窗口。每当它观察到<code>closingSelector</code>返回的Observable发射了一个对象时，它就关闭当前打开的窗口并立即打开一个新窗口。用这个方法，这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据是一一对应的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0" target="_blank" rel="noopener">window(Func0)</a>)</li></ul><h3 id="window-windowOpenings-closingSelector"><a href="#window-windowOpenings-closingSelector" class="headerlink" title="window(windowOpenings, closingSelector)"></a>window(windowOpenings, closingSelector)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window2.png" alt="window2"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window2.png" alt="img"></p><p>无论何时，只要<code>window</code>观察到<code>windowOpenings</code>这个Observable发射了一个<code>Opening</code>对象，它就打开一个窗口，并且同时调用<code>closingSelector</code>生成一个与那个窗口关联的关闭(closing)Observable。当这个关闭(closing)Observable发射了一个对象时，<code>window</code>操作符就会关闭那个窗口。对这个变体来说，由于当前窗口的关闭和新窗口的打开是由单独的Observable管理的，它创建的窗口可能会存在重叠（重复某些来自原始Observable的数据）或间隙（丢弃某些来自原始Observable的数据）。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable, rx.functions.Func1" target="_blank" rel="noopener">window(Observable,Func1)</a>)</li></ul><h3 id="window-count"><a href="#window-count" class="headerlink" title="window(count)"></a>window(count)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window3.png" alt="window3"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window3.png" alt="img"></p><p>这个<code>window</code>的变体立即打开它的第一个窗口。每当当前窗口发射了<code>count</code>项数据，它就关闭当前窗口并打开一个新窗口。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据是一一对应的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int" target="_blank" rel="noopener">window(int)</a>)</li></ul><h3 id="window-count-skip"><a href="#window-count-skip" class="headerlink" title="window(count, skip)"></a>window(count, skip)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window4.png" alt="window4"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window4.png" alt="img"></p><p>这个<code>window</code>的变体立即打开它的第一个窗口。原始Observable每发射<code>skip</code>项数据它就打开一个新窗口（例如，如果<code>skip</code>等于3，每到第三项数据，它会打开一耳光新窗口）。每当当前窗口发射了<code>count</code>项数据，它就关闭当前窗口并打开一个新窗口。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。如果<code>skip=count</code>，它的行为与<code>window(source, count)</code>相同；如果<code>skip &lt; count</code>，窗口可会有<code>count - skip</code> 个重叠的数据；如果<code>skip &gt; count</code>，在两个窗口之间会有<code>skip - count</code>项数据被丢弃。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(int, int" target="_blank" rel="noopener">window(int,int)</a>)</li></ul><h3 id="window-timespan-unit-scheduler"><a href="#window-timespan-unit-scheduler" class="headerlink" title="window(timespan, unit[, scheduler])"></a>window(timespan, unit[, scheduler])</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window5.png" alt="window5"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window5.png" alt="img"></p><p>这个<code>window</code>的变体立即打开它的第一个窗口。每当过了<code>timespan</code>这么长的时间它就关闭当前窗口并打开一个新窗口（时间单位是<code>unit</code>，可选在调度器<code>scheduler</code>上执行）。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据也是一一对应的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">window(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">window(long,TimeUnit,Scheduler)</a>)</li></ul><h3 id="window-timespan-unit-count-scheduler"><a href="#window-timespan-unit-count-scheduler" class="headerlink" title="window(timespan, unit, count[, scheduler])"></a>window(timespan, unit, count[, scheduler])</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window6.png" alt="window6"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window6.png" alt="img"></p><p>这个<code>window</code>的变体立即打开它的第一个窗口。这个变体是<code>window(count)</code>和<code>window(timespan, unit[, scheduler])</code>的结合，每当过了<code>timespan</code>的时长或者当前窗口收到了<code>count</code>项数据，它就关闭当前窗口并打开另一个。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。这种<code>window</code>变体发射一系列不重叠的窗口，这些窗口的数据集合与原始Observable发射的数据也是一一对应的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit, int" target="_blank" rel="noopener">window(long,TimeUnit,int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit, int, rx.Scheduler" target="_blank" rel="noopener">window(long,TimeUnit,int,Scheduler)</a>)</li></ul><h3 id="window-timespan-timeshift-unit-scheduler"><a href="#window-timespan-timeshift-unit-scheduler" class="headerlink" title="window(timespan, timeshift, unit[, scheduler])"></a>window(timespan, timeshift, unit[, scheduler])</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window7.png" alt="window7"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/window7.png" alt="img"></p><p><code>buffer(timespan, timeshift, unit)</code>在每一个<code>timeshift</code>时期内都创建一个新的<code>List</code>,然后用原始Observable发射的每一项数据填充这个列表（在把这个<code>List</code>当做自己的数据发射前，从创建时开始，直到过了<code>timespan</code>这么长的时间）。如果<code>timespan</code>长于<code>timeshift</code>，它发射的数据包将会重叠，因此可能包含重复的数据项。</p><p>这个<code>window</code>的变体立即打开它的第一个窗口。随后每当过了<code>timeshift</code>的时长就打开一个新窗口（时间单位是<code>unit</code>，可选在调度器<code>scheduler</code>上执行），当窗口打开的时长达到<code>timespan</code>，它就关闭当前打开的窗口。如果从原始Observable收到了<code>onError</code>或<code>onCompleted</code>通知它也会关闭当前窗口。窗口的数据可能重叠也可能有间隙，取决于你设置的<code>timeshift</code>和<code>timespan</code>的值。</p><p>这个变体的<code>window</code>默认在<code>computation</code>调度器上执行它的定时器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">window(long,long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(long, long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">window(long,long,TimeUnit,Scheduler)</a>)</li></ul><h3 id="window-backpressure"><a href="#window-backpressure" class="headerlink" title="window-backpressure"></a>window-backpressure</h3><p>你可以使用<code>Window</code>操作符实现反压<code>backpressure</code>（意思是，处理这样一个Observable：它产生数据的数据可能比它的观察者消费数据的数据快）。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.window1.png" alt="bp.window1"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.window1.png" alt="img"></p><p>Window操作符可以将大量的数据序列缩减为较少的数据窗口序列，让它们更容易处理。例如，你可以按固定的时间间隔，定期关闭和发射来自一个爆发性Observable的数据窗口。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(500, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.window2.png" alt="bp.window2"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.window2.png" alt="img"></p><p>你还可以选择每当收到爆发性Observable的N项数据时发射一个新的数据窗口。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(5);</span><br></pre></td></tr></table></figure><h1 id="过滤操作-1"><a href="#过滤操作-1" class="headerlink" title="过滤操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">过滤操作</a></h1><p>这个页面展示的操作符可用于过滤和选择Observable发射的数据序列。</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Filter.html" target="_blank" rel="noopener"><strong>filter( )</strong></a> — 过滤数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/TakeLast.html" target="_blank" rel="noopener"><strong>takeLast( )</strong></a> — 只发射最后的N项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Last.html" target="_blank" rel="noopener"><strong>last( )</strong></a> — 只发射最后的一项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Last.html" target="_blank" rel="noopener"><strong>lastOrDefault( )</strong></a> — 只发射最后的一项数据，如果Observable为空就发射默认值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/TakeLast.html" target="_blank" rel="noopener"><strong>takeLastBuffer( )</strong></a> — 将最后的N项数据当做单个数据发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Skip.html" target="_blank" rel="noopener"><strong>skip( )</strong></a> — 跳过开始的N项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SkipLast.html" target="_blank" rel="noopener"><strong>skipLast( )</strong></a> — 跳过最后的N项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Take.html" target="_blank" rel="noopener"><strong>take( )</strong></a> — 只发射开始的N项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html" target="_blank" rel="noopener"><strong>first( ) and takeFirst( )</strong></a> — 只发射第一项数据，或者满足某种条件的第一项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html" target="_blank" rel="noopener"><strong>firstOrDefault( )</strong></a> — 只发射第一项数据，如果Observable为空就发射默认值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/ElementAt.html" target="_blank" rel="noopener"><strong>elementAt( )</strong></a> — 发射第N项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/ElementAt.html" target="_blank" rel="noopener"><strong>elementAtOrDefault( )</strong></a> — 发射第N项数据，如果Observable数据少于N项就发射默认值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Sample.html" target="_blank" rel="noopener"><strong>sample( ) or throttleLast( )</strong></a> — 定期发射Observable最近的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Sample.html" target="_blank" rel="noopener"><strong>throttleFirst( )</strong></a> — 定期发射Observable发射的第一项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Debounce.html" target="_blank" rel="noopener"><strong>throttleWithTimeout( ) or debounce( )</strong></a> — 只有当Observable在指定的时间后还没有发射数据时，才发射一个数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Timeout.html" target="_blank" rel="noopener"><strong>timeout( )</strong></a> — 如果在一个指定的时间段后还没发射数据，就发射一个异常</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Distinct.html" target="_blank" rel="noopener"><strong>distinct( )</strong></a> — 过滤掉重复数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Distinct.html" target="_blank" rel="noopener"><strong>distinctUntilChanged( )</strong></a> — 过滤掉连续重复的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Filter.html" target="_blank" rel="noopener"><strong>ofType( )</strong></a> — 只发射指定类型的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/IgnoreElements.html" target="_blank" rel="noopener"><strong>ignoreElements( )</strong></a> — 丢弃所有的正常数据，只发射错误或完成通知</li></ul><h2 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h2><p>仅在过了一段指定的时间还没发射数据时才发射一个数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.c.png" alt="debounce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.c.png" alt="img"></p><p><code>Debounce</code>操作符会过滤掉发射速率过快的数据项。</p><p>RxJava将这个操作符实现为<code>throttleWithTimeout</code>和<code>debounce</code>。</p><p>注意：这个操作符会会接着最后一项数据发射原始Observable的<code>onCompleted</code>通知，即使这个通知发生在你指定的时间窗口内（从最后一项数据的发射算起）。也就是说，<code>onCompleted</code>通知不会触发限流。</p><h3 id="throttleWithTimeout"><a href="#throttleWithTimeout" class="headerlink" title="throttleWithTimeout"></a>throttleWithTimeout</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.png" alt="debounce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.png" alt="img"></p><p><code>throtleWithTimeout/debounce</code>的一个变体根据你指定的时间间隔进行限流，时间单位通过<code>TimeUnit</code>参数指定。</p><p>这种操作符默认在<code>computation</code>调度器上执行，但是你可以通过第三个参数指定。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleWithTimeout(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">throttleWithTimeout(long,TimeUnit)</a>) and <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">debounce(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleWithTimeout(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">throttleWithTimeout(long,TimeUnit,Scheduler)</a>) and <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">debounce(long,TimeUnit,Scheduler)</a>)</li></ul><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.f.png" alt="debounce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.f.png" alt="img"></p><p><code>debounce</code>操作符的一个变体通过对原始Observable的每一项应用一个函数进行限流，这个函数返回一个Observable。如果原始Observable在这个新生成的Observable终止之前发射了另一个数据，<code>debounce</code>会抑制(suppress)这个数据项。</p><p><code>debounce</code>的这个变体默认不在任何特定的调度器上执行。</p><h2 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h2><p>抑制（过滤掉）重复的数据项</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.c.png" alt="distinct"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.c.png" alt="img"></p><p><code>Distinct</code>的过滤规则是：只允许还没有发射过的数据项通过。</p><p>在某些实现中，有一些变体允许你调整判定两个数据不同(<code>distinct</code>)的标准。还有一些实现只比较一项数据和它的直接前驱，因此只会从序列中过滤掉连续重复的数据。</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.png" alt="distinct"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.png" alt="img"></p><p>RxJava将这个操作符实现为<code>distinct</code>函数。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 1, 1, 2, 3)</span><br><span class="line">          .distinct()</span><br><span class="line">          .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct(" target="_blank" rel="noopener">distinct()</a>)</li></ul><h3 id="distinct-Func1"><a href="#distinct-Func1" class="headerlink" title="distinct(Func1)"></a>distinct(Func1)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.key.png" alt="distinct"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.key.png" alt="img"></p><p>这个操作符有一个变体接受一个函数。这个函数根据原始Observable发射的数据项产生一个Key，然后，比较这些Key而不是数据本身，来判定两个数据是否是不同的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinct(rx.functions.Func1" target="_blank" rel="noopener">distinct(Func1)</a>)</li></ul><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinctUntilChanged.png" alt="distinctUntilChanged"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinctUntilChanged.png" alt="img"></p><p>RxJava还是实现了一个<code>distinctUntilChanged</code>操作符。它只判定一个数据和它的直接前驱是否是不同的。</p><h3 id="distinctUntilChanged-Func1"><a href="#distinctUntilChanged-Func1" class="headerlink" title="distinctUntilChanged(Func1)"></a>distinctUntilChanged(Func1)</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinctUntilChanged.key.png" alt="distinctUntilChanged.key"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinctUntilChanged.key.png" alt="img"></p><p>和<code>distinct(Func1)</code>一样，根据一个函数产生的Key判定两个相邻的数据项是不是不同的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#distinctUntilChanged(rx.functions.Func1" target="_blank" rel="noopener">distinctUntilChanged(Func1)</a>)</li></ul><p><code>distinct</code>和<code>distinctUntilChanged</code>默认不在任何特定的调度器上执行。</p><h2 id="ElementAt"><a href="#ElementAt" class="headerlink" title="ElementAt"></a>ElementAt</h2><p>只发射第N项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.c.png" alt="elementAt"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.c.png" alt="img"></p><p><code>ElementAt</code>操作符获取原始Observable发射的数据序列指定索引位置的数据项，然后当做自己的唯一数据发射。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.png" alt="elementAt"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.png" alt="img"></p><p>RxJava将这个操作符实现为<code>elementAt</code>，给它传递一个基于0的索引值，它会发射原始Observable数据序列对应索引位置的值，如果你传递给<code>elementAt</code>的值为5，那么它会发射第六项的数据。</p><p>如果你传递的是一个负数，或者原始Observable的数据项数小于<code>index+1</code>，将会抛出一个<code>IndexOutOfBoundsException</code>异常。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#elementAt(int" target="_blank" rel="noopener">elementAt(int)</a>)</li></ul><h3 id="elementAtOrDefault"><a href="#elementAtOrDefault" class="headerlink" title="elementAtOrDefault"></a>elementAtOrDefault</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAtOrDefault.png" alt="elementAtOrDefault"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAtOrDefault.png" alt="img"></p><p>RxJava还实现了<code>elementAtOrDefault</code>操作符。与<code>elementAt</code>的区别是，如果索引值大于数据项数，它会发射一个默认值（通过额外的参数指定），而不是抛出异常。但是如果你传递一个负数索引值，它仍然会抛出一个<code>IndexOutOfBoundsException</code>异常。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#elementAtOrDefault(int, T" target="_blank" rel="noopener">elementAtOrDefault(int,T)</a>)</li></ul><p><code>elementAt</code>和<code>elementAtOrDefault</code>默认不在任何特定的调度器上执行。</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>只发射通过了谓词测试的数据项</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.c.png" alt="filter"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.c.png" alt="img"></p><p><code>Filter</code>操作符使用你指定的一个谓词函数测试数据项，只有通过测试的数据才会被发射。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.png" alt="filter"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.png" alt="img"></p><p>RxJava将这个操作符实现为<code>filter</code>函数。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4, 5)</span><br><span class="line">          .filter(new Func1&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public Boolean call(Integer item) &#123;</span><br><span class="line">                return( item &lt; 4 );</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><p><code>filter</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#filter(rx.functions.Func1" target="_blank" rel="noopener">filter(Func1)</a>)</li></ul><h3 id="ofType"><a href="#ofType" class="headerlink" title="ofType"></a>ofType</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ofClass.png" alt="ofType"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ofClass.png" alt="img"></p><p><code>ofType</code>是<code>filter</code>操作符的一个特殊形式。它过滤一个Observable只返回指定类型的数据。</p><p><code>ofType</code>默认不在任何特定的调度器上指定。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#ofType(java.lang.Class" target="_blank" rel="noopener">ofType(Class)</a>)</li></ul><h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>只发射第一项（或者满足某个条件的第一项）数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.c.png" alt="first"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.c.png" alt="img"></p><p>如果你只对Observable发射的第一项数据，或者满足某个条件的第一项数据感兴趣，你可以使用<code>First</code>操作符。</p><p>在某些实现中，<code>First</code>没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用<code>Take(1)</code>或者<code>ElementAt(0)</code>。</p><p>在一些实现中还有一个<code>Single</code>操作符。它的行为与<code>First</code>类似，但为了确保只发射单个值，它会等待原始Observable终止（否则，不是发射那个值，而是以一个错误通知终止）。你可以使用它从原始Observable获取第一项数据，而且也确保只发射一项数据。</p><p>在RxJava中，这个操作符被实现为<code>first</code>，<code>firstOrDefault</code>和<code>takeFirst</code>。</p><p>可能容易混淆，<code>BlockingObservable</code>也有名叫<code>first</code>和<code>firstOrDefault</code>的操作符，它们会阻塞并返回值，不是立即返回一个Observable。</p><p>还有几个其它的操作符执行类似的功能。</p><h2 id="IgnoreElements"><a href="#IgnoreElements" class="headerlink" title="IgnoreElements"></a>IgnoreElements</h2><p>不发射任何数据，只发射Observable的终止通知</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ignoreElements.c.png" alt="ignoreElements"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ignoreElements.c.png" alt="img"></p><p><code>IgnoreElements</code>操作符抑制原始Observable发射的所有数据，只允许它的终止通知（<code>onError</code>或<code>onCompleted</code>）通过。</p><p>如果你不关心一个Observable发射的数据，但是希望在它完成时或遇到错误终止时收到通知，你可以对Observable使用<code>ignoreElements</code>操作符，它会确保永远不会调用观察者的<code>onNext()</code>方法。</p><p>RxJava将这个操作符实现为<code>ignoreElements</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#ignoreElements(" target="_blank" rel="noopener">ignoreElements()</a>)</li></ul><p><code>ignoreElements</code>默认不在任何特定的调度器上执行。</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>只发射最后一项（或者满足某个条件的最后一项）数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.c.png" alt="last"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.c.png" alt="img"></p><p>如果你只对Observable发射的最后一项数据，或者满足某个条件的最后一项数据感兴趣，你可以使用<code>Last</code>操作符。</p><p>在某些实现中，<code>Last</code>没有实现为一个返回Observable的过滤操作符，而是实现为一个在当时就发射原始Observable指定数据项的阻塞函数。在这些实现中，如果你想要的是一个过滤操作符，最好使用<code>TakeLast(1)</code>。</p><p>在RxJava中的实现是<code>last</code>和<code>lastOrDefault</code>。</p><p>可能容易混淆，<code>BlockingObservable</code>也有名叫<code>last</code>和<code>lastOrDefault</code>的操作符，它们会阻塞并返回值，不是立即返回一个Observable。</p><h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.png" alt="last"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.png" alt="img"></p><p>只发射最后一项数据，使用没有参数的<code>last</code>操作符。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">          .last()</span><br><span class="line">          .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Next: 3</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#last(" target="_blank" rel="noopener">last()</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png" alt="last"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png" alt="img"></p><p>这个版本的<code>last</code>也是接受一个谓词函数，返回一个发射原始Observable中满足条件的最后一项数据的Observable。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#last(rx.functions.Func1" target="_blank" rel="noopener">last(Func1)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/lastOrDefault.png" alt="last"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/lastOrDefault.png" alt="img"></p><p><code>lastOrDefault</code>与<code>last</code>类似，不同的是，如果原始Observable没有发射任何值，它发射你指定的默认值。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#lastOrDefault(T" target="_blank" rel="noopener">lastOrDefault(T)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/lastOrDefault.p.png" alt="last"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/lastOrDefault.p.png" alt="img"></p><p>这个版本的<code>lastOrDefault</code>可以接受一个谓词函数，如果有数据满足条件，返回的Observable就发射原始Observable满足条件的最后一项数据，否则发射默认值。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#lastOrDefault(T" target="_blank" rel="noopener">lastOrDefault(T)</a>)</li></ul><p><code>last</code>和<code>lastOrDefault</code>默认不在任何特定的调度器上执行。</p><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p>定期发射Observable最近发射的数据项</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.c.png" alt="sample"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.c.png" alt="img"></p><p><code>Sample</code>操作符定时查看一个Observable，然后发射自上次采样以来它最近发射的数据。</p><p>在某些实现中，有一个<code>ThrottleFirst</code>操作符的功能类似，但不是发射采样期间的最近的数据，而是发射在那段时间内的第一项数据。</p><p>RxJava将这个操作符实现为<code>sample</code>和<code>throttleLast</code>。</p><p>注意：如果自上次采样以来，原始Observable没有发射任何数据，这个操作返回的Observable在那段时间内也不会发射任何数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.png" alt="sample"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.png" alt="img"></p><p><code>sample</code>(别名<code>throttleLast</code>)的一个变体按照你参数中指定的时间间隔定时采样（<code>TimeUnit</code>指定时间单位）。</p><p><code>sample</code>的这个变体默认在<code>computation</code>调度器上执行，但是你可以使用第三个参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">sample(long,TimeUnit)</a>)和<a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">throttleLast(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">sample(long,TimeUnit,Scheduler)</a>)和<a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleLast(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">throttleLast(long,TimeUnit,Scheduler)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.o.png" alt="sample"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.o.png" alt="img"></p><p><code>sample</code>的这个变体每当第二个Observable发射一个数据（或者当它终止）时就对原始Observable进行采样。第二个Observable通过参数传递给<code>sample</code>。</p><p><code>sample</code>的这个变体默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#sample(rx.Observable" target="_blank" rel="noopener">sample(Observable)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/throttleFirst.png" alt="throttleFirst"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/throttleFirst.png" alt="img"></p><p><code>throttleFirst</code>与<code>throttleLast/sample</code>不同，在每个采样周期内，它总是发射原始Observable的第一项数据，而不是最近的一项。</p><p><code>throttleFirst</code>操作符默认在<code>computation</code>调度器上执行，但是你可以使用第三个参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">throttleFirst(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#throttleFirst(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">throttleFirst(long,TimeUnit,Scheduler)</a>)</li></ul><h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h2><p>抑制Observable发射的前N项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.c.png" alt="skip"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.c.png" alt="img"></p><p>使用<code>Skip</code>操作符，你可以忽略Observable’发射的前N项数据，只保留之后的数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.png" alt="skip"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.png" alt="img"></p><p>RxJava中这个操作符叫<code>skip</code>。<code>skip</code>的这个变体默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(int" target="_blank" rel="noopener">skip(int)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.t.png" alt="skip"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.t.png" alt="img"></p><p><code>skip</code>的这个变体接受一个时长而不是数量参数。它会丢弃原始Observable开始的那段时间发射的数据，时长和时间单位通过参数指定。</p><p><code>skip</code>的这个变体默认在<code>computation</code>调度器上执行，但是你可以使用第三个参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">skip(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skip(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">skip(long,TimeUnit,Scheduler)</a>)</li></ul><h2 id="SkipLast"><a href="#SkipLast" class="headerlink" title="SkipLast"></a>SkipLast</h2><p>抑制Observable发射的后N项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.c.png" alt="skipLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.c.png" alt="img"></p><p>使用<code>SkipLast</code>操作符修改原始Observable，你可以忽略Observable’发射的后N项数据，只保留前面的数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.png" alt="skipLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.png" alt="img"></p><p>使用<code>SkipLast</code>操作符，你可以忽略原始Observable发射的后N项数据，只保留之前的数据。注意：这个机制是这样实现的：延迟原始Observable发射的任何数据项，直到它发射了N项数据。</p><p><code>skipLast</code>的这个变体默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(int" target="_blank" rel="noopener">skipLast(int)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.t.png" alt="skipLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.t.png" alt="img"></p><p>还有一个<code>skipLast</code>变体接受一个时长而不是数量参数。它会丢弃在原始Observable的生命周期内最后一段时间内发射的数据。时长和时间单位通过参数指定。</p><p>注意：这个机制是这样实现的：延迟原始Observable发射的任何数据项，直到自这次发射之后过了给定的时长。</p><p><code>skipLast</code>的这个变体默认在<code>computation</code>调度器上执行，但是你可以使用第三个参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">skipLast(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipLast(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">skipLast(long,TimeUnit,Scheduler)</a>)</li></ul><h2 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h2><p>只发射前面的N项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.c.png" alt="take"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.c.png" alt="img"></p><p>使用<code>Take</code>操作符让你可以修改Observable的行为，只返回前面的N项数据，然后发射完成通知，忽略剩余的数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.png" alt="take"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.png" alt="img"></p><p>RxJava将这个操作符实现为<code>take</code>函数。</p><p>如果你对一个Observable使用<code>take(n)</code>（或它的同义词<code>limit(n)</code>）操作符，而那个Observable发射的数据少于N项，那么<code>take</code>操作生成的Observable不会抛异常或发射<code>onError</code>通知，在完成前它只会发射相同的少量数据。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4, 5, 6, 7, 8)</span><br><span class="line">          .take(4)</span><br><span class="line">          .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 2</span><br><span class="line">Next: 3</span><br><span class="line">Next: 4</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><p><code>take(int)</code>默认不任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(int" target="_blank" rel="noopener">take(int)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.t.png" alt="take"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.t.png" alt="img"></p><p><code>take</code>的这个变体接受一个时长而不是数量参数。它会丢发射Observable开始的那段时间发射的数据，时长和时间单位通过参数指定。</p><p><code>take</code>的这个变体默认在<code>computation</code>调度器上执行，但是你可以使用第三个参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">take(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#take(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">take(long,TimeUnit,Scheduler)</a>)</li></ul><h2 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h2><p>发射Observable发射的最后N项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.c.png" alt="takeLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.c.png" alt="img"></p><p>使用<code>TakeLast</code>操作符修改原始Observable，你可以只发射Observable’发射的后N项数据，忽略前面的数据。</p><h3 id="taskLast-n"><a href="#taskLast-n" class="headerlink" title="taskLast.n"></a>taskLast.n</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.n.png" alt="takeLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.n.png" alt="img"></p><p>使用<code>takeLast</code>操作符，你可以只发射原始Observable发射的后N项数据，忽略之前的数据。注意：这会延迟原始Observable发射的任何数据项，直到它全部完成。</p><p><code>takeLast</code>的这个变体默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLast(int" target="_blank" rel="noopener">takeLast(int)</a>)</li></ul><h3 id="takeLast-t"><a href="#takeLast-t" class="headerlink" title="takeLast.t"></a>takeLast.t</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.t.png" alt="takeLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.t.png" alt="img"></p><p>还有一个<code>takeLast</code>变体接受一个时长而不是数量参数。它会发射在原始Observable的生命周期内最后一段时间内发射的数据。时长和时间单位通过参数指定。</p><p>注意：这会延迟原始Observable发射的任何数据项，直到它全部完成。</p><p><code>takeLast</code>的这个变体默认在<code>computation</code>调度器上执行，但是你可以使用第三个参数指定其它的调度器。</p><h3 id="takeLastBuffer"><a href="#takeLastBuffer" class="headerlink" title="takeLastBuffer"></a>takeLastBuffer</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLastBuffer.png" alt="takeLast"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLastBuffer.png" alt="img"></p><p>还有一个操作符叫<code>takeLastBuffer</code>，它和<code>takeLast</code>类似，，唯一的不同是它把所有的数据项收集到一个<code>List</code>再发射，而不是依次发射一个。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int" target="_blank" rel="noopener">takeLastBuffer(int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">takeLastBuffer(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">takeLastBuffer(long,TimeUnit,Scheduler)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">takeLastBuffer(int,long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeLastBuffer(int, long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">takeLastBuffer(int,long,TimeUnit,Scheduler)</a>)</li></ul><h1 id="结合操作"><a href="#结合操作" class="headerlink" title="结合操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">结合操作</a></h1><p>这个页面展示的操作符可用于组合多个Observables。</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/StartWith.html" target="_blank" rel="noopener"><strong>startWith( )</strong></a> — 在数据序列的开头增加一项数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Merge.html" target="_blank" rel="noopener"><strong>merge( )</strong></a> — 将多个Observable合并为一个</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Merge.html" target="_blank" rel="noopener"><strong>mergeDelayError( )</strong></a> — 合并多个Observables，让没有错误的Observable都完成后再发射错误通知</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Zip.html" target="_blank" rel="noopener"><strong>zip( )</strong></a> — 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/And.html" target="_blank" rel="noopener"><strong>and( ), then( ), and when( )</strong></a> — (<code>rxjava-joins</code>) 通过模式和计划组合多个Observables发射的数据集合</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/CombineLatest.html" target="_blank" rel="noopener"><strong>combineLatest( )</strong></a> — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Join.html" target="_blank" rel="noopener"><strong>join( ) and groupJoin( )</strong></a> — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Switch.html" target="_blank" rel="noopener"><strong>switchOnNext( )</strong></a> — 将一个发射Observables的Observable转换成另一个Observable，后者发射这些Observables最近发射的数据</li></ul><blockquote><p>(<code>rxjava-joins</code>) — 表示这个操作符当前是可选的<code>rxjava-joins</code>包的一部分，还没有包含在标准的RxJava操作符集合里</p></blockquote><h2 id="And-Then-When"><a href="#And-Then-When" class="headerlink" title="And/Then/When"></a>And/Then/When</h2><p>使用Pattern和Plan作为中介，将两个或多个Observable发射的数据集合并到一起</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/and_then_when.C.png" alt="and/then/when"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/and_then_when.C.png" alt="img"></p><p>And/Then/When操作符组合的行为类似于<code>zip</code>，但是它们使用一个中间数据结构。接受两个或多个Observable，一次一个将它们的发射物合并到<code>Pattern</code>对象，然后操作那个<code>Pattern</code>对象，变换为一个<code>Plan</code>。随后将这些<code>Plan</code>变换为Observable的发射物。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/and_then_when.png" alt="and/then/when"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/and_then_when.png" alt="img"></p><p>它们属于<code>rxjava-joins</code>模块，不是核心RxJava包的一部分</p><h2 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h2><p>当两个Observables中的任何一个发射了数据时，使用一个函数结合每个Observable发射的最近数据项，并且基于这个函数的结果发射数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.c.png" alt="combineLatest"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.c.png" alt="img"></p><p><code>CombineLatest</code>操作符行为类似于<code>zip</code>，但是只有当原始的Observable中的每一个都发射了一条数据时<code>zip</code>才发射数据。<code>CombineLatest</code>则在原始的Observable中任意一个发射了数据时发射一条数据。当原始Observables的任何一个发射了一条数据时，<code>CombineLatest</code>使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.png" alt="combineLatest"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.png" alt="img"></p><p>RxJava将这个操作符实现为<code>combineLatest</code>，它接受二到九个Observable作为参数，或者单个Observables列表作为参数。它默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List, rx.functions.FuncN" target="_blank" rel="noopener">combineLatest(List,FuncN)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable, rx.Observable, rx.functions.Func2" target="_blank" rel="noopener">combineLatest(Observable,Observable,Func2)</a>)</li></ul><h3 id="withLatestFrom"><a href="#withLatestFrom" class="headerlink" title="withLatestFrom"></a>withLatestFrom</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/withLatestFrom.png" alt="withLatestFrom"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/withLatestFrom.png" alt="img"></p><p><code>withLatestFrom</code>操作符还在开发中，不是1.0版本的一部分。类似于<code>combineLatest</code>，但是只在单个原始Observable发射了一条数据时才发射数据。</p><h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>任何时候，只要在另一个Observable发射的数据定义的时间窗口内，这个Observable发射了一条数据，就结合两个Observable发射的数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png" alt="join"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png" alt="img"></p><p><code>Join</code>操作符结合两个Observable发射的数据，基于时间窗口（你定义的针对每条数据特定的原则）选择待集合的数据项。你将这些时间窗口实现为一些Observables，它们的生命周期从任何一条Observable发射的每一条数据开始。当这个定义时间窗口的Observable发射了一条数据或者完成时，与这条数据关联的窗口也会关闭。只要这条数据的窗口是打开的，它将继续结合其它Observable发射的任何数据项。你定义一个用于结合数据的函数。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/groupJoin.c.png" alt="groupJoin"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/groupJoin.c.png" alt="img"></p><p>很多ReactiveX实现还有一个类似的<code>GroupJoin</code>操作符。</p><p>Most ReactiveX implementations that have a Join operator also have a GroupJoin operator that is similar, except that the function you define to combine items emitted by the two Observables pairs individual items emitted by the source Observable not with an item from the second Observable, but with an Observable that emits items from the second Observable that fall in the same window.</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join_.png" alt="join"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join_.png" alt="img"></p><p>The <code>join</code> operator takes four parameters:</p><ol><li>the second Observable to combine with the source Observable</li><li>a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable</li><li>a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable</li><li>a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from join</li></ol><p><code>join</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#join(rx.Observable, rx.functions.Func1, rx.functions.Func1, rx.functions.Func2" target="_blank" rel="noopener">Join(Observable,Func1,Func1,Func2)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/groupJoin.png" alt="groupJoin"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/groupJoin.png" alt="img"></p><p>The <code>groupJoin</code> operator takes four parameters:</p><ol><li>the second Observable to combine with the source Observable</li><li>a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable</li><li>a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable</li><li>a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from groupJoin</li></ol><p><code>groupJoin</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#groupJoin(rx.Observable, rx.functions.Func1, rx.functions.Func1, rx.functions.Func2" target="_blank" rel="noopener">groupJoin(Observable,Func1,Func1,Func2)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.join.png" alt="st.join"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.join.png" alt="img"></p><p>可选的<code>StringObservable</code>类中也有一个<code>join</code>操作符。它将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，<code>join</code>操作符使用指定的定界符将全部单独的字符串连接起来。</p><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>合并多个Observables的发射物</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/merge.c.png" alt="merge"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/merge.c.png" alt="img"></p><p>使用<code>Merge</code>操作符你可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。</p><p><code>Merge</code>可能会让合并的Observables发射的数据交错（有一个类似的操作符<code>Concat</code>不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。</p><p>正如图例上展示的，任何一个原始Observable的<code>onError</code>通知会被立即传递给观察者，而且会终止合并后的Observable。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeDelayError.C.png" alt="mergeDelayError"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeDelayError.C.png" alt="img"></p><p>在很多ReactiveX实现中还有一个叫<code>MergeDelayError</code>的操作符，它的行为有一点不同，它会保留<code>onError</code>通知直到合并后的Observable所有的数据发射完成，在那时它才会把<code>onError</code>传递给观察者。</p><p>RxJava将它实现为<code>merge</code>, <code>mergeWith</code>和<code>mergeDelayError</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/merge.png" alt="merge"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/merge.png" alt="img"></p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Integer&gt; odds = Observable.just(1, 3, 5).subscribeOn(someScheduler);</span><br><span class="line">Observable&lt;Integer&gt; evens = Observable.just(2, 4, 6);</span><br><span class="line"></span><br><span class="line">Observable.merge(odds, evens)</span><br><span class="line">          .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Next: 3</span><br><span class="line">Next: 5</span><br><span class="line">Next: 2</span><br><span class="line">Next: 4</span><br><span class="line">Next: 6</span><br><span class="line">Sequence complete.</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable" target="_blank" rel="noopener">merge(Iterable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(java.lang.Iterable, int" target="_blank" rel="noopener">merge(Iterable,int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable[]" target="_blank" rel="noopener">merge(Observable[])</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable, rx.Observable" target="_blank" rel="noopener">merge(Observable,Observable)</a>) (接受二到九个Observable)</li></ul><p>除了传递多个Observable给<code>merge</code>，你还可以传递一个Observable列表<code>List</code>，数组，甚至是一个发射Observable序列的Observable，<code>merge</code>将合并它们的输出作为单个Observable的输出：</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/merge.io.png" alt="merge"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/merge.io.png" alt="img"></p><p>如果你传递一个发射Observables序列的Observable，你可以指定<code>merge</code>应该同时订阅的Observable’的最大数量。一旦达到订阅数的限制，它将不再订阅原始Observable发射的任何其它Observable，直到某个已经订阅的Observable发射了<code>onCompleted</code>通知。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable" target="_blank" rel="noopener">merge(Observable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#merge(rx.Observable, int" target="_blank" rel="noopener">merge(Observable,int)</a>)</li></ul><p><code>merge</code>是静态方法，<code>mergeWith</code>是对象方法，举个例子，<code>Observable.merge(odds,evens)</code>等价于<code>odds.mergeWith(evens)</code>。</p><p>如果传递给<code>merge</code>的任何一个的Observable发射了<code>onError</code>通知终止了，<code>merge</code>操作符生成的Observable也会立即以<code>onError</code>通知终止。如果你想让它继续发射数据，在最后才报告错误，可以使用<code>mergeDelayError</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeDelayError.png" alt="merge"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/mergeDelayError.png" alt="img"></p><p><code>mergeDelayError</code> behaves much like <code>merge</code>. The exception is when one of the Observables being merged terminates with an onError notification. If this happens with merge, the merged Observable will immediately issue an <code>onError</code> notification and terminate. <code>mergeDelayError</code>, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an <code>onError</code>notification when all of the other merged Observables have finished.</p><p>Because it is possible that more than one of the merged Observables encountered an error, <code>mergeDelayError</code> may pass information about multiple errors in the onError notification (it will never invoke the observer’s <code>onError</code> method more than once). For this reason, if you want to know the nature of these errors, you should write your observers’ onError methods so that they accept a parameter of the class <code>CompositeException</code>.</p><p><code>mergeDelayError</code> has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of <code>mergeDelayError</code> as there is for <code>merge</code>.</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeDelayError(rx.Observable" target="_blank" rel="noopener">mergeDelayError(Observable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#mergeDelayError(rx.Observable, rx.Observable" target="_blank" rel="noopener">mergeDelayError(Observable,Observable)</a>)</li></ul><h2 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h2><p>在数据序列的开头插入一条指定的项</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startWith.c.png" alt="startWith"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startWith.c.png" alt="img"></p><p>如果你想要一个Observable在发射数据之前先发射一个指定的数据序列，可以使用<code>StartWith</code>操作符。（如果你想一个Observable发射的数据末尾追加一个数据序列可以使用<code>Concat</code>操作符。）</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startWith.png" alt="startWith"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startWith.png" alt="img"></p><p>可接受一个Iterable或者多个Observable作为函数的参数。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(java.lang.Iterable" target="_blank" rel="noopener">startWith(Iterable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(T" target="_blank" rel="noopener">startWith(T)</a>) (最多接受九个参数)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startWith.o.png" alt="startWith"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/startWith.o.png" alt="img"></p><p>你也可以传递一个Observable给<code>startWith</code>，它会将那个Observable的发射物插在原始Observable发射的数据序列之前，然后把这个当做自己的发射物集合。这可以看作是<code>Concat</code>的反转。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#startWith(rx.Observable" target="_blank" rel="noopener">startWith(Observable)</a>)</li></ul><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>将一个发射多个Observables的Observable转换成另一个单独的Observable，后者发射那些Observables最近发射的数据项</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/switch.c.png" alt="switch"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/switch.c.png" alt="img"></p><p><code>Switch</code>订阅一个发射多个Observables的Observable。它每次观察那些Observables中的一个，<code>Switch</code>返回的这个Observable取消订阅前一个发射数据的Observable，开始发射最近的Observable发射的数据。注意：当原始Observable发射了一个新的Observable时（不是这个新的Observable发射了一条数据时），它将取消订阅之前的那个Observable。这意味着，在后来那个Observable产生之后到它开始发射数据之前的这段时间里，前一个Observable发射的数据将被丢弃（就像图例上的那个黄色圆圈一样）。</p><p>Java将这个操作符实现为<code>switchOnNext</code>。它默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#switchOnNext(rx.Observable" target="_blank" rel="noopener">switchOnNext(Observable)</a>)</li></ul><h2 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h2><p>通过一个函数将多个Observables的发射物结合到一起，基于这个函数的结果为每个结合体发射单个数据项。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/zip.c.png" alt="zip"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/zip.c.png" alt="img"></p><p><code>Zip</code>操作符返回一个Obversable，它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。</p><p>RxJava将这个操作符实现为<code>zip</code>和<code>zipWith</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/zip.o.png" alt="zip"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/zip.o.png" alt="img"></p><p><code>zip</code>的最后一个参数接受每个Observable发射的一项数据，返回被压缩后的数据，它可以接受一到九个参数：一个Observable序列，或者一些发射Observable的Observables。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(java.lang.Iterable, rx.functions.FuncN" target="_blank" rel="noopener">zip(Iterable,FuncN)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(rx.Observable, rx.functions.FuncN" target="_blank" rel="noopener">zip(Observable,FuncN)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#zip(rx.Observable, rx.Observable, rx.functions.Func2" target="_blank" rel="noopener">zip(Observable,Observable,Func2)</a>) (最多可以有九个Observables参数)</li></ul><h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/zip.i.png" alt="zip"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/zip.i.png" alt="img"></p><p><code>zipWith</code>操作符总是接受两个参数，第一个参数是一个Observable或者一个Iterable。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#zipWith(rx.Observable, rx.functions.Func2" target="_blank" rel="noopener">zipWith(Observable,Func2)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#zipWith(java.lang.Iterable, rx.functions.Func2" target="_blank" rel="noopener">zipWith(Iterable,Func2)</a>)</li></ul><p><code>zip</code>和<code>zipWith</code>默认不在任何特定的操作符上执行。</p><h1 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">错误处理</a></h1><p>很多操作符可用于对Observable发射的<code>onError</code>通知做出响应或者从错误中恢复，例如，你可以：</p><ol><li>吞掉这个错误，切换到一个备用的Observable继续发射数据</li><li>吞掉这个错误然后发射默认值</li><li>吞掉这个错误并立即尝试重启这个Observable</li><li>吞掉这个错误，在一些回退间隔后重启这个Observable</li></ol><p>这是操作符列表：</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html#onErrorResumeNext" target="_blank" rel="noopener"><strong>onErrorResumeNext( )</strong></a> — 指示Observable在遇到错误时发射一个数据序列</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html#onErrorReturn" target="_blank" rel="noopener"><strong>onErrorReturn( )</strong></a> — 指示Observable在遇到错误时发射一个特定的数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html#onExceptionResumeNext" target="_blank" rel="noopener"><strong>onExceptionResumeNext( )</strong></a> — instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)指示Observable遇到错误时继续发射数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Retry.html#retry" target="_blank" rel="noopener"><strong>retry( )</strong></a> — 指示Observable遇到错误时重试</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Retry.html#retryWhen" target="_blank" rel="noopener"><strong>retryWhen( )</strong></a> — 指示Observable遇到错误时，将错误传递给另一个Observable来决定是否要重新给订阅这个Observable</li></ul><h2 id="Catch"><a href="#Catch" class="headerlink" title="Catch"></a>Catch</h2><p>从<code>onError</code>通知中恢复发射数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/catch.png" alt="catch"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/catch.png" alt="img"></p><p><code>Catch</code>操作符拦截原始Observable的<code>onError</code>通知，将它替换为其它的数据项或数据序列，让产生的Observable能够正常终止或者根本不终止。</p><p>在某些ReactiveX的实现中，有一个叫<code>onErrorResumeNext</code>的操作符，它的行为与<code>Catch</code>相似。</p><p>RxJava将<code>Catch</code>实现为三个不同的操作符：</p><p><strong>onErrorReturn</strong></p><p>让Observable遇到错误时发射一个特殊的项并且正常终止。</p><p><strong>onErrorResumeNext</strong></p><p>让Observable在遇到错误时开始发射第二个Observable的数据序列。</p><p><strong>onExceptionResumeNext</strong></p><p>让Observable在遇到错误时继续发射后面的数据项。</p><h3 id="onErrorReturn"><a href="#onErrorReturn" class="headerlink" title="onErrorReturn"></a>onErrorReturn</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorReturn.png" alt="onErrorReturn"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorReturn.png" alt="img"></p><p><code>onErrorReturn</code>方法返回一个镜像原有Observable行为的新Observable，后者会忽略前者的<code>onError</code>调用，不会将错误传递给观察者，作为替代，它会发发射一个特殊的项并调用观察者的<code>onCompleted</code>方法。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorReturn(rx.functions.Func1" target="_blank" rel="noopener">onErrorReturn(Func1)</a>)</li></ul><h3 id="onErrorResumeNext"><a href="#onErrorResumeNext" class="headerlink" title="onErrorResumeNext"></a>onErrorResumeNext</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorResumeNext.png" alt="onErrorResumeNext"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorResumeNext.png" alt="img"></p><p><code>onErrorResumeNext</code>方法返回一个镜像原有Observable行为的新Observable，后者会忽略前者的<code>onError</code>调用，不会将错误传递给观察者，作为替代，它会开始镜像另一个，备用的Observable。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.functions.Func1" target="_blank" rel="noopener">onErrorResumeNext(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext(rx.Observable" target="_blank" rel="noopener">onErrorResumeNext(Observable)</a>)</li></ul><h3 id="onExceptionResumeNext"><a href="#onExceptionResumeNext" class="headerlink" title="onExceptionResumeNext"></a>onExceptionResumeNext</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onExceptionResumeNextViaObservable.png" alt="onExceptionResumeNext"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onExceptionResumeNextViaObservable.png" alt="img"></p><p>和<code>onErrorResumeNext</code>类似，<code>onExceptionResumeNext</code>方法返回一个镜像原有Observable行为的新Observable，也使用一个备用的Observable，不同的是，如果<code>onError</code>收到的<code>Throwable</code>不是一个<code>Exception</code>，它会将错误传递给观察者的<code>onError</code>方法，不会使用备用的Observable。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#onExceptionResumeNext(rx.Observable" target="_blank" rel="noopener">onExceptionResumeNext(Observable)</a>)</li></ul><h2 id="Retry"><a href="#Retry" class="headerlink" title="Retry"></a>Retry</h2><p>如果原始Observable遇到错误，重新订阅它期望它能正常终止</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retry.C.png" alt="retry"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retry.C.png" alt="img"></p><p><code>Retry</code>操作符不会将原始Observable的<code>onError</code>通知传递给观察者，它会订阅这个Observable，再给它一次机会无错误地完成它的数据序列。<code>Retry</code>总是传递<code>onNext</code>通知给观察者，由于重新订阅，可能会造成数据项重复，如上图所示。</p><p>RxJava中的实现为<code>retry</code>和<code>retryWhen</code>。</p><p>无论收到多少次<code>onError</code>通知，无参数版本的<code>retry</code>都会继续订阅并发射原始Observable。</p><p>接受单个<code>count</code>参数的<code>retry</code>会最多重新订阅指定的次数，如果次数超了，它不会尝试再次订阅，它会把最新的一个<code>onError</code>通知传递给它的观察者。</p><p>还有一个版本的<code>retry</code>接受一个谓词函数作为参数，这个函数的两个参数是：重试次数和导致发射<code>onError</code>通知的<code>Throwable</code>。这个函数返回一个布尔值，如果返回<code>true</code>，<code>retry</code>应该再次订阅和镜像原始的Observable，如果返回<code>false</code>，<code>retry</code>会将最新的一个<code>onError</code>通知传递给它的观察者。</p><p><code>retry</code>操作符默认在<code>trampoline</code>调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(" target="_blank" rel="noopener">retry()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(long" target="_blank" rel="noopener">retry(long)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#retry(rx.functions.Func2" target="_blank" rel="noopener">retry(Func2)</a>)</li></ul><h3 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen"></a>retryWhen</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retryWhen.f.png" alt="retryWhen"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retryWhen.f.png" alt="img"></p><p><code>retryWhen</code>和<code>retry</code>类似，区别是，<code>retryWhen</code>将<code>onError</code>中的<code>Throwable</code>传递给一个函数，这个函数产生另一个Observable，<code>retryWhen</code>观察它的结果再决定是不是要重新订阅原始的Observable。如果这个Observable发射了一项数据，它就重新订阅，如果这个Observable发射的是<code>onError</code>通知，它就将这个通知传递给观察者然后终止。</p><p><code>retryWhen</code>默认在<code>trampoline</code>调度器上执行，你可以通过参数指定其它的调度器。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.create((Subscriber&lt;? super String&gt; s) -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;subscribing&quot;);</span><br><span class="line">      s.onError(new RuntimeException(&quot;always fails&quot;));</span><br><span class="line">  &#125;).retryWhen(attempts -&gt; &#123;</span><br><span class="line">      return attempts.zipWith(Observable.range(1, 3), (n, i) -&gt; i).flatMap(i -&gt; &#123;</span><br><span class="line">          System.out.println(&quot;delay retry by &quot; + i + &quot; second(s)&quot;);</span><br><span class="line">          return Observable.timer(i, TimeUnit.SECONDS);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;).toBlocking().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subscribing</span><br><span class="line">delay retry by 1 second(s)</span><br><span class="line">subscribing</span><br><span class="line">delay retry by 2 second(s)</span><br><span class="line">subscribing</span><br><span class="line">delay retry by 3 second(s)</span><br><span class="line">subscribing</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#retryWhen(rx.functions.Func1" target="_blank" rel="noopener">retryWhen(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#retryWhen(rx.functions.Func1, rx.Scheduler" target="_blank" rel="noopener">retryWhen(Func1,Scheduler)</a>)</li></ul><h1 id="辅助操作-1"><a href="#辅助操作-1" class="headerlink" title="辅助操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">辅助操作</a></h1><p>这个页面列出了很多用于Observable的辅助操作符</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Materialize.html" target="_blank" rel="noopener"><strong>materialize( )</strong></a> — 将Observable转换成一个通知列表convert an Observable into a list of Notifications</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Materialize.html" target="_blank" rel="noopener"><strong>dematerialize( )</strong></a> — 将上面的结果逆转回一个Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Timestamp.html" target="_blank" rel="noopener"><strong>timestamp( )</strong></a> — 给Observable发射的每个数据项添加一个时间戳</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Serialize.html" target="_blank" rel="noopener"><strong>serialize( )</strong></a> — 强制Observable按次序发射数据并且要求功能是完好的</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Replay.html" target="_blank" rel="noopener"><strong>cache( )</strong></a> — 记住Observable发射的数据序列并发射相同的数据序列给后续的订阅者</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/ObserveOn.html" target="_blank" rel="noopener"><strong>observeOn( )</strong></a> — 指定观察者观察Observable的调度器</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SubscribeOn.html" target="_blank" rel="noopener"><strong>subscribeOn( )</strong></a> — 指定Observable执行任务的调度器</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>doOnEach( )</strong></a> — 注册一个动作，对Observable发射的每个数据项使用</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>doOnCompleted( )</strong></a> — 注册一个动作，对正常完成的Observable使用</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>doOnError( )</strong></a> — 注册一个动作，对发生错误的Observable使用</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>doOnTerminate( )</strong></a> — 注册一个动作，对完成的Observable使用，无论是否发生错误</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>doOnSubscribe( )</strong></a> — 注册一个动作，在观察者订阅时使用</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>doOnUnsubscribe( )</strong></a> — 注册一个动作，在观察者取消订阅时使用</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Do.html" target="_blank" rel="noopener"><strong>finallyDo( )</strong></a> — 注册一个动作，在Observable完成时使用</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Delay.html" target="_blank" rel="noopener"><strong>delay( )</strong></a> — 延时发射Observable的结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Delay.html" target="_blank" rel="noopener"><strong>delaySubscription( )</strong></a> — 延时处理订阅请求</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/TimeInterval.html" target="_blank" rel="noopener"><strong>timeInterval( )</strong></a> — 定期发射数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Using.html" target="_blank" rel="noopener"><strong>using( )</strong></a> — 创建一个只在Observable生命周期存在的资源</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html" target="_blank" rel="noopener"><strong>single( )</strong></a> — 强制返回单个数据，否则抛出异常</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html" target="_blank" rel="noopener"><strong>singleOrDefault( )</strong></a> — 如果Observable完成时返回了单个数据，就返回它，否则返回默认数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener"><strong>toFuture( )</strong>, <strong>toIterable( )</strong>, <strong>toList( )</strong></a> — 将Observable转换为其它对象或数据结构</li></ul><h1 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h1><p>延迟一段指定的时间再发射来自Observable的发射物</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.c.png" alt="delay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.c.png" alt="img"></p><p><code>Delay</code>操作符让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量。</p><p>RxJava的实现是 <code>delay</code>和<code>delaySubscription</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.png" alt="delay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.png" alt="img"></p><p>第一种<code>delay</code>接受一个定义时长的参数（包括数量和单位）。每当原始Observable发射一项数据，<code>delay</code>就启动一个定时器，当定时器过了给定的时间段时，<code>delay</code>返回的Observable发射相同的数据项。</p><p>注意：<code>delay</code>不会平移<code>onError</code>通知，它会立即将这个通知传递给订阅者，同时丢弃任何待发射的<code>onNext</code>通知。然而它会平移一个<code>onCompleted</code>通知。</p><p><code>delay</code>默认在<code>computation</code>调度器上执行，你可以通过参数指定使用其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">delay(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">delay()</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.o.png" alt="delay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.o.png" alt="img"></p><p>另一种<code>delay</code>不实用常数延时参数，它使用一个函数针对原始Observable的每一项数据返回一个Observable，它监视返回的这个Observable，当任何那样的Observable终止时，<code>delay</code>返回的Observable就发射关联的那项数据。</p><p>这种<code>delay</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func1" target="_blank" rel="noopener">delay(Func1)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.oo.png" alt="delay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delay.oo.png" alt="img"></p><p>这个版本的<code>delay</code>对每一项数据使用一个Observable作为原始Observable的延时定时器。</p><p>这种<code>delay</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(rx.functions.Func0, rx.functions.Func1" target="_blank" rel="noopener">delay(Func0,Func1)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delaySubscription.png" alt="delay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delaySubscription.png" alt="img"></p><p>还有一个操作符<code>delaySubscription</code>让你你可以延迟订阅原始Observable。它结合搜一个定义延时的参数。</p><p><code>delaySubscription</code>默认在<code>computation</code>调度器上执行，你可以通过参数指定使用其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">delaySubscription(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">delaySubscription(long,TimeUnit,Scheduler)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delaySubscription.o.png" alt="delay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/delaySubscription.o.png" alt="img"></p><p>还有一个版本的<code>delaySubscription</code>使用一个Obseable而不是一个固定的时长来设置订阅延时。</p><p>这种<code>delaySubscription</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#delaySubscription(rx.functions.Func0" target="_blank" rel="noopener">delaySubscription(Func0)</a>)</li></ul><h2 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h2><p>注册一个动作作为原始Observable生命周期事件的一种占位符</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/do.c.png" alt="do"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/do.c.png" alt="img"></p><p>你可以注册回调，当Observable的某个事件发生时，Rx会在与Observable链关联的正常通知集合中调用它。Rx实现了多种操作符用于达到这个目的。</p><p>RxJava实现了很多<code>Do</code>操作符的变体。</p><h3 id="doOnEach"><a href="#doOnEach" class="headerlink" title="doOnEach"></a>doOnEach</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnEach.png" alt="doOnEach"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnEach.png" alt="img"></p><p><code>doOnEach</code>操作符让你可以注册一个回调，它产生的Observable每发射一项数据就会调用它一次。你可以以<code>Action</code>的形式传递参数给它，这个Action接受一个<code>onNext</code>的变体<code>Notification</code>作为它的唯一参数，你也可以传递一个Observable给<code>doOnEach</code>，这个Observable的<code>onNext</code>会被调用，就好像它订阅了原始的Observable一样。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.functions.Action1" target="_blank" rel="noopener">doOnEach(Action1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnEach(rx.Observer" target="_blank" rel="noopener">doOnEach(Observer)</a>)</li></ul><h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnNext.png" alt="doOnNext"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnNext.png" alt="img"></p><p><code>doOnNext</code>操作符类似于<code>doOnEach(Action1)</code>，但是它的Action不是接受一个<code>Notification</code>参数，而是接受发射的数据项。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">          .doOnNext(new Action1&lt;Integer&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void call(Integer item) &#123;</span><br><span class="line">            if( item &gt; 1 ) &#123;</span><br><span class="line">              throw new RuntimeException( &quot;Item exceeds maximum value&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(Integer item) &#123;</span><br><span class="line">            System.out.println(&quot;Next: &quot; + item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">            System.out.println(&quot;Sequence complete.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Next: 1</span><br><span class="line">Error: Item exceeds maximum value</span><br></pre></td></tr></table></figure><h3 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe"></a>doOnSubscribe</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnSubscribe.png" alt="doOnSubscribe"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnSubscribe.png" alt="img"></p><p><code>doOnSubscribe</code>操作符注册一个动作，当观察者订阅它生成的Observable它就会被调用。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnSubscribe(rx.functions.Action0" target="_blank" rel="noopener">doOnSubscribe(Action0)</a>)</li></ul><h3 id="doOnUnsubscribe"><a href="#doOnUnsubscribe" class="headerlink" title="doOnUnsubscribe"></a>doOnUnsubscribe</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnUnsubscribe.png" alt="doOnUnsubscribe"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnUnsubscribe.png" alt="img"></p><p><code>doOnUnsubscribe</code>操作符注册一个动作，当观察者取消订阅它生成的Observable它就会被调用。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnUnsubscribe(rx.functions.Action0" target="_blank" rel="noopener">doOnUnsubscribe(Action0)</a>)</li></ul><h3 id="doOnCompleted"><a href="#doOnCompleted" class="headerlink" title="doOnCompleted"></a>doOnCompleted</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnCompleted.png" alt="doOnCompleted"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnCompleted.png" alt="img"></p><p><code>doOnCompleted</code> 操作符注册一个动作，当它产生的Observable正常终止调用<code>onCompleted</code>时会被调用。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnCompleted(rx.functions.Action0" target="_blank" rel="noopener">doOnCompleted(Action0)</a>)</li></ul><h3 id="doOnError"><a href="#doOnError" class="headerlink" title="doOnError"></a>doOnError</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnError.png" alt="doOnError"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnError.png" alt="img"></p><p><code>doOnError</code> 操作符注册一个动作，当它产生的Observable异常终止调用<code>onError</code>时会被调用。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnError(rx.functions.Action1" target="_blank" rel="noopener">doOnError(Action0)</a>)</li></ul><h3 id="doOnTerminate"><a href="#doOnTerminate" class="headerlink" title="doOnTerminate"></a>doOnTerminate</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnTerminate.png" alt="doOnTerminate"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/doOnTerminate.png" alt="img"></p><p><code>doOnTerminate</code> 操作符注册一个动作，当它产生的Observable终止之前会被调用，无论是正常还是异常终止。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#doOnTerminate(rx.functions.Action0" target="_blank" rel="noopener">doOnTerminate(Action0)</a>)</li></ul><h3 id="finallyDo"><a href="#finallyDo" class="headerlink" title="finallyDo"></a>finallyDo</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/finallyDo.png" alt="finallyDo"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/finallyDo.png" alt="img"></p><p><code>finallyDo</code> 操作符注册一个动作，当它产生的Observable终止之后会被调用，无论是正常还是异常终止。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#finallyDo(rx.functions.Action0" target="_blank" rel="noopener">finallyDo(Action0)</a>)</li></ul><h2 id="Materialize-Dematerialize"><a href="#Materialize-Dematerialize" class="headerlink" title="Materialize/Dematerialize"></a>Materialize/Dematerialize</h2><p><code>Materialize</code>将数据项和事件通知都当做数据项发射，<code>Dematerialize</code>刚好相反。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/materialize.c.png" alt="materialize"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/materialize.c.png" alt="img"></p><p>一个合法的有限的Obversable将调用它的观察者的<code>onNext</code>方法零次或多次，然后调用观察者的<code>onCompleted</code>或<code>onError</code>正好一次。<code>Materialize</code>操作符将这一系列调用，包括原来的<code>onNext</code>通知和终止通知<code>onCompleted</code>或<code>onError</code>都转换为一个Observable发射的数据序列。</p><p>RxJava的<code>materialize</code>将来自原始Observable的通知转换为<code>Notification</code>对象，然后它返回的Observable会发射这些数据。</p><p><code>materialize</code>默认不在任何特定的调度器 (<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Scheduler.md" target="_blank" rel="noopener"><code>Scheduler</code></a>) 上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#materialize(" target="_blank" rel="noopener">materialize()</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/dematerialize.c.png" alt="dematerialize"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/dematerialize.c.png" alt="img"></p><p><code>Dematerialize</code>操作符是<code>Materialize</code>的逆向过程，它将<code>Materialize</code>转换的结果还原成它原本的形式。</p><p><code>dematerialize</code>反转这个过程，将原始Observable发射的<code>Notification</code>对象还原成Observable的通知。</p><p><code>dematerialize</code>默认不在任何特定的调度器 (<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Scheduler.md" target="_blank" rel="noopener"><code>Scheduler</code></a>) 上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#dematerialize(" target="_blank" rel="noopener">dematerialize()</a>)</li></ul><h2 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h2><p>指定一个观察者在哪个调度器上观察这个Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/observeOn.c.png" alt="observeOn"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/observeOn.c.png" alt="img"></p><p>很多ReactiveX实现都使用调度器 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Scheduler.md" target="_blank" rel="noopener">“<code>Scheduler</code>“</a>来管理多线程环境中Observable的转场。你可以使用<code>ObserveOn</code>操作符指定Observable在一个特定的调度器上发送通知给观察者 (调用观察者的<code>onNext</code>, <code>onCompleted</code>, <code>onError</code>方法)。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/observeOn.e.png" alt="observeOn"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/observeOn.e.png" alt="img"></p><p>注意：当遇到一个异常时<code>ObserveOn</code>会立即向前传递这个<code>onError</code>终止通知，它不会等待慢速消费的Observable接受任何之前它已经收到但还没有发射的数据项。这可能意味着<code>onError</code>通知会跳到（并吞掉）原始Observable发射的数据项前面，正如图例上展示的。</p><p><code>SubscribeOn</code>操作符的作用类似，但它是用于指定Observable本身在特定的调度器上执行，它同样会在那个调度器上给观察者发通知。</p><p>RxJava中，要指定Observable应该在哪个调度器上调用观察者的<code>onNext</code>, <code>onCompleted</code>, <code>onError</code>方法，你需要使用<code>observeOn</code>操作符，传递给它一个合适的<code>Scheduler</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#observeOn(rx.Scheduler" target="_blank" rel="noopener">observeOn(Scheduler)</a>)</li></ul><h2 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize"></a>Serialize</h2><p>强制一个Observable连续调用并保证行为正确</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/serialize.c.png" alt="img"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/serialize.c.png" alt="img"></p><p>一个Observable可以异步调用它的观察者的方法，可能是从不同的线程调用。这可能会让Observable行为不正确，它可能会在某一个<code>onNext</code>调用之前尝试调用<code>onCompleted</code>或<code>onError</code>方法，或者从两个不同的线程同时调用<code>onNext</code>方法。使用<code>Serialize</code>操作符，你可以纠正这个Observable的行为，保证它的行为是正确的且是同步的。</p><p>RxJava中的实现是<code>serialize</code>，它默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#serialize(" target="_blank" rel="noopener">serialize()</a>)</li></ul><h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><p>操作来自Observable的发射物和通知</p><p><code>Subscribe</code>操作符是连接观察者和Observable的胶水。一个观察者要想看到Observable发射的数据项，或者想要从Observable获取错误和完成通知，它首先必须使用这个操作符订阅那个Observable。</p><p><code>Subscribe</code>操作符的一般实现可能会接受一到三个方法（然后由观察者组合它们），或者接受一个实现了包含这三个方法的接口的对象（有时叫做<code>Observer</code>或<code>Subscriber</code>）：</p><p><strong>onNext</strong></p><p>每当Observable发射了一项数据它就会调用这个方法。这个方法的参数是这个Observable发射的数据项。</p><p><strong>onError</strong></p><p>Observable调用这个方法表示它无法生成期待的数据或者遇到了其它错误。这将停止Observable，它在这之后不会再调用<code>onNext</code>或<code>onCompleted</code>。<code>onError</code>方法的参数是导致这个错误的原因的一个表示（有时可能是一个Exception或Throwable对象，其它时候也可能是一个简单的字符串，取决于具体的实现）。</p><p><strong>onCompleted</strong></p><p>如果没有遇到任何错误，Observable在最后一次调用<code>onCompleted</code>之后会调用这个方法。</p><p>如果一个Observable直到有一个观察者订阅它才开始发射数据项，就称之为”冷”的Observable；如果一个Observable可能在任何时刻开始发射数据，就称之为”热”的Observable，一个订阅者可能从开始之后的某个时刻开始观察它发射的数据序列，它可能会错过在订阅之前发射的数据。</p><p>RxJava中的实现是<code>subscribe</code>方法。</p><p>如果你使用无参数的版本，它将触发对Observable的一个订阅，但是将忽略它的发射物和通知。这个操作会激活一个”冷”的Observable。</p><p>你也可以传递一到三个函数给它，它们会按下面的方法解释：</p><ol><li><code>onNext</code></li><li><code>onNext</code>和<code>onError</code></li><li><code>onNext</code>, <code>onError</code>和<code>onCompleted</code></li></ol><p>最后，你还可以传递一个<code>Observer</code>或<code>Subscriber</code>接口给它，<code>Observer</code>接口包含这三个以<code>on</code>开头的方法。<code>Subscriber</code>接口也实现了这三个方法，而且还添加了几个额外的方法，用于支持使用反压操作(<code>reactive pull backpressure</code>)，这让<code>Subscriber</code>可以在Observable完成前取消订阅。</p><p><code>subscribe</code>方法返回一个实现了<code>Subscription</code>接口的对象。这个接口包含<code>unsubscribe</code>方法，任何时刻你都可以调用它来断开<code>subscribe</code>方法建立的Observable和观察者之间的订阅关系。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(" target="_blank" rel="noopener">subscribe()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1" target="_blank" rel="noopener">subscribe(Action1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1, rx.functions.Action1" target="_blank" rel="noopener">subscribe(Action1,Action1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0" target="_blank" rel="noopener">subscribe(Action1,Action1,Action0)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.Observer" target="_blank" rel="noopener">subscribe(Observer)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribe(rx.Subscriber" target="_blank" rel="noopener">subscribe(Subscriber)</a>)</li></ul><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p><code>forEach</code>方法是简化版的<code>subscribe</code>，你同样可以传递一到三个函数给它，解释和传递给<code>subscribe</code>时一样。</p><p>不同的是，你无法使用<code>forEach</code>返回的对象取消订阅。也没办法传递一个可以用于取消订阅的参数。因此，只有当你明确地需要操作Observable的所有发射物和通知时，你才应该使用这个操作符。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1" target="_blank" rel="noopener">forEach(Action1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1, rx.functions.Action1" target="_blank" rel="noopener">forEach(Action1,Action1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#forEach(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0" target="_blank" rel="noopener">forEach(Action1,Action1,A/Users/mcxiaoke/github/RxDocs/docs/BlockingObservable.mdction0)</a>)</li></ul><h3 id="BlockingObservable"><a href="#BlockingObservable" class="headerlink" title="BlockingObservable"></a>BlockingObservable</h3><p><code>BlockingObservable</code>类中也有一个类似的叫作<code>forEach</code>的方法。详细的说明见 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/BlockingObservable.md" target="_blank" rel="noopener"><code>BlockingObservable</code></a></p><h2 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h2><p>指定Observable自身在哪个调度器上执行</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/subscribeOn.c.png" alt="SubscribeOn"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/subscribeOn.c.png" alt="img"></p><p>很多ReactiveX实现都使用调度器 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Scheduler.md" target="_blank" rel="noopener">“<code>Scheduler</code>“</a>来管理多线程环境中Observable的转场。你可以使用<code>SubscribeOn</code>操作符指定Observable在一个特定的调度器上运转。</p><p><code>ObserveOn</code>操作符的作用类似，但是功能很有限，它指示Observable在一个指定的调度器上给观察者发通知。</p><p>在某些实现中还有一个<code>UnsubscribeOn</code>操作符。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#subscribeOn(rx.Scheduler" target="_blank" rel="noopener">subscribeOn(Scheduler)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#unsubscribeOn(rx.Scheduler" target="_blank" rel="noopener">unsubscribeOn(Scheduler)</a>)</li></ul><h2 id="TimeInterval"><a href="#TimeInterval" class="headerlink" title="TimeInterval"></a>TimeInterval</h2><p>将一个发射数据的Observable转换为发射那些数据发射时间间隔的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeInterval.c.png" alt="TimeInterval"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeInterval.c.png" alt="img"></p><p><code>TimeInterval</code>操作符拦截原始Observable发射的数据项，替换为发射表示相邻发射物时间间隔的对象。</p><p>RxJava中的实现为<code>timeInterval</code>，这个操作符将原始Observable转换为另一个Observable，后者发射一个标志替换前者的数据项，这个标志表示前者的两个连续发射物之间流逝的时间长度。新的Observable的第一个发射物表示的是在观察者订阅原始Observable到原始Observable发射它的第一项数据之间流逝的时间长度。不存在与原始Observable发射最后一项数据和发射<code>onCompleted</code>通知之间时长对应的发射物。</p><p><code>timeInterval</code>默认在<code>immediate</code>调度器上执行，你可以通过传参数修改。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeInterval(" target="_blank" rel="noopener">timeInterval()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeInterval(rx.Scheduler" target="_blank" rel="noopener">timeInterval(Scheduler)</a>)</li></ul><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>对原始Observable的一个镜像，如果过了一个指定的时长仍没有发射数据，它会发一个错误通知</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.c.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.c.png" alt="img"></p><p>如果原始Observable过了指定的一段时长没有发射任何数据，<code>Timeout</code>操作符会以一个<code>onError</code>通知终止这个Observable。</p><p>RxJava中的实现为<code>timeout</code>，但是有好几个变体。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.1.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.1.png" alt="img"></p><p>第一个变体接受一个时长参数，每当原始Observable发射了一项数据，<code>timeout</code>就启动一个计时器，如果计时器超过了指定指定的时长而原始Observable没有发射另一项数据，<code>timeout</code>就抛出<code>TimeoutException</code>，以一个错误通知终止Observable。</p><p>这个<code>timeout</code>默认在<code>computation</code>调度器上执行，你可以通过参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">timeout(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit, rx.Scheduler" target="_blank" rel="noopener">timeout()</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.2.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.2.png" alt="img"></p><p>这个版本的<code>timeout</code>在超时时会切换到使用一个你指定的备用的Observable，而不是发错误通知。它也默认在<code>computation</code>调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit, rx.Observable" target="_blank" rel="noopener">timeout(long,TimeUnit,Observable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(long, java.util.concurrent.TimeUnit, rx.Observable, rx.Scheduler" target="_blank" rel="noopener">timeout(long,TimeUnit,Observable,Scheduler)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.3.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.3.png" alt="img"></p><p>这个版本的<code>timeout</code>使用一个函数针对原始Observable的每一项返回一个Observable，如果当这个Observable终止时原始Observable还没有发射另一项数据，就会认为是超时了，<code>timeout</code>就抛出<code>TimeoutException</code>，以一个错误通知终止Observable。</p><p>这个<code>timeout</code>默认在<code>immediate</code>调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func1" target="_blank" rel="noopener">timeout(Func1)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.4.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.4.png" alt="img"></p><p>这个版本的<code>timeout</code>同时指定超时时长和备用的Observable。它默认在<code>immediate</code>调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func1, rx.Observable" target="_blank" rel="noopener">timeout(Func1,Observable)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.5.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.5.png" alt="img"></p><p>这个版本的<code>time</code>除了给每一项设置超时，还可以单独给第一项设置一个超时。它默认在<code>immediate</code>调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func0, rx.functions.Func1" target="_blank" rel="noopener">timeout(Func0,Func1)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.6.png" alt="Timeout"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timeout.6.png" alt="img"></p><p>同上，但是同时可以指定一个备用的Observable。它默认在<code>immediate</code>调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timeout(rx.functions.Func0, rx.functions.Func1, rx.Observable" target="_blank" rel="noopener">timeout(Func0,Func1,Observable)</a>)</li></ul><h2 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h2><p>给Observable发射的数据项附加一个时间戳</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timestamp.c.png" alt="Timestamp"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/timestamp.c.png" alt="img"></p><p>RxJava中的实现为<code>timestamp</code>，它将一个发射T类型数据的Observable转换为一个发射类型为<code>Timestamped&lt;T&gt;</code>的数据的Observable，每一项都包含数据的原始发射时间。</p><p><code>timestamp</code>默认在<code>immediate</code>调度器上执行，但是可以通过参数指定其它的调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timestamp(" target="_blank" rel="noopener">timestamp()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#timestamp(rx.Scheduler" target="_blank" rel="noopener">timestamp(Scheduler)</a>)</li></ul><h2 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h2><p>创建一个只在Observable生命周期内存在的一次性资源</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/using.c.png" alt="using"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/using.c.png" alt="img"></p><p><code>Using</code>操作符让你可以指示Observable创建一个只在它的生命周期内存在的资源，当Observable终止时这个资源会被自动释放。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/using.png" alt="using"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/using.png" alt="img"></p><p><code>using</code>操作符接受三个参数：</p><ol><li>一个用户创建一次性资源的工厂函数</li><li>一个用于创建Observable的工厂函数</li><li>一个用于释放资源的函数</li></ol><p>当一个观察者订阅<code>using</code>返回的Observable时，<code>using</code>将会使用Observable工厂函数创建观察者要观察的Observable，同时使用资源工厂函数创建一个你想要创建的资源。当观察者取消订阅这个Observable时，或者当观察者终止时（无论是正常终止还是因错误而终止），<code>using</code>使用第三个函数释放它创建的资源。</p><p><code>using</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#using(rx.functions.Func0, rx.functions.Func1, rx.functions.Action1" target="_blank" rel="noopener">using(Func0,Func1,Action1)</a>)</li></ul><h2 id="To"><a href="#To" class="headerlink" title="To"></a>To</h2><p>将Observable转换为另一个对象或数据结构</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/to.c.png" alt="to"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/to.c.png" alt="img"></p><p>ReactiveX的很多语言特定实现都有一种操作符让你可以将Observable或者Observable发射的数据序列转换为另一个对象或数据结构。它们中的一些会阻塞直到Observable终止，然后生成一个等价的对象或数据结构；另一些返回一个发射那个对象或数据结构的Observable。</p><p>在某些ReactiveX实现中，还有一个操作符用于将Observable转换成阻塞式的。一个阻塞式的Ogbservable在普通的Observable的基础上增加了几个方法，用于操作Observable发射的数据项。</p><h3 id="getIterator"><a href="#getIterator" class="headerlink" title="getIterator"></a>getIterator</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.getIterator.png" alt="getIterator"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.getIterator.png" alt="img"></p><p><code>getIterator</code>操作符只能用于<code>BlockingObservable</code>的子类，要使用它，你首先必须把原始的Observable转换为一个<code>BlockingObservable</code>。可以使用这两个操作符：<code>BlockingObservable.from</code>或<code>the Observable.toBlocking</code>。</p><p>这个操作符将Observable转换为一个<code>Iterator</code>，你可以通过它迭代原始Observable发射的数据集。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#getIterator(" target="_blank" rel="noopener">BlockingObservable.getIterator()</a>)</li></ul><h3 id="toFuture"><a href="#toFuture" class="headerlink" title="toFuture"></a>toFuture</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.toFuture.png" alt="toFuture"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.toFuture.png" alt="img"></p><p><code>toFuture</code>操作符也是只能用于<code>BlockingObservable</code>。这个操作符将Observable转换为一个返回单个数据项的<code>Future</code>，如果原始Observable发射多个数据项，<code>Future</code>会收到一个<code>IllegalArgumentException</code>；如果原始Observable没有发射任何数据，<code>Future</code>会收到一个<code>NoSuchElementException</code>。</p><p>如果你想将发射多个数据项的Observable转换为<code>Future</code>，可以这样用：<code>myObservable.toList().toBlocking().toFuture()</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toFuture(" target="_blank" rel="noopener">BlockingObservable.toFuture()</a>)</li></ul><h3 id="toIterable"><a href="#toIterable" class="headerlink" title="toIterable"></a>toIterable</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.toIterable.png" alt="toIterable"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.toIterable.png" alt="img"></p><p><code>toFuture</code>操作符也是只能用于<code>BlockingObservable</code>。这个操作符将Observable转换为一个<code>Iterable</code>，你可以通过它迭代原始Observable发射的数据集。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toIterable(" target="_blank" rel="noopener">BlockingObservable.toIterable()</a>)</li></ul><h3 id="toList"><a href="#toList" class="headerlink" title="toList"></a>toList</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toList.png" alt="toList"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toList.png" alt="img"></p><p>通常，发射多项数据的Observable会为每一项数据调用<code>onNext</code>方法。你可以用<code>toList</code>操作符改变这个行为，让Observable将多项数据组合成一个<code>List</code>，然后调用一次<code>onNext</code>方法传递整个列表。</p><p>如果原始Observable没有发射任何数据就调用了<code>onCompleted</code>，<code>toList</code>返回的Observable会在调用<code>onCompleted</code>之前发射一个空列表。如果原始Observable调用了<code>onError</code>，<code>toList</code>返回的Observable会立即调用它的观察者的<code>onError</code>方法。</p><p><code>toList</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toList(" target="_blank" rel="noopener">toList()</a>)</li></ul><h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toMap.png" alt="toMap"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toMap.png" alt="img"></p><p><code>toMap</code>收集原始Observable发射的所有数据项到一个Map（默认是HashMap）然后发射这个Map。你可以提供一个用于生成Map的Key的函数，还可以提供一个函数转换数据项到Map存储的值（默认数据项本身就是值）。</p><p><code>toMap</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1" target="_blank" rel="noopener">toMap(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1, rx.functions.Func1" target="_blank" rel="noopener">toMap(Func1,Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0" target="_blank" rel="noopener">toMap(Func1,Func1,Func0)</a>)</li></ul><h3 id="toMultiMap"><a href="#toMultiMap" class="headerlink" title="toMultiMap"></a>toMultiMap</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toMultiMap.png" alt="toMultiMap"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toMultiMap.png" alt="img"></p><p><code>toMultiMap</code>类似于<code>toMap</code>，不同的是，它生成的这个Map同时还是一个<code>ArrayList</code>（默认是这样，你可以传递一个可选的工厂方法修改这个行为）。</p><p><code>toMultiMap</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1" target="_blank" rel="noopener">toMultiMap(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1, rx.functions.Func1" target="_blank" rel="noopener">toMultiMap(Func1,Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0" target="_blank" rel="noopener">toMultiMap(Func1,Func1,Func0)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0, rx.functions.Func1" target="_blank" rel="noopener">toMultiMap(Func1,Func1,Func0,Func1)</a>)</li></ul><h3 id="toSortedList"><a href="#toSortedList" class="headerlink" title="toSortedList"></a>toSortedList</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toSortedList.png" alt="toSortedList"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/toSortedList.png" alt="img"></p><p><code>toSortedList</code>类似于<code>toList</code>，不同的是，它会对产生的列表排序，默认是自然升序，如果发射的数据项没有实现<code>Comparable</code>接口，会抛出一个异常。然而，你也可以传递一个函数作为用于比较两个数据项，这是<code>toSortedList</code>不会使用<code>Comparable</code>接口。</p><p><code>toSortedList</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(" target="_blank" rel="noopener">toSortedList()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(rx.functions.Func2" target="_blank" rel="noopener">toSortedList(Func2)</a>)</li></ul><h3 id="nest"><a href="#nest" class="headerlink" title="nest"></a>nest</h3><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/nest.png" alt="nest"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/nest.png" alt="img"></p><p><code>nest</code>操作符有一个特殊的用途：将一个Observable转换为一个发射这个Observable的Observable。</p><h1 id="条件和布尔操作-1"><a href="#条件和布尔操作-1" class="headerlink" title="条件和布尔操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">条件和布尔操作</a></h1><p>这个页面的操作符可用于根据条件发射或变换Observables，或者对它们做布尔运算：</p><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Amb" target="_blank" rel="noopener"><strong>amb( )</strong></a> — 给定多个Observable，只让第一个发射数据的Observable发射全部数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#DefaultIfEmpty" target="_blank" rel="noopener"><strong>defaultIfEmpty( )</strong></a> — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据</li><li>(<code>rxjava-computation-expressions</code>) <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Repeat" target="_blank" rel="noopener"><strong>doWhile( )</strong></a> — 发射原始Observable的数据序列，然后重复发射这个序列直到不满足这个条件为止</li><li>(<code>rxjava-computation-expressions</code>) <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Defer" target="_blank" rel="noopener"><strong>ifThen( )</strong></a> — 只有当某个条件为真时才发射原始Observable的数据序列，否则发射一个空的或默认的序列</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#SkipUntil" target="_blank" rel="noopener"><strong>skipUntil( )</strong></a> — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#SkipWhile" target="_blank" rel="noopener"><strong>skipWhile( )</strong></a> — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据</li><li>(<code>rxjava-computation-expressions</code>) <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Defer" target="_blank" rel="noopener"><strong>switchCase( )</strong></a> — 基于一个计算结果，发射一个指定Observable的数据序列</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#TakeUntil" target="_blank" rel="noopener"><strong>takeUntil( )</strong></a> — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#TakeWhile" target="_blank" rel="noopener"><strong>takeWhile( ) and takeWhileWithIndex( )</strong></a> — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据</li><li>(<code>rxjava-computation-expressions</code>) <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Repeat" target="_blank" rel="noopener"><strong>whileDo( )</strong></a> — 如果条件为<code>true</code>，则发射源Observable数据序列，并且只要条件保持为<code>true</code>就重复发射此数据序列</li></ul><blockquote><p>(<code>rxjava-computation-expressions</code>) — 表示这个操作符当前是可选包 <code>rxjava-computation-expressions</code> 的一部分，还没有包含在标准RxJava的操作符集合里</p></blockquote><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#All" target="_blank" rel="noopener"><strong>all( )</strong></a> — 判断是否所有的数据项都满足某个条件</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Contains" target="_blank" rel="noopener"><strong>contains( )</strong></a> — 判断Observable是否会发射一个指定的值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Contains" target="_blank" rel="noopener"><strong>exists( ) and isEmpty( )</strong></a> — 判断Observable是否发射了一个值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Conditional.html#Sequenceequal" target="_blank" rel="noopener"><strong>sequenceEqual( )</strong></a> — 判断两个Observables发射的序列是否相等</li></ul><h1 id="条件和布尔操作-2"><a href="#条件和布尔操作-2" class="headerlink" title="条件和布尔操作"></a>条件和布尔操作</h1><h2 id="All"><a href="#All" class="headerlink" title="All"></a>All</h2><p>判定是否Observable发射的所有数据都满足某个条件</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/all.c.png" alt="all"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/all.c.png" alt="img"></p><p>传递一个谓词函数给<code>All</code>操作符，这个函数接受原始Observable发射的数据，根据计算返回一个布尔值。<code>All</code>返回一个只发射一个单个布尔值的Observable，如果原始Observable正常终止并且每一项数据都满足条件，就返回true；如果原始Observable的任何一项数据不满足条件就返回False。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/all.png" alt="all"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/all.png" alt="img"></p><p>RxJava将这个操作符实现为<code>all</code>，它默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1" target="_blank" rel="noopener">all(Func1)</a>)</li></ul><h2 id="Amb"><a href="#Amb" class="headerlink" title="Amb"></a>Amb</h2><p>给定两个或多个Observables，它只发射首先发射数据或通知的那个Observable的所有数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/amb.c.png" alt="amb"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/amb.c.png" alt="img"></p><p>当你传递多个Observable给<code>Amb</code>时，它只发射其中一个Observable的数据和通知：首先发送通知给<code>Amb</code>的那个，不管发射的是一项数据还是一个<code>onError</code>或<code>onCompleted</code>通知。<code>Amb</code>将忽略和丢弃其它所有Observables的发射物。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/amb.png" alt="amb"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/amb.png" alt="img"></p><p>RxJava的实现是<code>amb</code>，有一个类似的对象方法<code>ambWith</code>。例如，<code>Observable.amb(o1,o2)</code>和<code>o1.ambWith(o2)</code>是等价的。</p><p>这个操作符默认不在任何特定的调度器上执行。</p><h2 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h2><p>判定一个Observable是否发射一个特定的值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/contains.c.png" alt="contains"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/contains.c.png" alt="img"></p><p>给<code>Contains</code>传一个指定的值，如果原始Observable发射了那个值，它返回的Observable将发射true，否则发射false。</p><p>相关的一个操作符<code>IsEmpty</code>用于判定原始Observable是否没有发射任何数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/contains.png" alt="contains"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/contains.png" alt="img"></p><p><code>contains</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object" target="_blank" rel="noopener">contains(Object)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/exists.png" alt="exists"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/exists.png" alt="img"></p><p>RxJava中还有一个<code>exists</code>操作符，它通过一个谓词函数测试原始Observable发射的数据，只要任何一项满足条件就返回一个发射true的Observable，否则返回一个发射false的Observable。</p><p><code>exists</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#exists(rx.functions.Func1" target="_blank" rel="noopener">exists(Func1)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/isEmpty.png" alt="isEmpty"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/isEmpty.png" alt="img"></p><p><code>isEmpty</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#isEmpty(" target="_blank" rel="noopener">isEmpty()</a>)</li></ul><h2 id="DefaultIfEmpty"><a href="#DefaultIfEmpty" class="headerlink" title="DefaultIfEmpty"></a>DefaultIfEmpty</h2><p>发射来自原始Observable的值，如果原始Observable没有发射任何值，就发射一个默认值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/defaultIfEmpty.c.png" alt="defaultIfEmtpy"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/defaultIfEmpty.c.png" alt="img"></p><p><code>DefaultIfEmpty</code>简单的精确地发射原始Observable的值，如果原始Observable没有发射任何数据正常终止（以<code>onCompleted</code>d的形式），<code>DefaultIfEmpty</code>返回的Observable就发射一个你提供的默认值。</p><p>RxJava将这个操作符实现为<code>defaultIfEmpty</code>。它默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T" target="_blank" rel="noopener">defaultIfEmpty(T)</a>)</li></ul><p>还有一个新的操作符<code>switchIfEmpty</code>，不在RxJava 1.0.0版中，它和<code>defaultIfEmtpy</code>类似，不同的是，如果原始Observable没有发射数据，它发射一个备用Observable的发射物。</p><h2 id="SequenceEqual"><a href="#SequenceEqual" class="headerlink" title="SequenceEqual"></a>SequenceEqual</h2><p>判定两个Observables是否发射相同的数据序列。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sequenceEqual.c.png" alt="sequenceEqual"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sequenceEqual.c.png" alt="img"></p><p>传递两个Observable给<code>SequenceEqual</code>操作符，它会比较两个Observable的发射物，如果两个序列是相同的（相同的数据，相同的顺序，相同的终止状态），它就发射true，否则发射false。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sequenceEqual.png" alt="sequenceEqual"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sequenceEqual.png" alt="img"></p><p>它还有一个版本接受第三个参数，可以传递一个函数用于比较两个数据项是否相同。</p><p>这个操作符默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#sequenceEqual(rx.Observable, rx.Observable" target="_blank" rel="noopener">sequenceEqual(Observable,Observable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#sequenceEqual(rx.Observable, rx.Observable, rx.functions.Func2" target="_blank" rel="noopener">sequenceEqual(Observable,Observable,Func2)</a>)</li></ul><h2 id="SkipUntil"><a href="#SkipUntil" class="headerlink" title="SkipUntil"></a>SkipUntil</h2><p>丢弃原始Observable发射的数据，直到第二个Observable发射了一项数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipUntil.c.png" alt="skipUntil"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipUntil.c.png" alt="img"></p><p><code>SkipUntil</code>订阅原始的Observable，但是忽略它的发射物，直到第二个Observable发射了一项数据那一刻，它开始发射原始Observable。</p><p>RxJava中对应的是<code>skipUntil</code>，它默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipUntil(rx.Observable" target="_blank" rel="noopener">skipUntil(Observable)</a>)</li></ul><h2 id="SkipWhile"><a href="#SkipWhile" class="headerlink" title="SkipWhile"></a>SkipWhile</h2><p>丢弃Observable发射的数据，直到一个指定的条件不成立</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipWhile.c.png" alt="skipWhile"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipWhile.c.png" alt="img"></p><p><code>SkipWhile</code>订阅原始的Observable，但是忽略它的发射物，直到你指定的某个条件变为false的那一刻，它开始发射原始Observable。</p><p><code>skipWhile</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#skipWhile(rx.functions.Func1" target="_blank" rel="noopener">skipWhile(Func1)</a>)</li></ul><h2 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h2><p>当第二个Observable发射了一项数据或者终止时，丢弃原始Observable发射的任何数据</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeUntil.c.png" alt="takeUntil"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeUntil.c.png" alt="img"></p><p><code>TakeUntil</code>订阅并开始发射原始Observable，它还监视你提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，<code>TakeUntil</code>返回的Observable会停止发射原始Observable并终止。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeUntil.png" alt="takeUntil"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeUntil.png" alt="img"></p><p>RxJava中的实现是<code>takeUntil</code>。注意：第二个Observable发射一项数据或一个<code>onError</code>通知或一个<code>onCompleted</code>通知都会导致<code>takeUntil</code>停止发射数据。</p><p><code>takeUntil</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeUntil(rx.Observable" target="_blank" rel="noopener">takeUntil(Observable)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeUntil.p.png" alt="takeUntil"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeUntil.p.png" alt="img"></p><p>还有一个版本的<code>takeUntil</code>，不在RxJava 1.0.0版中，它使用一个谓词函数而不是第二个Observable来判定是否需要终止发射数据，它的行为类似于<code>takeWhile</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeUntil(rx.functions.Func1" target="_blank" rel="noopener">takeUntil(Func1)</a>)</li></ul><h2 id="TakeWhile"><a href="#TakeWhile" class="headerlink" title="TakeWhile"></a>TakeWhile</h2><p>发射Observable发射的数据，直到一个指定的条件不成立</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeWhile.c.png" alt="takeWhile"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeWhile.c.png" alt="img"></p><p><code>TakeWhile</code>发射原始Observable，直到你指定的某个条件不成立的那一刻，它停止发射原始Observable，并终止自己的Observable。</p><p>RxJava中的<code>takeWhile</code>操作符返回一个镜像原始Observable行为的Observable，直到某一项数据你指定的函数返回<code>false</code>那一刻，这个新的Observable发射<code>onCompleted</code>终止通知。</p><p><code>takeWhile</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#takeWhile(rx.functions.Func1" target="_blank" rel="noopener">takeWhile(Func1)</a>)</li></ul><h1 id="算术和聚合操作-1"><a href="#算术和聚合操作-1" class="headerlink" title="算术和聚合操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">算术和聚合操作</a></h1><p>本页展示的操作符用于对整个序列执行算法操作或其它操作，由于这些操作必须等待数据发射完成（通常也必须缓存这些数据），它们对于非常长或者无限的序列来说是危险的，不推荐使用。</p><h4 id="rxjava-math-模块的操作符"><a href="#rxjava-math-模块的操作符" class="headerlink" title="rxjava-math 模块的操作符"></a><code>rxjava-math</code> 模块的操作符</h4><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Average" target="_blank" rel="noopener"><strong>averageInteger( )</strong></a> — 求序列平均数并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Average" target="_blank" rel="noopener"><strong>averageLong( )</strong></a> — 求序列平均数并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Average" target="_blank" rel="noopener"><strong>averageFloat( )</strong></a> — 求序列平均数并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Average" target="_blank" rel="noopener"><strong>averageDouble( )</strong></a> — 求序列平均数并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Max" target="_blank" rel="noopener"><strong>max( )</strong></a> — 求序列最大值并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Max" target="_blank" rel="noopener"><strong>maxBy( )</strong></a> — 求最大key对应的值并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Min" target="_blank" rel="noopener"><strong>min( )</strong></a> — 求最小值并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Min" target="_blank" rel="noopener"><strong>minBy( )</strong></a> — 求最小Key对应的值并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Sum" target="_blank" rel="noopener"><strong>sumInteger( )</strong></a> — 求和并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Sum" target="_blank" rel="noopener"><strong>sumLong( )</strong></a> — 求和并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Sum" target="_blank" rel="noopener"><strong>sumFloat( )</strong></a> — 求和并发射</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Sum" target="_blank" rel="noopener"><strong>sumDouble( )</strong></a> — 求和并发射</li></ul><h4 id="其它聚合操作符"><a href="#其它聚合操作符" class="headerlink" title="其它聚合操作符"></a>其它聚合操作符</h4><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Concat" target="_blank" rel="noopener"><strong>concat( )</strong></a> — 顺序连接多个Observables</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Count" target="_blank" rel="noopener"><strong>count( ) and countLong( )</strong></a> — 计算数据项的个数并发射结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Reduce" target="_blank" rel="noopener"><strong>reduce( )</strong></a> — 对序列使用reduce()函数并发射最终的结果</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Mathematical.html#Reduce" target="_blank" rel="noopener"><strong>collect( )</strong></a> — 将原始Observable发射的数据放到一个单一的可变的数据结构中，然后返回一个发射这个数据结构的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener"><strong>toList( )</strong></a> — 收集原始Observable发射的所有数据到一个列表，然后返回这个列表</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener"><strong>toSortedList( )</strong></a> — 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener"><strong>toMap( )</strong></a> — 将序列数据转换为一个Map，Map的key是根据一个函数计算的</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html" target="_blank" rel="noopener"><strong>toMultiMap( )</strong></a> — 将序列数据转换为一个列表，同时也是一个Map，Map的key是根据一个函数计算的</li></ul><h1 id="算术和聚合操作-2"><a href="#算术和聚合操作-2" class="headerlink" title="算术和聚合操作"></a>算术和聚合操作</h1><h2 id="Average"><a href="#Average" class="headerlink" title="Average"></a>Average</h2><p>计算原始Observable发射数字的平均值并发射它</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/average.c.png" alt="average"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/average.c.png" alt="img"></p><p><code>Average</code>操作符操作符一个发射数字的Observable，并发射单个值：原始Observable发射的数字序列的平均值。</p><p>这个操作符不包含在RxJava核心模块中，它属于不同的<code>rxjava-math</code>模块。它被实现为四个操作符：<code>averageDouble</code>, <code>averageFloat</code>, <code>averageInteger</code>, <code>averageLong</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/average.f.png" alt="average"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/average.f.png" alt="img"></p><p>如果原始Observable不发射任何数据，这个操作符会抛异常：<code>IllegalArgumentException</code>。</p><h2 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h2><p>发射原始Observable的最小值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/min.c.png" alt="min"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/min.c.png" alt="img"></p><p><code>Min</code>操作符操作一个发射数值的Observable并发射单个值：最小的那个值。</p><p>RxJava中，<code>min</code>属于<code>rxjava-math</code>模块。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/min.png" alt="min"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/min.png" alt="img"></p><p><code>min</code>接受一个可选参数，用于比较两项数据的大小，如果最小值的数据超过一项，<code>min</code>会发射原始Observable最近发射的那一项。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/minBy.png" alt="minBy"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/minBy.png" alt="img"></p><p><code>minBy</code>类似于<code>min</code>，但是它发射的不是最小值，而是发射Key最小的项，Key由你指定的一个函数生成。</p><h2 id="Max"><a href="#Max" class="headerlink" title="Max"></a>Max</h2><p>发射原始Observable的最大值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/max.c.png" alt="max"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/max.c.png" alt="img"></p><p><code>Max</code>操作符操作一个发射数值的Observable并发射单个值：最大的那个值。</p><p>RxJava中，<code>max</code>属于<code>rxjava-math</code>模块。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/max.png" alt="max"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/max.png" alt="img"></p><p><code>max</code>接受一个可选参数，用于比较两项数据的大小，如果最大值的数据超过一项，<code>max</code>会发射原始Observable最近发射的那一项。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/maxBy.png" alt="maxBy"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/maxBy.png" alt="img"></p><p><code>maxBy</code>类似于<code>max</code>，但是它发射的不是最大值，而是发射Key最大的项，Key由你指定的一个函数生成。</p><h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p>计算原始Observable发射物的数量，然后只发射这个值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/count.c.png" alt="count"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/count.c.png" alt="img"></p><p><code>Count</code>操作符将一个Observable转换成一个发射单个值的Observable，这个值表示原始Observable发射的数据的数量。</p><p>如果原始Observable发生错误终止，<code>Count</code>不发射数据而是直接传递错误通知。如果原始Observable永远不终止，<code>Count</code>既不会发射数据也不会终止。</p><p>RxJava的实现是<code>count</code>和<code>countLong</code>。</p><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] items = new String[] &#123; &quot;one&quot;, &quot;two&quot;, &quot;three&quot; &#125;;</span><br><span class="line">assertEquals( new Integer(3), Observable.from(items).count().toBlocking().single() );</span><br></pre></td></tr></table></figure><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#count(" target="_blank" rel="noopener">count()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong(" target="_blank" rel="noopener">countLong()</a>)</li></ul><h2 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h2><p>计算Observable发射的数值的和并发射这个和</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sum.c.png" alt="sum"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sum.c.png" alt="img"></p><p><code>Sum</code>操作符操作一个发射数值的Observable，仅发射单个值：原始Observable所有数值的和。</p><p>RxJava的实现是<code>sumDouble</code>, <code>sumFloat</code>, <code>sumInteger</code>, <code>sumLong</code>，它们不是RxJava核心模块的一部分，属于<code>rxjava-math</code>模块。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sum.f.png" alt="sum.f"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sum.f.png" alt="img"></p><p>你可以使用一个函数，计算Observable每一项数据的函数返回值的和。</p><p>在<code>StringObservable</code>类（这个类不是RxJava核心模块的一部分）中有一个<code>stringConcat</code>操作符，它将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者这个字符串表示的是前者所有字符串的连接。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.join.png" alt="St.join"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/St.join.png" alt="img"></p><p><code>StringObservable</code>类还有一个<code>join</code>操作符，它将一个发射字符串序列的Observable转换为一个发射单个字符串的Observable，后者这个字符串表示的是前者所有字符串以你指定的分界符连接的结果。</p><h2 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h2><p>不交错的发射两个或多个Observable的发射物</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/concat.c.png" alt="concat"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/concat.c.png" alt="img"></p><p><code>Concat</code>操作符连接多个Observable的输出，就好像它们是一个Observable，第一个Observable发射的所有数据在第二个Observable发射的任何数据前面，以此类推。</p><p>直到前面一个Observable终止，<code>Concat</code>才会订阅额外的一个Observable。注意：因此，如果你尝试连接一个”热”Observable（这种Observable在创建后立即开始发射数据，即使没有订阅者），<code>Concat</code>将不会看到也不会发射它之前发射的任何数据。</p><p>在ReactiveX的某些实现中有一种<code>ConcatMap</code>操作符（名字可能叫<code>concat_all</code>, <code>concat_map</code>, <code>concatMapObserver</code>, <code>for</code>, <code>forIn/for_in</code>, <code>mapcat</code>, <code>selectConcat</code>或<code>selectConcatObserver</code>），他会变换原始Observable发射的数据到一个对应的Observable，然后再按观察和变换的顺序进行连接操作。</p><p><code>StartWith</code>操作符类似于<code>Concat</code>，但是它是插入到前面，而不是追加那些Observable的数据到原始Observable发射的数据序列。</p><p><code>Merge</code>操作符也差不多，它结合两个或多个Observable的发射物，但是数据可能交错，而<code>Concat</code>不会让多个Observable的发射物交错。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/concat.png" alt="concat"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/concat.png" alt="img"></p><p>RxJava中的实现叫<code>concat</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable" target="_blank" rel="noopener">concat(Observable)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable, rx.Observable" target="_blank" rel="noopener">concat(Observable,Observable) </a>)</li></ul><p>还有一个实例方法叫<code>concatWith</code>，这两者是等价的：<code>Observable.concat(a,b)</code>和<code>a.concatWith(b)</code>。</p><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>按顺序对Observable发射的每项数据应用一个函数并发射最终的值</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/reduce.c.png" alt="reduce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/reduce.c.png" alt="img"></p><p><code>Reduce</code>操作符对原始Observable发射数据的第一项应用一个函数，然后再将这个函数的返回值与第二项数据一起传递给函数，以此类推，持续这个过程知道原始Observable发射它的最后一项数据并终止，此时<code>Reduce</code>返回的Observable发射这个函数返回的最终值。</p><p>在其它场景中，这种操作有时被称为<code>累积</code>，<code>聚集</code>，<code>压缩</code>，<code>折叠</code>，<code>注射</code>等。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/reduce.png" alt="reduce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/reduce.png" alt="img"></p><p>注意如果原始Observable没有发射任何数据，<code>reduce</code>抛出异常<code>IllegalArgumentException</code>。</p><p><code>reduce</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#reduce(rx.functions.Func2" target="_blank" rel="noopener">reduce(Func2)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/reduceSeed.png" alt="reduce"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/reduceSeed.png" alt="img"></p><p>还有一个版本的<code>reduce</code>额外接受一个种子参数。注意传递一个值为<code>null</code>的种子是合法的，但是与不传种子参数的行为是不同的。如果你传递了种子参数，并且原始Observable没有发射任何数据，<code>reduce</code>操作符将发射这个种子值然后正常终止，而不是抛异常。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#reduce(R, rx.functions.Func2" target="_blank" rel="noopener">reduce(R,Func2)</a>)</li></ul><p>提示：不建议使用<code>reduce</code>收集发射的数据到一个可变的数据结构，那种场景你应该使用<code>collect</code>。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/collect.png" alt="collect"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/collect.png" alt="img"></p><p><code>collect</code>与<code>reduce</code>类似，但它的目的是收集原始Observable发射的所有数据到一个可变的数据结构，<code>collect</code>生成的这个Observable会发射这项数据。它需要两个参数：</p><ol><li>一个函数返回可变数据结构</li><li>另一个函数，当传递给它这个数据结构和原始Observable发射的数据项时，适当地修改数据结构。</li></ol><p><code>collect</code>默认不在任何特定的调度器上执行。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0, rx.functions.Action2" target="_blank" rel="noopener">collect(Func0,Action2)</a>)</li></ul><h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="noopener">异步操作</a></h1><p>下面的这些操作符属于单独的<code>rxjava-async</code>模块，它们用于将同步对象转换为Observable。</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#start" target="_blank" rel="noopener"><strong>start( )</strong></a> — 创建一个Observable，它发射一个函数的返回值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#toAsync" target="_blank" rel="noopener"><strong>toAsync( ) or asyncAction( ) or asyncFunc( )</strong></a> — 将一个函数或者Action转换为已Observable，它执行这个函数并发射函数的返回值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#startFuture" target="_blank" rel="noopener"><strong>startFuture( )</strong></a> — 将一个返回Future的函数转换为一个Observable，它发射Future的返回值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#deferFuture" target="_blank" rel="noopener"><strong>deferFuture( )</strong></a> — 将一个返回Observable的Future转换为一个Observable，但是并不尝试获取这个Future返回的Observable，直到有订阅者订阅它</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#forEachFuture" target="_blank" rel="noopener"><strong>forEachFuture( )</strong></a> — 传递Subscriber方法给一个Subscriber，但是同时表现得像一个Future一样阻塞直到它完成</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#fromAction" target="_blank" rel="noopener"><strong>fromAction( )</strong></a> — 将一个Action转换为Observable，当一个订阅者订阅时，它执行这个action并发射它的返回值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#fromCallable" target="_blank" rel="noopener"><strong>fromCallable( )</strong></a> — 将一个Callable转换为Observable，当一个订阅者订阅时，它执行这个Callable并发射Callable的返回值，或者发射异常</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#fromRunnable" target="_blank" rel="noopener"><strong>fromRunnable( )</strong></a> — convert a Runnable into an Observable that invokes the runable and emits its result when a Subscriber subscribes将一个Runnable转换为Observable，当一个订阅者订阅时，它执行这个Runnable并发射Runnable的返回值</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Start.html#runAsync" target="_blank" rel="noopener"><strong>runAsync( )</strong></a> — 返回一个StoppableObservable，它发射某个Scheduler上指定的Action生成的多个actions</li></ul><h1 id="连接操作-1"><a href="#连接操作-1" class="headerlink" title="连接操作"></a>连接操作</h1><p>这一节解释<a href="http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html" target="_blank" rel="noopener"><code>ConnectableObservable</code></a> 和它的子类以及它们的操作符：</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Connect.html" target="_blank" rel="noopener"><strong>ConnectableObservable.connect( )</strong></a> — 指示一个可连接的Observable开始发射数据</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Publish.html" target="_blank" rel="noopener"><strong>Observable.publish( )</strong></a> — 将一个Observable转换为一个可连接的Observable</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Replay.html" target="_blank" rel="noopener"><strong>Observable.replay( )</strong></a> — 确保所有的订阅者看到相同的数据序列，即使它们在Observable开始发射数据之后才订阅</li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/RefCount.html" target="_blank" rel="noopener"><strong>ConnectableObservable.refCount( )</strong></a> — 让一个可连接的Observable表现得像一个普通的Observable</li></ul><p>一个可连接的Observable与普通的Observable差不多，除了这一点：可连接的Observable在被订阅时并不开始发射数据，只有在它的<code>connect()</code>被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.png" alt="publishConnect"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.png" alt="img"></p><p>The following example code shows two Subscribers subscribing to the same Observable. In the first case, they subscribe to an ordinary Observable; in the second case, they subscribe to a Connectable Observable that only connects after both Subscribers subscribe. Note the difference in the output: 下面的示例代码展示了两个订阅者订阅同一个Observable的情况。第一种情形，它们订阅一个普通的Observable；第二种情形，它们订阅一个可连接的Observable，并且在两个都订阅后再连接。注意输出的不同：</p><p><strong>示例 #1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def firstMillion  = Observable.range( 1, 1000000 ).sample(7, java.util.concurrent.TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">firstMillion.subscribe(</span><br><span class="line">   &#123; println(&quot;Subscriber #1:&quot; + it); &#125;,       // onNext</span><br><span class="line">   &#123; println(&quot;Error: &quot; + it.getMessage()); &#125;, // onError</span><br><span class="line">   &#123; println(&quot;Sequence #1 complete&quot;); &#125;       // onCompleted</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">firstMillion.subscribe(</span><br><span class="line">    &#123; println(&quot;Subscriber #2:&quot; + it); &#125;,       // onNext</span><br><span class="line">    &#123; println(&quot;Error: &quot; + it.getMessage()); &#125;, // onError</span><br><span class="line">    &#123; println(&quot;Sequence #2 complete&quot;); &#125;       // onCompleted</span><br><span class="line">);</span><br><span class="line">Subscriber #1:211128</span><br><span class="line">Subscriber #1:411633</span><br><span class="line">Subscriber #1:629605</span><br><span class="line">Subscriber #1:841903</span><br><span class="line">Sequence #1 complete</span><br><span class="line">Subscriber #2:244776</span><br><span class="line">Subscriber #2:431416</span><br><span class="line">Subscriber #2:621647</span><br><span class="line">Subscriber #2:826996</span><br><span class="line">Sequence #2 complete</span><br></pre></td></tr></table></figure><p><strong>示例 #2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def firstMillion  = Observable.range( 1, 1000000 ).sample(7, java.util.concurrent.TimeUnit.MILLISECONDS).publish();</span><br><span class="line"></span><br><span class="line">firstMillion.subscribe(</span><br><span class="line">   &#123; println(&quot;Subscriber #1:&quot; + it); &#125;,       // onNext</span><br><span class="line">   &#123; println(&quot;Error: &quot; + it.getMessage()); &#125;, // onError</span><br><span class="line">   &#123; println(&quot;Sequence #1 complete&quot;); &#125;       // onCompleted</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">firstMillion.subscribe(</span><br><span class="line">   &#123; println(&quot;Subscriber #2:&quot; + it); &#125;,       // onNext</span><br><span class="line">   &#123; println(&quot;Error: &quot; + it.getMessage()); &#125;, // onError</span><br><span class="line">   &#123; println(&quot;Sequence #2 complete&quot;); &#125;       // onCompleted</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">firstMillion.connect();</span><br><span class="line">Subscriber #2:208683</span><br><span class="line">Subscriber #1:208683</span><br><span class="line">Subscriber #2:432509</span><br><span class="line">Subscriber #1:432509</span><br><span class="line">Subscriber #2:644270</span><br><span class="line">Subscriber #1:644270</span><br><span class="line">Subscriber #2:887885</span><br><span class="line">Subscriber #1:887885</span><br><span class="line">Sequence #2 complete</span><br><span class="line">Sequence #1 complete</span><br></pre></td></tr></table></figure><h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>让一个可连接的Observable开始发射数据给订阅者</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.c.png" alt="connect"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.c.png" alt="img"></p><p>可连接的Observable (<em>connectable Observable</em>)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了<code>Connect</code>操作符时才会开始。用这个方法，你可以等待所有的观察者都订阅了Observable之后再开始发射数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.png" alt="connect"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.png" alt="img"></p><p>RxJava中<code>connect</code>是<code>ConnectableObservable</code>接口的一个方法，使用<code>publish</code>操作符可以将一个普通的Observable转换为一个<code>ConnectableObservable</code>。</p><p>调用<code>ConnectableObservable</code>的<code>connect</code>方法会让它后面的Observable开始给发射数据给订阅者。</p><p><code>connect</code>方法返回一个<code>Subscription</code>对象，可以调用它的<code>unsubscribe</code>方法让Observable停止发射数据给观察者。</p><p>即使没有任何订阅者订阅它，你也可以使用<code>connect</code>方法让一个Observable开始发射数据（或者开始生成待发射的数据）。这样，你可以将一个”冷”的Observable变为”热”的。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#connect(" target="_blank" rel="noopener">connect()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#connect(rx.functions.Action1" target="_blank" rel="noopener">connect(Action1)</a>)</li></ul><h2 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h2><p>将普通的Observable转换为可连接的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.c.png" alt="publish"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.c.png" alt="img"></p><p>可连接的Observable (<em>connectable Observable</em>)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了<code>Connect</code>操作符时才会开始。用这种方法，你可以在任何时候让一个Observable开始发射数据。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.png" alt="publish"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.png" alt="img"></p><p>RxJava的实现为<code>publish</code>。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#publish(" target="_blank" rel="noopener">publish()</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.f.png" alt="publish"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishConnect.f.png" alt="img"></p><p>有一个变体接受一个函数作为参数。这个函数用原始Observable发射的数据作为参数，产生一个新的数据作为<code>ConnectableObservable</code>给发射，替换原位置的数据项。实质是在签名的基础上添加一个<code>Map</code>操作。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#publish(rx.functions.Func1" target="_blank" rel="noopener">publish(Func1)</a>)</li></ul><h2 id="RefCount"><a href="#RefCount" class="headerlink" title="RefCount"></a>RefCount</h2><p>让一个可连接的Observable行为像普通的Observable</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishRefCount.c.png" alt="refCount"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishRefCount.c.png" alt="img"></p><p>可连接的Observable (<em>connectable Observable</em>)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了<code>Connect</code>操作符时才会开始。用这种方法，你可以在任何时候让一个Observable开始发射数据。</p><p><code>RefCount</code>操作符把从一个可连接的Observable连接和断开的过程自动化了。它操作一个可连接的Observable，返回一个普通的Observable。当第一个订阅者订阅这个Observable时，<code>RefCount</code>连接到下层的可连接Observable。<code>RefCount</code>跟踪有多少个观察者订阅它，直到最后一个观察者完成才断开与下层可连接Observable的连接。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishRefCount.png" alt="refCount"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/publishRefCount.png" alt="img"></p><p>RxJava中的实现为<code>refCount</code>，还有一个操作符叫<code>share</code>，它的作用等价于对一个Observable同时应用<code>publish</code>和<code>refCount</code>操作。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html#refCount(" target="_blank" rel="noopener">refCount()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#share(" target="_blank" rel="noopener">share()</a>)</li></ul><h2 id="Replay"><a href="#Replay" class="headerlink" title="Replay"></a>Replay</h2><p>保证所有的观察者收到相同的数据序列，即使它们在Observable开始发射数据之后才订阅</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/replay.c.png" alt="replay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/replay.c.png" alt="img"></p><p>可连接的Observable (<em>connectable Observable</em>)与普通的Observable差不多，不过它并不会在被订阅时开始发射数据，而是直到使用了<code>Connect</code>操作符时才会开始。用这种方法，你可以在任何时候让一个Observable开始发射数据。</p><p>如果在将一个Observable转换为可连接的Observable之前对它使用<code>Replay</code>操作符，产生的这个可连接Observable将总是发射完整的数据序列给任何未来的观察者，即使那些观察者在这个Observable开始给其它观察者发射数据之后才订阅。</p><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/replay.png" alt="replay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/replay.png" alt="img"></p><p>RxJava的实现为<code>replay</code>，它有多个接受不同参数的变体，有的可以指定<code>replay</code>的最大缓存数量，有的还可以指定调度器。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(" target="_blank" rel="noopener">replay()</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int" target="_blank" rel="noopener">replay(int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">replay(long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">replay(int,long,TimeUnit)</a>)</li></ul><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/replay.f.png" alt="replay"><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/replay.f.png" alt="img"></p><p>有一种 <code>replay</code>返回一个普通的Observable。它可以接受一个变换函数为参数，这个函数接受原始Observable发射的数据项为参数，返回结果Observable要发射的一项数据。因此，这个操作符其实是<code>replay</code>变换之后的数据项。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1" target="_blank" rel="noopener">replay(Func1)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1, int" target="_blank" rel="noopener">replay(Func1,int)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">replay(Func1,long,TimeUnit)</a>)</li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1, int, long, java.util.concurrent.TimeUnit" target="_blank" rel="noopener">replay(Func1,int,long,TimeUnit)</a>)</li></ul><h1 id="实现自己的操作符"><a href="#实现自己的操作符" class="headerlink" title="实现自己的操作符"></a>实现自己的操作符</h1><p>你可以实现你自己的Observable操作符，本文展示怎么做。</p><p>如果你的操作符是被用于<em>创造</em>一个Observable，而不是变换或者响应一个Observable，使用 <a href="http://reactivex.io/documentation/operators/create.html" target="_blank" rel="noopener"><code>create( )</code></a> 方法，不要试图手动实现 <code>Observable</code>。另外，你可以按照下面的用法说明创建一个自定义的操作符。</p><p>如果你的操作符是用于Observable发射的单独的数据项，按照下面的说明做：<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Implementing-Your-Own-Operators#序列操作符" target="_blank" rel="noopener"><em>Sequence Operators</em></a> 。如果你的操作符是用于变换Observable发射的整个数据序列，按照这个说明做：<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Implementing-Your-Own-Operators#变换操作符" target="_blank" rel="noopener"><em>Transformational Operators</em></a> 。</p><p><strong>提示：</strong> 在一个类似于Groovy的语言Xtend中，你可以以 <em>extension methods</em> 的方式实现你自己的操作符 ,不使用本文的方法，它们也可以链式调用。详情参见 <a href="http://mnmlst-dvlpr.blogspot.de/2014/07/rxjava-and-xtend.html" target="_blank" rel="noopener">RxJava and Xtend</a></p><h1 id="序列操作符"><a href="#序列操作符" class="headerlink" title="序列操作符"></a>序列操作符</h1><p>下面的例子向你展示了怎样使用<code>lift( )</code>操作符将你的自定义操作符（在这个例子中是 <code>myOperator</code>）与标准的RxJava操作符（如<code>ofType</code>和<code>map</code>）一起使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fooObservable = barObservable.ofType(Integer).map(&#123;it*2&#125;).lift(new MyOperator&lt;T&gt;()).map(&#123;&quot;transformed by myOperator: &quot; + it&#125;);</span><br></pre></td></tr></table></figure><p>下面这部分向你展示了你的操作符的脚手架形式，以便它能正确的与<code>lift()</code>搭配使用。</p><h2 id="实现你的操作符"><a href="#实现你的操作符" class="headerlink" title="实现你的操作符"></a>实现你的操作符</h2><p>将你的自定义操作符定义为实现了 <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html" target="_blank" rel="noopener"><code>Operator</code></a> 接口的一个公开类, 就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MyOperator&lt;T&gt; implements Operator&lt;T&gt; &#123;</span><br><span class="line">  public MyOperator( /* any necessary params here */ ) &#123;</span><br><span class="line">    /* 这里添加必要的初始化代码 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; s) &#123;</span><br><span class="line">    return new Subscriber&lt;t&gt;(s) &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onCompleted() &#123;</span><br><span class="line">        /* 这里添加你自己的onCompleted行为，或者仅仅传递完成通知： */</span><br><span class="line">        if(!s.isUnsubscribed()) &#123;</span><br><span class="line">          s.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onError(Throwable t) &#123;</span><br><span class="line">        /* 这里添加你自己的onError行为, 或者仅仅传递错误通知：*/</span><br><span class="line">        if(!s.isUnsubscribed()) &#123;</span><br><span class="line">          s.onError(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void onNext(T item) &#123;</span><br><span class="line">        /* 这个例子对结果的每一项执行排序操作，然后返回这个结果 */</span><br><span class="line">        if(!s.isUnsubscribed()) &#123;</span><br><span class="line">          transformedItem = myOperatorTransformOperation(item);</span><br><span class="line">          s.onNext(transformedItem);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h1><p>下面的例子向你展示了怎样使用 <code>compose( )</code> 操作符将你得自定义操作符（在这个例子中，是一个名叫<code>myTransformer</code>的操作符，它将一个发射整数的Observable转换为发射字符串的）与标准的RxJava操作符（如<code>ofType</code>和<code>map</code>）一起使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fooObservable = barObservable.ofType(Integer).map(&#123;it*2&#125;).compose(new MyTransformer&lt;Integer,String&gt;()).map(&#123;&quot;transformed by myOperator: &quot; + it&#125;);</span><br></pre></td></tr></table></figure><p>下面这部分向你展示了你的操作符的脚手架形式，以便它能正确的与<code>compose()</code>搭配使用。</p><h2 id="实现你的变换器"><a href="#实现你的变换器" class="headerlink" title="实现你的变换器"></a>实现你的变换器</h2><p>将你的自定义操作符定义为实现了 <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.Transformer.html" target="_blank" rel="noopener"><code>Transformer</code></a> 接口的一个公开类，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyTransformer&lt;Integer,String&gt; implements Transformer&lt;Integer,String&gt; &#123;</span><br><span class="line">  public MyTransformer( /* any necessary params here */ ) &#123;</span><br><span class="line">    /* 这里添加必要的初始化代码 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Observable&lt;String&gt; call(Observable&lt;Integer&gt; source) &#123;</span><br><span class="line">    /* </span><br><span class="line">     * 这个简单的例子Transformer应用一个map操作，</span><br><span class="line">     * 这个map操作将发射整数变换为发射整数的字符串表示。</span><br><span class="line">     */</span><br><span class="line">    return source.map( new Func1&lt;Integer,String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public String call(Integer t1) &#123;</span><br><span class="line">        return String.valueOf(t1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参见-1"><a href="#参见-1" class="headerlink" title="参见"></a>参见</h2><ul><li><a href="http://blog.danlew.net/2015/03/02/dont-break-the-chain/" target="_blank" rel="noopener">“Don’t break the chain: use RxJava’s compose() operator”</a> by Dan Lew</li></ul><h1 id="其它需要考虑的"><a href="#其它需要考虑的" class="headerlink" title="其它需要考虑的"></a>其它需要考虑的</h1><ul><li><p>在发射任何数据（或者通知）给订阅者之前，你的序列操作符可能需要检查它的 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Observable#unsubscribing" target="_blank" rel="noopener"><code>Subscriber.isUnsubscribed( )</code></a> 状态，如果没有订阅者了，没必要浪费时间生成数据项。</p></li><li><p>请注意：你的序列操作符必须复合Observable协议的核心原则：</p><ul><li>它可能调用订阅者的 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Observable#onnext-oncompleted-and-onerror" target="_blank" rel="noopener"><code>onNext( )</code></a> 方法任意次，但是这些调用必须是不重叠的。</li><li>它只能调用订阅者的 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Observable#onnext-oncompleted-and-onerror" target="_blank" rel="noopener"><code>onCompleted( )</code></a> 或 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Observable#onnext-oncompleted-and-onerror" target="_blank" rel="noopener"><code>onError( )</code></a> 正好一次，但不能都调用，而且不能在这之后调用订阅者的 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Observable#onnext-oncompleted-and-onerror" target="_blank" rel="noopener"><code>onNext( )</code></a> 方法。</li><li>如果你不能保证你得操作符遵从这两个原则，你可以给它添加 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Observable-Utility-Operators#serialize" target="_blank" rel="noopener"><code>serialize( )</code></a> 操作符，它会强制保持正确的行为。</li></ul></li><li><p>请关注这里 <a href="https://github.com/ReactiveX/RxJava/issues/1962" target="_blank" rel="noopener">Issue #1962</a> &amp;mdash；需要有一个计划创建一个测试脚手架，你可以用它来写测试验证你的新操作符遵从了Observable协议。</p></li><li><p>不要让你的操作符阻塞别的操作。</p></li><li><p>When possible, you should compose new operators by combining existing operators, rather than implementing them with new code. RxJava itself does this with some of its standard operators, for example:</p></li><li><p>如果可能，你应该组合现有的操作符创建你的新操作符，而不是从零开始实现它。RxJava自身的标准操作符也是这样做的，例如：</p><ul><li><a href="http://reactivex.io/documentation/operators/first.html" target="_blank" rel="noopener"><code>first( )</code></a> 被定义为 <code>take(1).single( )</code></li><li><a href="http://reactivex.io/documentation/operators/ignoreelements.html" target="_blank" rel="noopener"><code>ignoreElements( )</code></a> 被定义为 <code>filter(alwaysFalse( ))</code></li><li><a href="http://reactivex.io/documentation/operators/reduce.html" target="_blank" rel="noopener"><code>reduce(a)</code></a> 被定义为 <code>scan(a).last( )</code></li></ul></li><li><p>如果你的操作符使用了函数或者lambda表达式作为参数，请注意它们可能是异常的来源，而且要准备好捕获这些异常，并且使用</p></li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onError()</span><br></pre></td></tr></table></figure><p>  通知订阅者。</p><ul><li>某些异常被认为是致命的，对它们来说，调用 <code>onError()</code>毫无意义，那样或者是无用的，或者只是对问题的妥协。你可以使用 <code>Exceptions.throwIfFatal(throwable)</code> 方法过滤掉这些致命的异常，并重新抛出它们，而不是试图发射关于它们的通知。</li></ul><ul><li><p>一般说来，一旦发生错误应立即通知订阅者，而不是首先尝试发射更多的数据。</p></li><li><p>请注意 <code>null</code> 可能是Observable发射的一个合法数据。频繁发生错误的一个来源是：测试一些变量并且将持有一个非 <code>null</code> 值作为是否发射了数据的替代。一个值为 <code>null</code> 的数据仍然是一个发射数据项，它与没有发射任何东西是不能等同的。</p></li><li><p>想让你的操作符在反压(<em>backpressure</em>)场景中变得得好可能会非常棘手。可以参考Dávid Karnok的博客 <a href="http://akarnokd.blogspot.hu/" target="_blank" rel="noopener">Advanced RxJava</a>，这里有一个涉及到的各种因素和怎样处理它们的很值得看的讨论。</p></li></ul><p>插件让你可以用多种方式修改RxJava的默认行为：</p><ul><li>修改默认的计算、IO和新线程调度器集合</li><li>为RxJava可能遇到的特殊错误注册一个错误处理器</li><li>注册一个函数记录一些常规RxJava活动的发生</li></ul><h1 id="RxJavaSchedulersHook"><a href="#RxJavaSchedulersHook" class="headerlink" title="RxJavaSchedulersHook"></a>RxJavaSchedulersHook</h1><p>这个插件让你可以使用你选择的调度器覆盖默认的计算、IO和新线程调度 (<code>Scheduler</code>)，要做到这些，需要继承 <code>RxJavaSchedulersHook</code> 类并覆写这些方法：</p><ul><li><code>Scheduler getComputationScheduler( )</code></li><li><code>Scheduler getIOScheduler( )</code></li><li><code>Scheduler getNewThreadScheduler( )</code></li><li><code>Action0 onSchedule(action)</code></li></ul><p>然后是下面这些步骤：</p><ol><li>创建一个你实现的 <code>RxJavaSchedulersHook</code> 子类的对象。</li><li>使用 <code>RxJavaPlugins.getInstance( )</code> 获取全局的RxJavaPlugins对象。</li><li>将你的默认调度器对象传递给 <code>RxJavaPlugins</code> 的 <code>registerSchedulersHook( )</code> 方法。</li></ol><p>完成这些后，RxJava会开始使用你的方法返回的调度器，而不是内置的默认调度器。</p><h1 id="RxJavaErrorHandler"><a href="#RxJavaErrorHandler" class="headerlink" title="RxJavaErrorHandler"></a>RxJavaErrorHandler</h1><p>这个插件让你可以注册一个函数处理传递给 <code>Subscriber.onError(Throwable)</code> 的错误。要做到这一点，需要继承 <code>RxJavaErrorHandler</code> 类并覆写这个方法：</p><ul><li><code>void handleError(Throwable e)</code></li></ul><p>然后是下面这些步骤：</p><ol><li>创建一个你实现的 <code>RxJavaErrorHandler</code> 子类的对象。</li><li>使用 <code>RxJavaPlugins.getInstance( )</code> 获取全局的RxJavaPlugins对象。</li><li>将你的错误处理器对象传递给 <code>RxJavaPlugins</code> 的 <code>registerErrorHandler( )</code> 方法。</li></ol><p>完成这些后，RxJava会开始使用你的错误处理器处理传递给 <code>Subscriber.onError(Throwable)</code> 的错误。</p><h1 id="RxJavaObservableExecutionHook"><a href="#RxJavaObservableExecutionHook" class="headerlink" title="RxJavaObservableExecutionHook"></a>RxJavaObservableExecutionHook</h1><p>这个插件让你可以注册一个函数用于记录日志或者性能数据收集，RxJava在某些常规活动时会调用它。要做到这一点，需要继承 <code>RxJavaObservableExecutionHook</code> 类并覆写这些方法：</p><table><thead><tr><th>方法</th><th>何时调用</th></tr></thead><tbody><tr><td><code>onCreate( )</code></td><td>在 <code>Observable.create( )</code>方法中</td></tr><tr><td><code>onSubscribeStart( )</code></td><td>在 <code>Observable.subscribe( )</code>之前立刻</td></tr><tr><td><code>onSubscribeReturn( )</code></td><td>在 <code>Observable.subscribe( )</code>之后立刻</td></tr><tr><td><code>onSubscribeError( )</code></td><td>在<code>Observable.subscribe( )</code>执行失败时</td></tr><tr><td><code>onLift( )</code></td><td>在<code>Observable.lift( )</code>方法中</td></tr></tbody></table><p>然后是下面这些步骤：</p><ol><li>创建一个你实现的 <code>RxJavaObservableExecutionHook</code> 子类的对象。</li><li>使用 <code>RxJavaPlugins.getInstance( )</code> 获取全局的RxJavaPlugins对象。</li><li>将你的Hook对象传递给 <code>RxJavaPlugins</code> 的 <code>registerObservableExecutionHook( )</code> 方法。</li></ol><p>When you do this, RxJava will begin to call your functions when it encounters the specific conditions they were designed to take note of. 完成这些后，在满足某些特殊的条件时，RxJava会开始调用你的方法。</p><h1 id="背压问题"><a href="#背压问题" class="headerlink" title="背压问题"></a>背压问题</h1><p><strong>背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略</strong></p><p>简而言之，<strong>背压是流速控制的一种策略</strong>。</p><p>需要强调两点：</p><ul><li>背压策略的一个前提是<strong>异步环境</strong>，也就是说，被观察者和观察者处在不同的线程环境中。</li><li>背压（Backpressure）并不是一个像flatMap一样可以在程序中直接使用的操作符，他只是一种控制事件流速的策略。</li></ul><h1 id="响应式拉取（reactive-pull）"><a href="#响应式拉取（reactive-pull）" class="headerlink" title="响应式拉取（reactive pull）"></a>响应式拉取（reactive pull）</h1><p>首先我们回忆之前那篇《关于Rxjava最友好的文章》，里面其实提到，在RxJava的观察者模型中，<strong>被观察者是主动的推送数据给观察者，观察者是被动接收的</strong>。而响应式拉取则反过来，<strong>观察者主动从被观察者那里去拉取数据，而被观察者变成被动的等待通知再发送数据</strong>。</p><p>结构示意图如下：</p><p><a href="https://camo.githubusercontent.com/9fdb9f312a133e65f0a104f908e3dc505f0b4872/68747470733a2f2f646e2d6d686b65306b75762e71626f782e6d652f34356161613135356633623465643937366136352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9fdb9f312a133e65f0a104f908e3dc505f0b4872/68747470733a2f2f646e2d6d686b65306b75762e71626f782e6d652f34356161613135356633623465643937366136352e706e67" alt="img"></a></p><p>观察者可以根据自身实际情况按需拉取数据，而不是被动接收（也就相当于告诉上游观察者把速度慢下来），最终实现了上游被观察者发送事件的速度的控制，实现了背压的策略。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class FlowableOnBackpressureBufferStategy&#123;</span><br><span class="line">...</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(T t) &#123;</span><br><span class="line">            if (done) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean callOnOverflow = false;</span><br><span class="line">            boolean callError = false;</span><br><span class="line">            Deque&lt;T&gt; dq = deque;</span><br><span class="line">            synchronized (dq) &#123;</span><br><span class="line">               if (dq.size() == bufferSize) &#123;</span><br><span class="line">                   switch (strategy) &#123;</span><br><span class="line">                   case DROP_LATEST:</span><br><span class="line">                       dq.pollLast();</span><br><span class="line">                       dq.offer(t);</span><br><span class="line">                       callOnOverflow = true;</span><br><span class="line">                       break;</span><br><span class="line">                   case DROP_OLDEST:</span><br><span class="line">                       dq.poll();</span><br><span class="line">                       dq.offer(t);</span><br><span class="line">                       callOnOverflow = true;</span><br><span class="line">                       break;</span><br><span class="line">                   default:</span><br><span class="line">                       // signal error</span><br><span class="line">                       callError = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   dq.offer(t);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (callOnOverflow) &#123;</span><br><span class="line">                if (onOverflow != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        onOverflow.run();</span><br><span class="line">                    &#125; catch (Throwable ex) &#123;</span><br><span class="line">                        Exceptions.throwIfFatal(ex);</span><br><span class="line">                        s.cancel();</span><br><span class="line">                        onError(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (callError) &#123;</span><br><span class="line">                s.cancel();</span><br><span class="line">                onError(new MissingBackpressureException());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                drain();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段源码中，根据不同的背压策略进行了不同的处理措施，当然这只是列举了一段关于buffer背压策略的例子。</p><h1 id="根源"><a href="#根源" class="headerlink" title="根源"></a>根源</h1><p>产生背压问题的根源就是上游发送速度与下游的处理速度不均导致的，所以如果想要解决这个问题就需要通过匹配两个速率达到解决这个背压根源的措施。</p><p>通常有两个策略可供使用：</p><ol><li>从数量上解决，对数据进行采样</li><li>从速度上解决，降低发送事件的速率</li><li>利用flowable和subscriber</li></ol><h1 id="使用Flowable"><a href="#使用Flowable" class="headerlink" title="使用Flowable"></a>使用Flowable</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</span><br><span class="line">                Log.d(TAG, &quot;emit 1&quot;);</span><br><span class="line">                emitter.onNext(1);</span><br><span class="line">                Log.d(TAG, &quot;emit 2&quot;);</span><br><span class="line">                emitter.onNext(2);</span><br><span class="line">                Log.d(TAG, &quot;emit 3&quot;);</span><br><span class="line">                emitter.onNext(3);</span><br><span class="line">                Log.d(TAG, &quot;emit complete&quot;);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, BackpressureStrategy.ERROR); //增加了一个参数</span><br><span class="line"></span><br><span class="line">        Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">                s.request(Long.MAX_VALUE);  //注意这句代码</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">                 Log.w(TAG, &quot;onError: &quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">                Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        upstream.subscribe(downstream);</span><br></pre></td></tr></table></figure><p>我们注意到这次和<code>Observable</code>有些不同. 首先是创建<code>Flowable</code>的时候增加了一个参数, 这个参数是用来选择背压,也就是出现上下游流速不均衡的时候应该怎么处理的办法, 这里我们直接用<code>BackpressureStrategy.ERROR</code>这种方式, 这种方式会在出现上下游流速不均衡的时候直接抛出一个异常,这个异常就是著名的<code>MissingBackpressureException</code>. 其余的策略后面再来讲解.</p><p>另外的一个区别是在下游的<code>onSubscribe</code>方法中传给我们的不再是<code>Disposable</code>了, 而是<code>Subscription</code>, 它俩有什么区别呢, 首先它们都是上下游中间的一个开关, 之前我们说调用<code>Disposable.dispose()</code>方法可以切断水管, 同样的调用<code>Subscription.cancel()</code>也可以切断水管, 不同的地方在于<code>Subscription</code>增加了一个<code>void request(long n)</code>方法, 这个方法有什么用呢, 在上面的代码中也有这么一句代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.request(Long.MAX_VALUE);</span><br></pre></td></tr></table></figure><p>这是因为<code>Flowable</code>在设计的时候采用了一种新的思路也就是<code>响应式拉取</code>的方式来更好的解决上下游流速不均衡的问题, 与我们之前所讲的<code>控制数量</code>和<code>控制速度</code>不太一样, 这种方式用通俗易懂的话来说就好比是<code>叶问打鬼子</code>, 我们把<code>上游</code>看成<code>小日本</code>, 把<code>下游</code>当作<code>叶问</code>, 当调用<code>Subscription.request(1)</code>时, <code>叶问</code>就说<code>我要打一个!</code> 然后<code>小日本</code>就拿出<code>一个鬼子</code>给叶问, 让他打, 等叶问打死这个鬼子之后, 再次调用<code>request(10)</code>, 叶问就又说<code>我要打十个!</code> 然后小日本又派出<code>十个鬼子</code>给叶问, 然后就在边上看热闹, 看叶问能不能打死十个鬼子, 等叶问打死十个鬼子后再继续要鬼子接着打…</p><p>所以我们把request当做是一种能力, 当成<code>下游处理事件</code>的能力, 下游能处理几个就告诉上游我要几个, 这样只要上游根据下游的处理能力来决定发送多少事件, 就不会造成一窝蜂的发出一堆事件来, 从而导致OOM. 这也就完美的解决之前我们所学到的两种方式的缺陷, 过滤事件会导致事件丢失, 减速又可能导致性能损失. 而这种方式既解决了事件丢失的问题, 又解决了速度的问题, 完美 !</p><h1 id="同步情况"><a href="#同步情况" class="headerlink" title="同步情况"></a>同步情况</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;                         </span><br><span class="line">    @Override                                                                    </span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; </span><br><span class="line">        for (int i = 0; ; i++) &#123;   //无限循环发事件                                              </span><br><span class="line">            emitter.onNext(i);                                                   </span><br><span class="line">        &#125;                                                                        </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">&#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;                                           </span><br><span class="line">    @Override                                                                    </span><br><span class="line">    public void accept(Integer integer) throws Exception &#123;                       </span><br><span class="line">        Thread.sleep(2000);                                                      </span><br><span class="line">        Log.d(TAG, &quot;&quot; + integer);                                                </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当上下游工作在<code>同一个线程</code>中时, 这时候是一个<code>同步</code>的订阅关系, 也就是说<code>上游</code>每发送一个事件<code>必须</code>等到<code>下游</code>接收处理完了以后才能接着发送下一个事件.</p><p>同步与异步的区别就在于有没有缓存发送事件的缓冲区。</p><h1 id="异步情况"><a href="#异步情况" class="headerlink" title="异步情况"></a>异步情况</h1><p>通过subscribeOn和observeOn来确定对应的线程，达到异步的效果，异步时会有一个对应的缓存区来换从从上游发送的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum BackpressureStrategy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * OnNext events are written without any buffering or dropping.</span><br><span class="line">     * Downstream has to deal with any overflow.</span><br><span class="line">     * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.</span><br><span class="line">     */</span><br><span class="line">    MISSING,</span><br><span class="line">    /**</span><br><span class="line">     * Signals a MissingBackpressureException in case the downstream can&apos;t keep up.</span><br><span class="line">     */</span><br><span class="line">    ERROR,</span><br><span class="line">    /**</span><br><span class="line">     * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.</span><br><span class="line">     */</span><br><span class="line">    BUFFER,</span><br><span class="line">    /**</span><br><span class="line">     * Drops the most recent onNext value if the downstream can&apos;t keep up.</span><br><span class="line">     */</span><br><span class="line">    DROP,</span><br><span class="line">    /**</span><br><span class="line">     * Keeps only the latest onNext value, overwriting any previous value if the</span><br><span class="line">     * downstream can&apos;t keep up.</span><br><span class="line">     */</span><br><span class="line">    LATEST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背压策略：</p><ol><li>error， 缓冲区大概在128</li><li>buffer， 缓冲区在1000左右</li><li>drop， 把存不下的事件丢弃</li><li>latest， 只保留最新的</li><li>missing, 缺省设置，不做任何操作</li></ol><p>上游从哪里得知下游的处理能力呢？我们来看看上游最重要的部分，肯定就是<code>FlowableEmitter</code>了啊，我们就是通过它来发送事件的啊，来看看它的源码吧(别紧张，它的代码灰常简单)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123;</span><br><span class="line">    void setDisposable(Disposable s);</span><br><span class="line">    void setCancellable(Cancellable c);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The current outstanding request amount.</span><br><span class="line">     * &lt;p&gt;This method is thread-safe.</span><br><span class="line">     * @return the current outstanding request amount</span><br><span class="line">     */</span><br><span class="line">    long requested();</span><br><span class="line"></span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    FlowableEmitter&lt;T&gt; serialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlowableEmitter是个接口，继承Emitter，Emitter里面就是我们的onNext(),onComplete()和onError()三个方法。我们看到FlowableEmitter中有这么一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long requested();</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/0b495034ad2ac1a38f9d28c48b5251187bb99057/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313030383435332d306234303863663664323336303637372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0b495034ad2ac1a38f9d28c48b5251187bb99057/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313030383435332d306234303863663664323336303637372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p><p>同步request.png</p><p>这张图的意思就是当上下游在同一个线程中的时候，在<code>下游</code>调用request(n)就会直接改变<code>上游</code>中的requested的值，多次调用便会叠加这个值，而上游每发送一个事件之后便会去减少这个值，当这个值减少至0的时候，继续发送事件便会抛异常了。</p><p><a href="https://camo.githubusercontent.com/a0d23f12ff69fb80643a03e81a8ec6a8e9d7286d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313030383435332d366165363134643963623339323763622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a0d23f12ff69fb80643a03e81a8ec6a8e9d7286d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313030383435332d366165363134643963623339323763622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p><p>异步request.png</p><p>可以看到，当上下游工作在不同的线程里时，每一个线程里都有一个requested，而我们调用request（1000）时，实际上改变的是下游主线程中的requested，而上游中的requested的值是由RxJava内部调用request(n)去设置的，这个调用会在合适的时候自动触发。</p><h1 id="Rxjava实例开发应用"><a href="#Rxjava实例开发应用" class="headerlink" title="Rxjava实例开发应用"></a>Rxjava实例开发应用</h1><ol><li>网络请求处理(轮询，嵌套，出错重连)</li><li>功能防抖</li><li>从多级缓存获取数据</li><li>合并数据源</li><li>联合判断</li><li>与 Retrofit,RxBinding,EventBus结合使用</li></ol><h1 id="Rxjava原理"><a href="#Rxjava原理" class="headerlink" title="Rxjava原理"></a>Rxjava原理</h1><ol><li>Scheduler线程切换工作原理</li><li>数据的发送与接收(观察者模式)</li><li>lift的工作原理</li><li>map的工作原理</li><li>flatMap的工作原理</li><li>merge的工作原理</li><li>concat的工作原理</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rxjava&quot;&gt;&lt;a href=&quot;#rxjava&quot; class=&quot;headerlink&quot; title=&quot;rxjava&quot;&gt;&lt;/a&gt;rxjava&lt;/h1&gt;&lt;h2 id=&quot;Rx介绍&quot;&gt;&lt;a href=&quot;#Rx介绍&quot; class=&quot;headerlink&quot; title=&quot;Rx介绍&quot;&gt;&lt;/a&gt;Rx介绍&lt;/h2&gt;&lt;h3 id=&quot;ReactiveX的历史&quot;&gt;&lt;a href=&quot;#ReactiveX的历史&quot; class=&quot;headerlink&quot; title=&quot;ReactiveX的历史&quot;&gt;&lt;/a&gt;ReactiveX的历史&lt;/h3&gt;&lt;p&gt;ReactiveX是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了，Rx的大部分语言库由ReactiveX这个组织负责维护，比较流行的有RxJava/RxJS/Rx.NET，社区网站是 &lt;a href=&quot;http://reactivex.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;reactivex.io&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;什么是ReactiveX&quot;&gt;&lt;a href=&quot;#什么是ReactiveX&quot; class=&quot;headerlink&quot; title=&quot;什么是ReactiveX&quot;&gt;&lt;/a&gt;什么是ReactiveX&lt;/h3&gt;&lt;p&gt;微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。&lt;/p&gt;
&lt;p&gt;ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。&lt;/p&gt;
&lt;h3 id=&quot;ReactiveX的应用&quot;&gt;&lt;a href=&quot;#ReactiveX的应用&quot; class=&quot;headerlink&quot; title=&quot;ReactiveX的应用&quot;&gt;&lt;/a&gt;ReactiveX的应用&lt;/h3&gt;&lt;p&gt;很多公司都在使用ReactiveX，例如Microsoft、Netflix、Github、Trello、SoundCloud。&lt;/p&gt;
&lt;h3 id=&quot;ReactiveX宣言&quot;&gt;&lt;a href=&quot;#ReactiveX宣言&quot; class=&quot;headerlink&quot; title=&quot;ReactiveX宣言&quot;&gt;&lt;/a&gt;ReactiveX宣言&lt;/h3&gt;&lt;p&gt;ReactiveX不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。&lt;/p&gt;
&lt;h2 id=&quot;Rx模式&quot;&gt;&lt;a href=&quot;#Rx模式&quot; class=&quot;headerlink&quot; title=&quot;Rx模式&quot;&gt;&lt;/a&gt;Rx模式&lt;/h2&gt;&lt;h3 id=&quot;使用观察者模式&quot;&gt;&lt;a href=&quot;#使用观察者模式&quot; class=&quot;headerlink&quot; title=&quot;使用观察者模式&quot;&gt;&lt;/a&gt;使用观察者模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建：Rx可以方便的创建事件流和数据流&lt;/li&gt;
&lt;li&gt;组合：Rx使用查询式的操作符组合和变换数据流&lt;/li&gt;
&lt;li&gt;监听：Rx可以订阅任何可观察的数据流并执行操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;简化代码&quot;&gt;&lt;a href=&quot;#简化代码&quot; class=&quot;headerlink&quot; title=&quot;简化代码&quot;&gt;&lt;/a&gt;简化代码&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态&lt;/li&gt;
&lt;li&gt;简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码&lt;/li&gt;
&lt;li&gt;异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制&lt;/li&gt;
&lt;li&gt;轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用Observable的优势&quot;&gt;&lt;a href=&quot;#使用Observable的优势&quot; class=&quot;headerlink&quot; title=&quot;使用Observable的优势&quot;&gt;&lt;/a&gt;使用Observable的优势&lt;/h3&gt;&lt;p&gt;Rx扩展了观察者模式用于支持数据和事件序列，添加了一些操作符，它让你可以声明式的组合这些序列，而无需关注底层的实现：如线程、同步、线程安全、并发数据结构和非阻塞IO。&lt;/p&gt;
&lt;p&gt;Observable通过使用最佳的方式访问异步数据序列填补了这个间隙&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;单个数据&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;多个数据&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T getData()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt; getData()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Future&amp;lt;T&amp;gt; getData()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Observable&amp;lt;T&amp;gt; getData()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Rx的Observable模型让你可以像使用集合数据一样操作异步事件流，对异步事件流使用各种简单、可组合的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="Rxjava" scheme="http://darryrzhong.xyz/tags/Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Android之热修复核心原理(ClassLoader类加载)</title>
    <link href="http://darryrzhong.xyz/2019/09/15/Android%E4%B9%8B%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-ClassLoader%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://darryrzhong.xyz/2019/09/15/Android之热修复核心原理-ClassLoader类加载/</id>
    <published>2019-09-15T08:56:21.000Z</published>
    <updated>2020-03-09T05:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-热修复核心原理，ClassLoader类加载"><a href="#Android-热修复核心原理，ClassLoader类加载" class="headerlink" title="Android 热修复核心原理，ClassLoader类加载"></a>Android 热修复核心原理，ClassLoader类加载</h1><p>[TOC]</p><p>​    又在写bug？这句话虽然是句玩笑话，但是也正因为我们是人不是神，但也不能面面俱到，什么都考虑完美，出现bug是不可避免的。那么对于android我们出现了Bug怎么办？</p><p>​    早期遇到Bug我们一般会紧急发布了一个版本。然而这个Bug可能就是简简单单的一行代码，为了这一行代码，进行全量或者增量更新迭代一个版本，未免有点大材小用了。而且新版本的普及需要时间，而且如果这次的新版本又有个小问题，怎么办？</p><p>​    那么为了解决这一个问题，热修复出现了。</p><p>​    热修复，现在大家应该都不陌生。从16年开始开始，热修复技术在 Android 技术社区热了一阵子，这种不用发布新版本就可以修复线上 bug 的技术看起来非常黑科技。</p><blockquote><p>本节课的目的并不在于热修复本身，主要是通过热修复这个案例熟悉其核心：类加载机制。（后续会有更详细课程讲解热修复）</p></blockquote><h2 id="ART-和-Dalvik"><a href="#ART-和-Dalvik" class="headerlink" title="ART 和 Dalvik"></a>ART 和 Dalvik</h2><p>​    <strong>DVM</strong>也是实现了<strong>JVM</strong>规范的一个虚拟器，默认使用CMS垃圾回收器，但是与JVM运行 Class 字节码不同，DVM 执行 <strong>Dex(Dalvik Executable Format)</strong> ——专为 Dalvik 设计的一种压缩格式。Dex 文件是很多 .class 文件处理压缩后的产物，最终可以在 Android 运行时环境执行。</p><p>​    而<strong>ART（Android Runtime）</strong> 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。ART 和 Dalvik 都是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。</p><p><a href="https://source.android.google.cn/devices/tech/dalvik/gc-debug" target="_blank" rel="noopener">https://source.android.google.cn/devices/tech/dalvik/gc-debug</a></p><h3 id="dexopt与dexaot"><a href="#dexopt与dexaot" class="headerlink" title="dexopt与dexaot"></a>dexopt与dexaot</h3><ul><li><p><strong>dexopt</strong>   </p><p>在<strong>Dalvik</strong>中虚拟机在加载一个dex文件时，对 dex 文件 进行 验证 和 优化的操作，其对 dex 文件的优化结果变成了 odex(Optimized dex) 文件，这个文件和 dex 文件很像，只是使用了一些优化操作码。</p></li><li><p><strong>dex2oat</strong></p><p><strong>ART 预先编译机制</strong>，在安装时对 dex 文件执行dexopt优化之后再将odex进行 AOT 提前编译操作，编译为OAT（实际上是ELF文件）可执行文件（机器码）。（相比做过ODEX优化，未做过优化的DEX转换成OAT要花费更长的时间）</p></li></ul><p><img src="//darryrzhong.xyz/2019/09/15/Android之热修复核心原理-ClassLoader类加载/1240-20200309133141482.png" alt="dex.png"></p><h2 id="ClassLoader介绍"><a href="#ClassLoader介绍" class="headerlink" title="ClassLoader介绍"></a>ClassLoader介绍</h2><p>​    任何一个 Java 程序都是由一个或多个 class 文件组成，在程序运行时，需要将 class 文件加载到 JVM 中才可以使用，负责加载这些 class 文件的就是 Java 的类加载机制。ClassLoader 的作用简单来说就是加载 class 文件，提供给程序运行时使用。每个 Class 对象的内部都有一个 classLoader 字段来标识自己是由哪个 ClassLoader 加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> ClassLoader classLoader;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ClassLoader是一个抽象类，而它的具体实现类主要有：</p><ul><li><p><code>BootClassLoader</code></p><p>用于加载Android Framework层class文件。</p></li><li><p><code>PathClassLoader</code></p><p>用于Android应用程序类加载器。可以加载指定的dex，以及jar、zip、apk中的classes.dex</p></li><li><p><code>DexClassLoader</code></p><p>用于加载指定的dex，以及jar、zip、apk中的classes.dex</p></li></ul><blockquote><p>很多博客里说PathClassLoader只能加载已安装的apk的dex，其实这说的应该是在dalvik虚拟机上。</p><p>但现在一般不用关心dalvik了。</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Log.e(TAG, <span class="string">"Activity.class 由："</span> + Activity.class.getClassLoader() +<span class="string">" 加载"</span>);</span><br><span class="line">Log.e(TAG, <span class="string">"MainActivity.class 由："</span> + getClassLoader() +<span class="string">" 加载"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">Activity.class 由：java.lang.BootClassLoader<span class="meta">@d</span>3052a9 加载</span><br><span class="line"></span><br><span class="line">MainActivity.class 由：dalvik.system.PathClassLoader[DexPathList[[zip file <span class="string">"/data/app/com.enjoy.enjoyfix-1/base.apk"</span>],nativeLibraryDirectories=[/data/app/com.enjoy.enjoyfix-<span class="number">1</span>/lib/x86, /system/lib, /vendor/lib]]] 加载</span><br></pre></td></tr></table></figure><p>  它们之间的关系如下：</p><p><img src="//darryrzhong.xyz/2019/09/15/Android之热修复核心原理-ClassLoader类加载/1240-20200309133151676.png" alt="ClassLoader.png"></p><p><code>PathClassLoader</code>与<code>DexClassLoader</code>的共同父类是<code>BaseDexClassLoader</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span></span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两者唯一的区别在于：创建<code>DexClassLoader</code>需要传递一个<code>optimizedDirectory</code>参数，并且会将其创建为<code>File</code>对象传给<code>super</code>，而<code>PathClassLoader</code>则直接给到null。因此两者都可以加载<strong>指定的dex，以及jar、zip、apk中的classes.dex</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader pathClassLoader = <span class="keyword">new</span> PathClassLoader(<span class="string">"/sdcard/xx.dex"</span>, getClassLoader());</span><br><span class="line"></span><br><span class="line">File dexOutputDir = context.getCodeCacheDir();</span><br><span class="line">DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(<span class="string">"/sdcard/xx.dex"</span>,dexOutputDir.getAbsolutePath(), <span class="keyword">null</span>,getClassLoader());</span><br></pre></td></tr></table></figure><p>​    其实,<code>optimizedDirectory</code>参数就是dexopt的产出目录(odex)。那<code>PathClassLoader</code>创建时，这个目录为null，就意味着不进行dexopt？并不是，<code>optimizedDirectory</code>为null时的默认路径为：<strong><em>/data/dalvik-cache</em></strong>。</p><blockquote><p>在API 26源码中，将DexClassLoader的optimizedDirectory标记为了 deprecated 弃用，实现也变为了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">&gt; String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>……和PathClassLoader一摸一样了！</p></blockquote><h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h3><p>​    可以看到创建<code>ClassLoader</code>需要接收一个<code>ClassLoader parent</code>参数。这个<code>parent</code>的目的就在于实现类加载的双亲委托。即：</p><p>​    某个类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查class是否有被加载  </span></span><br><span class="line">Class c = findLoadedClass(name);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果parent不为null，则调用parent的loadClass进行加载  </span></span><br><span class="line">c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//parent为null，则调用BootClassLoader进行加载  </span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果都找不到就自己查找</span></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因此我们自己创建的ClassLoader: <code>new PathClassLoader(&quot;/sdcard/xx.dex&quot;, getClassLoader());</code>并不仅仅只能加载 xx.dex中的class。</p></blockquote><p>​    </p><blockquote><p>值得注意的是：<code>c = findBootstrapClassOrNull(name);</code></p><p>按照方法名理解，应该是当parent为null时候，也能够加载<code>BootClassLoader</code>加载的类。</p><p><code>new PathClassLoader(&quot;/sdcard/xx.dex&quot;, null)</code>，能否加载Activity.class？</p><p>但是实际上，Android当中的实现为：（Java不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">private</span> Class <span class="title">findBootstrapClassOrNull</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h3><p>​    可以看到在所有父ClassLoader无法加载Class时，则会调用自己的<code>findClass</code>方法。<code>findClass</code>在ClassLoader中的定义为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    其实任何ClassLoader子类，都可以重写<code>loadClass</code>与<code>findClass</code>。一般如果你不想使用双亲委托，则重写<code>loadClass</code>修改其实现。而重写<code>findClass</code>则表示在双亲委托下，父ClassLoader都找不到Class的情况下，定义自己如何去查找一个Class。而我们的<code>PathClassLoader</code>会自己负责加载<code>MainActivity</code>这样的程序中自己编写的类，利用双亲委托父ClassLoader加载Framework中的<code>Activity</code>。说明<code>PathClassLoader</code>并没有重写<code>loadClass</code>，因此我们可以来看看PathClassLoader中的 <code>findClass</code> 是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,String </span></span></span><br><span class="line"><span class="function"><span class="params">librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, </span><br><span class="line">                                    optimizedDirectory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    <span class="comment">//查找指定的class</span></span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    实现非常简单，从<code>pathList</code>中查找class。继续查看<code>DexPathList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">    <span class="comment">// splitDexPath 实现为返回 List&lt;File&gt;.add(dexPath)</span></span><br><span class="line">    <span class="comment">// makeDexElements 会去 List&lt;File&gt;.add(dexPath) 中使用DexFile加载dex文件返回 Element数组</span></span><br><span class="line">    <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext);</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//从element中获得代表Dex的 DexFile</span></span><br><span class="line"><span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">DexFile dex = element.dexFile;</span><br><span class="line"><span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//查找class</span></span><br><span class="line">        Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">    suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="热修复"><a href="#热修复" class="headerlink" title="热修复"></a>热修复</h2><p>​    <code>PathClassLoader</code>中存在一个Element数组，Element类中存在一个dexFile成员表示dex文件，即：APK中有X个dex，则Element数组就有X个元素。</p><p><img src="//darryrzhong.xyz/2019/09/15/Android之热修复核心原理-ClassLoader类加载/1240-20200309133157869.png" alt="类查找.png"></p><p>​    在<code>PathClassLoader</code>中的Element数组为：[patch.dex , classes.dex , classes2.dex]。如果存在<strong>Key.class</strong>位于patch.dex与classes2.dex中都存在一份，当进行类查找时，循环获得<code>dexElements</code>中的DexFile，查找到了<strong>Key.class</strong>则立即返回，不会再管后续的element中的DexFile是否能加载到<strong>Key.class</strong>了。    </p><p>​    因此实际上，一种热修复实现可以将出现Bug的class单独的制作一份fix.dex文件(补丁包)，然后在程序启动时，从服务器下载fix.dex保存到某个路径，再通过fix.dex的文件路径，用其创建<code>Element</code>对象，然后将这个<code>Element</code>对象插入到我们程序的类加载器<code>PathClassLoader</code>的<code>pathList</code>中的<code>dexElements</code>数组头部。这样在加载出现Bug的class时会优先加载fix.dex中的修复类，从而解决Bug。</p><blockquote><p>热修复的方式不止这一种，并且如果要完整实现此种热修复可能还需要注意一些其他的问题(如：反射兼容)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-热修复核心原理，ClassLoader类加载&quot;&gt;&lt;a href=&quot;#Android-热修复核心原理，ClassLoader类加载&quot; class=&quot;headerlink&quot; title=&quot;Android 热修复核心原理，ClassLoader类加载&quot;&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="ClassLoader" scheme="http://darryrzhong.xyz/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>java系列之虚拟机的内存分配与回收机制</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/</id>
    <published>2019-09-15T08:49:34.000Z</published>
    <updated>2020-03-09T05:20:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习垃圾回收的意义"><a href="#学习垃圾回收的意义" class="headerlink" title="学习垃圾回收的意义"></a>学习垃圾回收的意义</h1><p>Java与C++等语言最大的技术区别：自动化的垃圾回收机制（GC）</p><p>为什么要了解GC和内存分配策略</p><p>1、面试需要</p><p>2、GC对应用的性能是有影响的；</p><p>3、写代码有好处</p><p>栈：栈中的生命周期是跟随线程，所以一般不需要关注</p><p>堆：堆中的对象是垃圾回收的重点</p><p>方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点</p><h1 id="GC案例"><a href="#GC案例" class="headerlink" title="GC案例"></a>GC案例</h1><p>自动回收机制也有失败的时候（Oom类）</p><p>-Xms  堆区内存初始内存分配的大小 </p><p>-Xmx  堆区内存可被分配的最大上限 </p><p>-XX:+PrintGCDetails </p><p>打印GC详情 </p><p>-XX:+HeapDumpOnOutOfMemoryError </p><p>当堆内存空间溢出时输出堆的内存快照 </p><h1 id="新生代配置"><a href="#新生代配置" class="headerlink" title="新生代配置"></a>新生代配置</h1><p>新生代大小配置参数的优先级：</p><p>中间 -Xmn  限定大小</p><p>-XX:SurvivorRatio </p><p>2个Survivor区和Eden区的比值</p><p>8 表示 两个Survivor ： Eden = 2： 8 ，每个Survivor占 1/10</p><p>可以修改为2</p><p>8 表示 两个Survivor ： Eden = 2： 2  ，各占一半</p><p>GC overhead limit exceeded 超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常</p><p>1.垃圾回收会占据资源</p><p>2.回收效率过低也会有限制</p><p>为什么new出的对象不会被回收了，我们来看看GC是如何判断对象的存活</p><h1 id="判断对象的存活"><a href="#判断对象的存活" class="headerlink" title="判断对象的存活"></a>判断对象的存活</h1><p>引用计数法：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否该回收。（PHP语言在用）</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/1240-20200309131912847.jpeg" alt="clip_image002.jpg"></p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>（<strong>面试时重要的知识点，牢记</strong>）</p><a id="more"></a><p>来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>作为GC Roots的对象包括下面几种：</p><p>l  虚拟机栈（栈帧中的本地变量表）中引用的对象。</p><p>l  方法区中类静态属性引用的对象。</p><p>l  方法区中常量引用的对象。</p><p>l  本地方法栈中JNI（即一般说的Native方法）引用的对象。</p><h1 id="各种引用"><a href="#各种引用" class="headerlink" title="各种引用"></a>各种引用</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>一般的Object obj = new Object() ，就属于强引用。</p><h2 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用 SoftReference"></a>软引用 SoftReference</h2><p>一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。参见代码：</p><p>VM参数 -Xms10m  -Xmx10m -XX:+PrintGC</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/1240-20200309131940882.jpeg" alt="clip_image004.jpg"></p><p>运行结果</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/1240-20200309131944401.jpeg" alt="clip_image006.jpg"></p><p>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p><h2 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用 WeakReference"></a>弱引用 WeakReference</h2><p>一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。</p><p>参看代码：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/1240-20200309131947566.jpeg" alt="clip_image008.jpg"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/1240-20200309131949999.jpeg" alt="clip_image010.jpg"></p><p><strong>注意：</strong>软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。</p><p>实际运用（WeakHashMap、ThreadLocal）</p><h2 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用 PhantomReference"></a>虚引用 PhantomReference</h2><p>幽灵引用，最弱，被垃圾回收的时候收到一个通知</p><h1 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h1><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p><p>注意：内存移动是必须实打实的移动（复制），不能使用指针玩。</p><p>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）</p><h1 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h1><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h1 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h1><p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h1 id="堆内存分配策略"><a href="#堆内存分配策略" class="headerlink" title="堆内存分配策略"></a>堆内存分配策略</h1><p><strong>对象优先在**</strong>Eden<strong>**分配</strong>，如果说Eden内存空间不足，就会发生Minor GC</p><p><strong>大对象直接进入老年代</strong>，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。</p><p>-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。</p><p><strong>长期存活的对象将进入老年代</strong>，默认15岁，-XX:MaxTenuringThreshold调整</p><p><strong>动态对象年龄判定，</strong>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p><p><strong>空间分配担保</strong>：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。</p><h1 id="把算法们都用上"><a href="#把算法们都用上" class="headerlink" title="把算法们都用上"></a>把算法们都用上</h1><p>jps -v</p><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><p><strong>请记住下图的垃圾收集器和之间的连线关系。</strong></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/strip.gif" alt="clip_image012.gif"></p><table><thead><tr><th><strong>收集器</strong></th><th><strong>收集对象和算法</strong></th><th><strong>收集器类型</strong></th><th><strong>说明</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>Serial</td><td>新生代，复制算法</td><td>单线程</td><td></td><td>简单高效；   适合内存不大的情况；</td></tr><tr><td>ParNew</td><td>新生代，复制算法</td><td>并行的多线程收集器</td><td>ParNew垃圾收集器是Serial收集器的多线程版本</td><td>搭配CMS垃圾回收器的首选</td></tr><tr><td>Parallel Scavenge   吞吐量优先收集器</td><td>新生代，复制算法</td><td>并行的多线程收集器</td><td>类似ParNew，更加关注吞吐量，达到一个可控制的吞吐量；</td><td>本身是Server级别多CPU机器上的默认GC方式，主要适合后台运算不需要太多交互的任务；</td></tr></tbody></table><table><thead><tr><th><strong>收集器</strong></th><th><strong>收集对象和算法</strong></th><th><strong>收集器类型</strong></th><th><strong>说明</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>Serial Old</td><td>老年代，标记整理算法</td><td>单线程</td><td></td><td>Client模式下虚拟机使用</td></tr><tr><td>Parallel Old</td><td>老年代，标记整理算法</td><td>并行的多线程收集器</td><td>Parallel Scavenge收集器的老年代版本，为了配合Parallel   Scavenge的面向吞吐量的特性而开发的对应组合；</td><td>在注重吞吐量以及CPU资源敏感的场合采用</td></tr><tr><td>CMS</td><td>老年代，标记清除算法</td><td>并行与并发收集器</td><td>尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：    1.内存碎片    2.需要更多cpu资源    3.浮动垃圾问题，需要更大的堆空间</td><td>重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器；</td></tr><tr><td>G1</td><td>跨新生代和老年代；标记整理 + 化整为零</td><td>并行与并发收集器</td><td>JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势；</td><td>面向服务端应用的垃圾回收器，目标为取代CMS</td></tr></tbody></table><p>并行：垃圾收集的多线程的同时进行。</p><p>并发：垃圾收集的多线程和应用的多线程同时进行。</p><p>注：吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)</p><p>垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间</p><h1 id="垃圾回收器工作示意图"><a href="#垃圾回收器工作示意图" class="headerlink" title="垃圾回收器工作示意图"></a>垃圾回收器工作示意图</h1><h2 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial/Serial Old"></a>Serial/Serial Old</h2><p>最古老的，单线程，独占式，成熟，适合单CPU  服务器</p><p>-XX:+UseSerialGC 新生代和老年代都用串行收集器</p><p>-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old</p><p>-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old</p><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少</p><p>-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old</p><h2 id="Parallel-Scavenge（ParallerGC）-Parallel-Old"><a href="#Parallel-Scavenge（ParallerGC）-Parallel-Old" class="headerlink" title="Parallel Scavenge（ParallerGC）/Parallel Old"></a>Parallel Scavenge（ParallerGC）/Parallel Old</h2><p>关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h2 id="Concurrent-Mark-Sweep-（CMS）"><a href="#Concurrent-Mark-Sweep-（CMS）" class="headerlink" title="Concurrent Mark Sweep （CMS）"></a>Concurrent Mark Sweep （CMS）</h2><p>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><p>l  <strong>初始标记</strong>-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</p><p>l  <strong>并发标记</strong>-和用户的应用程序同时进行，进行GC RootsTracing的过程</p><p>l  <strong>重新标记</strong>-短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>l  <strong>并发清除</strong></p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>-XX:+UseConcMarkSweepGC ，表示新生代使用ParNew，老年代的用CMS</p><p><strong>浮动垃圾：</strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p><img src="//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/strip-20200309131959999.gif" alt="clip_image014.gif"></p><p>-XX:+UseG1GC</p><p><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p><p><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p><p><strong>空间整合</strong>：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p><p><strong>内存布局：</strong>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p><p>n  新生代GC</p><p>回收Eden区和survivor区，回收后，所有eden区被清空，存在一个survivor区保存了部分数据。老年代区域会增多，因为部分新生代的对象会晋升到老年代。</p><p>n  并发标记周期 </p><p><strong>初始标记：</strong>短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，产生一个全局停顿，都伴随有一次新生代的GC。</p><p><strong>根区域扫描：</strong>扫描survivor区可以直接到达的老年代区域。</p><p><strong>并发标记阶段：</strong>扫描和查找整个堆的存活对象，并标记。</p><p><strong>重新标记：</strong>会产生全局停顿，对并发标记阶段的结果进行修正。</p><p><strong>独占清理</strong>：会产生全局停顿，对GC回收比例进行排序，供混合收集阶段使用</p><p><strong>并发清理</strong>：识别并清理完全空闲的区域，并发进行</p><p>n  混合收集 </p><p>对含有垃圾比例较高的Region进行回收。</p><p>G1当出现内存不足的的情况，也可能进行的FullGC回收。</p><p>G1中重要的参数：</p><p>-XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。</p><p>-XX:ParallerGCThreads：设置GC的工作线程数量</p><h1 id="Stop-The-World现象"><a href="#Stop-The-World现象" class="headerlink" title="Stop The World现象"></a>Stop The World现象</h1><p>GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。</p><h1 id="内存泄漏和内存溢出辨析"><a href="#内存泄漏和内存溢出辨析" class="headerlink" title="内存泄漏和内存溢出辨析"></a>内存泄漏和内存溢出辨析</h1><p>内存溢出：实实在在的内存空间不足导致；</p><p>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下。</p><h1 id="未来的垃圾回收"><a href="#未来的垃圾回收" class="headerlink" title="未来的垃圾回收"></a>未来的垃圾回收</h1><p>ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大我也是通过并发的时间去回收了</p><p>关键技术</p><ol><li><strong>有色指针（Colored      Pointers**</strong>）**</li><li><strong>加载屏障（Load      Barrier**</strong>）**</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习垃圾回收的意义&quot;&gt;&lt;a href=&quot;#学习垃圾回收的意义&quot; class=&quot;headerlink&quot; title=&quot;学习垃圾回收的意义&quot;&gt;&lt;/a&gt;学习垃圾回收的意义&lt;/h1&gt;&lt;p&gt;Java与C++等语言最大的技术区别：自动化的垃圾回收机制（GC）&lt;/p&gt;
&lt;p&gt;为什么要了解GC和内存分配策略&lt;/p&gt;
&lt;p&gt;1、面试需要&lt;/p&gt;
&lt;p&gt;2、GC对应用的性能是有影响的；&lt;/p&gt;
&lt;p&gt;3、写代码有好处&lt;/p&gt;
&lt;p&gt;栈：栈中的生命周期是跟随线程，所以一般不需要关注&lt;/p&gt;
&lt;p&gt;堆：堆中的对象是垃圾回收的重点&lt;/p&gt;
&lt;p&gt;方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点&lt;/p&gt;
&lt;h1 id=&quot;GC案例&quot;&gt;&lt;a href=&quot;#GC案例&quot; class=&quot;headerlink&quot; title=&quot;GC案例&quot;&gt;&lt;/a&gt;GC案例&lt;/h1&gt;&lt;p&gt;自动回收机制也有失败的时候（Oom类）&lt;/p&gt;
&lt;p&gt;-Xms  堆区内存初始内存分配的大小 &lt;/p&gt;
&lt;p&gt;-Xmx  堆区内存可被分配的最大上限 &lt;/p&gt;
&lt;p&gt;-XX:+PrintGCDetails &lt;/p&gt;
&lt;p&gt;打印GC详情 &lt;/p&gt;
&lt;p&gt;-XX:+HeapDumpOnOutOfMemoryError &lt;/p&gt;
&lt;p&gt;当堆内存空间溢出时输出堆的内存快照 &lt;/p&gt;
&lt;h1 id=&quot;新生代配置&quot;&gt;&lt;a href=&quot;#新生代配置&quot; class=&quot;headerlink&quot; title=&quot;新生代配置&quot;&gt;&lt;/a&gt;新生代配置&lt;/h1&gt;&lt;p&gt;新生代大小配置参数的优先级：&lt;/p&gt;
&lt;p&gt;中间 -Xmn  限定大小&lt;/p&gt;
&lt;p&gt;-XX:SurvivorRatio &lt;/p&gt;
&lt;p&gt;2个Survivor区和Eden区的比值&lt;/p&gt;
&lt;p&gt;8 表示 两个Survivor ： Eden = 2： 8 ，每个Survivor占 1/10&lt;/p&gt;
&lt;p&gt;可以修改为2&lt;/p&gt;
&lt;p&gt;8 表示 两个Survivor ： Eden = 2： 2  ，各占一半&lt;/p&gt;
&lt;p&gt;GC overhead limit exceeded 超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常&lt;/p&gt;
&lt;p&gt;1.垃圾回收会占据资源&lt;/p&gt;
&lt;p&gt;2.回收效率过低也会有限制&lt;/p&gt;
&lt;p&gt;为什么new出的对象不会被回收了，我们来看看GC是如何判断对象的存活&lt;/p&gt;
&lt;h1 id=&quot;判断对象的存活&quot;&gt;&lt;a href=&quot;#判断对象的存活&quot; class=&quot;headerlink&quot; title=&quot;判断对象的存活&quot;&gt;&lt;/a&gt;判断对象的存活&lt;/h1&gt;&lt;p&gt;引用计数法：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否该回收。（PHP语言在用）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之虚拟机的内存分配与回收机制/1240-20200309131912847.jpeg&quot; alt=&quot;clip_image002.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;可达性分析&quot;&gt;&lt;a href=&quot;#可达性分析&quot; class=&quot;headerlink&quot; title=&quot;可达性分析&quot;&gt;&lt;/a&gt;可达性分析&lt;/h2&gt;&lt;p&gt;（&lt;strong&gt;面试时重要的知识点，牢记&lt;/strong&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="虚拟机" scheme="http://darryrzhong.xyz/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>java系列之初始虚拟机</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E8%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之初识虚拟机/</id>
    <published>2019-09-15T08:43:08.000Z</published>
    <updated>2020-03-09T05:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要了解虚拟机"><a href="#为什么要了解虚拟机" class="headerlink" title="为什么要了解虚拟机"></a>为什么要了解虚拟机</h1><p>JVM不单单只支持Java语言，也支持其他语言（Scala、Kotlin、Groovy等等）</p><p>区块链2.0–以太坊(比特币是区块链1.0) 中提供了EVM的虚拟机，它的实现和JVM类似，基于栈、生成脚本编译成字节码来执行。知识通用。（理论大于实际）</p><h1 id="虚拟机历史"><a href="#虚拟机历史" class="headerlink" title="虚拟机历史"></a>虚拟机历史</h1><p>了解即可，无需关注</p><p>Hotspot什么意思：热点代码探测技术，及时编译器（发现最有价值的代码，如果代码用得非常多，就会把这些代码编译成本地代码）。</p><p>华为有的项目用的J9</p><p>谷歌(谷歌主要开发语言也是Java)：Google Android Dalivk VM,后面的课程会有单独的老师具体讲DVM，了解完JVM再去了解DVM就很容易。</p><h1 id="未来的Java技术"><a href="#未来的Java技术" class="headerlink" title="未来的Java技术"></a>未来的Java技术</h1><p><strong>模块化**</strong>:**使用得最多OSGI，应用层面就是微服务，互联网的发展方向</p><p><strong>混合语言</strong>：多个语言都可以运行在JVM中</p><p><strong>多核并行</strong>：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)</p><p><strong>丰富语法：</strong>JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource</p><p><strong>64**</strong>位：**虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位。</p><p><strong>更强的垃圾回收：</strong>JDK11 –ZGC（TB级别内存回收））：有色指针、加载屏障</p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）</p><p>计算器=指令+数据</p><p>虚拟机栈、本地方法栈(native方法)、程序计数器：指令相关</p><p>堆、方法：数据相关</p><a id="more"></a><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响（面试可能问到为什么需要）</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p><strong>栈：</strong>数据结构的特点和java中方法中调用方法的特性一致。（为什么JVM使用栈 –演示代码StackFilo）</p><p><strong>虚拟机栈：</strong>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。</p><p>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p><p><strong>局部变量表:</strong>顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。</p><p><strong>操作数据栈</strong>：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作</p><p><strong>动态连接:</strong>Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）</p><p><strong>返回地址:</strong>正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>各虚拟机自由实现，</p><h1 id="线程共享的区域"><a href="#线程共享的区域" class="headerlink" title="线程共享的区域"></a>线程共享的区域</h1><h2 id="方法区-永久代"><a href="#方法区-永久代" class="headerlink" title="方法区/永久代"></a>方法区/永久代</h2><p>用于存储已经被虚拟机加载的类信息，常量(“zdy”,”123”等)，静态变量(static变量)等数据，可用以下参数调整：</p><p>jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；</p><p>jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize</p><p>jdk1.8以后大小就只受本机总内存的限制</p><p>如：-XX:MaxMetaspaceSize=3M</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：</p><p>-Xms：堆的最小值；</p><p>-Xmx：堆的最大值；</p><p>-Xmn：新生代的大小；</p><p>-XX:NewSize；新生代最小值；</p><p>-XX:MaxNewSize：新生代最大值；</p><p>例如- Xmx256m</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；</p><p>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</p><h1 id="站在线程角度来看"><a href="#站在线程角度来看" class="headerlink" title="站在线程角度来看"></a>站在线程角度来看</h1><p><img src="//darryrzhong.xyz/2019/09/15/java系列之初识虚拟机/1240-20200309133536138.jpeg" alt="clip_image002.jpg"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之初识虚拟机/1240-20200309133538603.jpeg" alt="clip_image004.jpg"></p><h1 id="深入辨析堆和栈"><a href="#深入辨析堆和栈" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h1><p>n  <strong>功能</strong> </p><p>Ø 以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放； </p><p>Ø 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中； </p><p>n  <strong>线程独享还是共享</strong> </p><p>Ø 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。 </p><p>Ø 堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 </p><p>n  <strong>空间大小</strong> </p><p>栈的内存要远远小于堆内存</p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>参数：-Xss256k</p><p>java.lang.StackOverflowError  一般的方法调用是很难出现的，如果出现了要考虑是否有无限递归。</p><p>虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和非递归(循环来实现)都有存在的意义。递归代码简洁，非递归代码复杂但是速度较快。</p><h1 id="虚拟机中的对象"><a href="#虚拟机中的对象" class="headerlink" title="虚拟机中的对象"></a>虚拟机中的对象</h1><h2 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h2><p>虚拟机遇到一条new指令时：</p><h3 id="1）检查加载"><a href="#1）检查加载" class="headerlink" title="1）检查加载"></a>1）检查加载</h3><p>先执行相应的类加载过程。</p><h3 id="2）分配内存"><a href="#2）分配内存" class="headerlink" title="2）分配内存"></a>2）分配内存</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</p><h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”。</p><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h4><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><h5 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h5><p>解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；</p><h5 id="分配缓冲"><a href="#分配缓冲" class="headerlink" title="分配缓冲"></a>分配缓冲</h5><p>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。</p><p>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。</p><p>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p><h3 id="3）内存空间初始化"><a href="#3）内存空间初始化" class="headerlink" title="3）内存空间初始化"></a>3）内存空间初始化</h3><p>（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="4）设置"><a href="#4）设置" class="headerlink" title="4）设置"></a>4）设置</h3><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p><h3 id="5）对象初始化"><a href="#5）对象初始化" class="headerlink" title="5）对象初始化"></a>5）对象初始化</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。 </p><p>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。</p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><p>如果使用直接指针访问， reference中存储的直接就是对象地址。</p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p><h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><h2 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2><p>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。</p><p>栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</p><p>public void test(int x,inty ){</p><p>String x = “”;</p><p>User u = ….</p><p>….. </p><p>}</p><p>User类型的对象u就<strong>没有</strong>逃逸出方法test。</p><p>public  User test(int x,inty ){</p><p>String x = “”;</p><p>User u = ….</p><p>….. </p><p>return u;</p><p>}</p><p>User类型的对象u就逃逸出方法test。</p><h3 id="如何启用栈上分配"><a href="#如何启用栈上分配" class="headerlink" title="如何启用栈上分配"></a>如何启用栈上分配</h3><p>-server JVM运行的模式之一, server模式才能进行逃逸分析， JVM运行的模式还有mix/client</p><p>-Xmx10m和-Xms10m：堆的大小</p><p>-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)</p><p>-XX:+PrintGC：打印GC日志</p><p>-XX:+EliminateAllocations：标量替换(默认打开)</p><p>-XX:-UseTLAB 关闭本地线程分配缓冲</p><p>TLAB： ThreadLocalAllocBuffer，具体解释参见下文《虚拟机中的对象—对象的分配—-2）》</p><p>对栈上分配发生影响的参数就是三个，-server、-XX:+DoEscapeAnalysis和-XX:+EliminateAllocations，任何一个发生变化都不会发生栈上分配，因为启用逃逸分析和标量替换默认是打开的，所以，在我们的例子中，JVM的参数只用-server一样可以有栈上替换的效果(以King老师机器上JDK1.8为例，其他版本JDK请自行尝试)。</p><h3 id="栈上分配的效果"><a href="#栈上分配的效果" class="headerlink" title="栈上分配的效果"></a>栈上分配的效果</h3><p>同样的User的对象实例，分配100000000次，启用栈上分配，只需6ms，不启用，需要900多ms。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要了解虚拟机&quot;&gt;&lt;a href=&quot;#为什么要了解虚拟机&quot; class=&quot;headerlink&quot; title=&quot;为什么要了解虚拟机&quot;&gt;&lt;/a&gt;为什么要了解虚拟机&lt;/h1&gt;&lt;p&gt;JVM不单单只支持Java语言，也支持其他语言（Scala、Kotlin、Groovy等等）&lt;/p&gt;
&lt;p&gt;区块链2.0–以太坊(比特币是区块链1.0) 中提供了EVM的虚拟机，它的实现和JVM类似，基于栈、生成脚本编译成字节码来执行。知识通用。（理论大于实际）&lt;/p&gt;
&lt;h1 id=&quot;虚拟机历史&quot;&gt;&lt;a href=&quot;#虚拟机历史&quot; class=&quot;headerlink&quot; title=&quot;虚拟机历史&quot;&gt;&lt;/a&gt;虚拟机历史&lt;/h1&gt;&lt;p&gt;了解即可，无需关注&lt;/p&gt;
&lt;p&gt;Hotspot什么意思：热点代码探测技术，及时编译器（发现最有价值的代码，如果代码用得非常多，就会把这些代码编译成本地代码）。&lt;/p&gt;
&lt;p&gt;华为有的项目用的J9&lt;/p&gt;
&lt;p&gt;谷歌(谷歌主要开发语言也是Java)：Google Android Dalivk VM,后面的课程会有单独的老师具体讲DVM，了解完JVM再去了解DVM就很容易。&lt;/p&gt;
&lt;h1 id=&quot;未来的Java技术&quot;&gt;&lt;a href=&quot;#未来的Java技术&quot; class=&quot;headerlink&quot; title=&quot;未来的Java技术&quot;&gt;&lt;/a&gt;未来的Java技术&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;模块化**&lt;/strong&gt;:**使用得最多OSGI，应用层面就是微服务，互联网的发展方向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合语言&lt;/strong&gt;：多个语言都可以运行在JVM中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多核并行&lt;/strong&gt;：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;丰富语法：&lt;/strong&gt;JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;64**&lt;/strong&gt;位：**虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更强的垃圾回收：&lt;/strong&gt;JDK11 –ZGC（TB级别内存回收））：有色指针、加载屏障&lt;/p&gt;
&lt;h1 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h1&gt;&lt;p&gt;抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）&lt;/p&gt;
&lt;p&gt;计算器=指令+数据&lt;/p&gt;
&lt;p&gt;虚拟机栈、本地方法栈(native方法)、程序计数器：指令相关&lt;/p&gt;
&lt;p&gt;堆、方法：数据相关&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="虚拟机" scheme="http://darryrzhong.xyz/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>java系列之线程池原理与Android中AsyncTask</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8EAndroid%E4%B8%ADAsyncTask/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/</id>
    <published>2019-09-15T07:07:50.000Z</published>
    <updated>2019-09-15T08:33:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池原理与AsyncTask"><a href="#线程池原理与AsyncTask" class="headerlink" title="线程池原理与AsyncTask"></a>线程池原理与AsyncTask</h1><h2 id="什么是线程池？为什么要用线程池？"><a href="#什么是线程池？为什么要用线程池？" class="headerlink" title="什么是线程池？为什么要用线程池？"></a>什么是线程池？为什么要用线程池？</h2><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。线程池就是将线程进行池化，需要运行任务时从池中拿一个线程来执行，执行完毕，线程放回池中。</p><p>在开发过程中，合理地使用线程池能够带来3个好处。</p><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p><p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p><h2 id="JDK中的线程池和工作机制"><a href="#JDK中的线程池和工作机制" class="headerlink" title="JDK中的线程池和工作机制"></a>JDK中的线程池和工作机制</h2><h3 id="线程池的创建各个参数含义"><a href="#线程池的创建各个参数含义" class="headerlink" title="线程池的创建各个参数含义"></a>线程池的创建各个参数含义</h3><p>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</runnable></p><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；</p><p>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p><p>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p><h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p><h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p><h4 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h4><p>keepAliveTime的时间单位</p><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能</p><h5 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h5><p><strong>队列：</strong></p><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p><p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><p><strong>阻塞队列：</strong></p><p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p><p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 <img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image002.jpg" alt="img"></p><p>•抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</p><p>•返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p><p>•一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</p><p>•超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p><h5 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h5><p>•ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p><p>•LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</p><p>•PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</p><p>•DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p><p>•SynchronousQueue：一个不存储元素的阻塞队列。</p><p>•LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p><p>•LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”</p><h4 id="RejectedExecutionHandler（饱和策略）"><a href="#RejectedExecutionHandler（饱和策略）" class="headerlink" title="RejectedExecutionHandler（饱和策略）"></a>RejectedExecutionHandler（饱和策略）</h4><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p><p>（1）AbortPolicy：直接抛出异常，默认策略；</p><p>（2）CallerRunsPolicy：用调用者所在的线程来执行任务；</p><p>（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p><p>（4）DiscardPolicy：直接丢弃任务；</p><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><a id="more"></a><h3 id="线程池的工作机制"><a href="#线程池的工作机制" class="headerlink" title="线程池的工作机制"></a>线程池的工作机制</h3><p>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p><p>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p><p>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</p><p>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p><h2 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h2><p>要想合理地配置线程池，就必须首先分析任务特性</p><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p><p>•任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</p><p>•任务的优先级：高、中和低。</p><p>•任务的执行时间：长、中和短。</p><p>•任务的依赖性：是否依赖其他系统资源，如数据库连接。</p><p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><h3 id="为什么需要AsyncTask？"><a href="#为什么需要AsyncTask？" class="headerlink" title="为什么需要AsyncTask？"></a>为什么需要AsyncTask？</h3><p>在Android当中，当一个应用程序的组件启动的时候，并且没有其他的应用程序组件在运行时，Android系统就会为该应用程序组件开辟一个新的线程来执行。默认的情况下，在一个相同Android应用程序当中，其里面的组件都是运行在同一个线程里面的，这个线程我们称之为Main线程。当我们通过某个组件来启动另一个组件的时候，这个时候默认都是在同一个线程当中完成的。</p><p>在Android当中，通常将线程分为两种，一种叫做Main Thread，除了Main Thread之外的线程都可称为Worker Thread。</p><p>当一个应用程序运行的时候，Android操作系统就会给该应用程序启动一个线程，这个线程就是我们的Main Thread，这个线程非常的重要，它主要用来加载我们的UI界面，完成系统和我们用户之间的交互，并将交互后的结果又展示给我们用户，所以Main Thread又被称为UI Thread。</p><p>Android系统默认不会给我们的应用程序组件创建一个额外的线程，所有的这些组件默认都是在同一个线程中运行。然而，某些时候当我们的应用程序需要完成一个耗时的操作的时候，例如访问网络或者是对数据库进行查询时，此时我们的UI Thread就会被阻塞。例如，当我们点击一个Button，然后希望其从网络中获取一些数据，如果此操作在UI Thread当中完成的话，当我们点击Button的时候，UI线程就会处于阻塞的状态，此时，我们的系统不会调度任何其它的事件，更糟糕的是，当我们的整个现场如果阻塞时间超过5秒钟(官方是这样说的)，这个时候就会出现 ANR (Application Not Responding)的现象，此时，应用程序会弹出一个框，让用户选择是否退出该程序。对于Android开发来说，出现ANR的现象是绝对不能被允许的。</p><p>另外，由于我们的Android UI控件是线程不安全的，所以我们不能在UI Thread之外的线程当中对我们的UI控件进行操作。因此在Android的多线程编程当中，我们有两条非常重要的原则必须要遵守：</p><p>l  绝对不能在UI Thread当中进行耗时的操作，不能阻塞我们的UI Thread</p><p>l  不能在UI Thread之外的线程当中操纵我们的UI元素</p><p> 既然在Android当中有两条重要的原则要遵守，那么我们可能就有疑问了？我们既不能在主线程当中处理耗时的操作，又不能在工作线程中来访问我们的UI控件，那么我们比如从网络中要下载一张图片，又怎么能将其更新到UI控件上呢？这就关系到了我们的主线程和工作线程之间的通信问题了。在Android当中，提供了两种方式来解决线程直接的通信问题，一种是通过Handler的机制，这个时候就很可能自己会去封装一下thread+handler了，正是因为这类需求很多，google就帮我们封装了一下。其实我们也可以自己封装，但是我相信99%程序员自己封装的东西比不上google的。所以另外一种就是今天要详细讲解的 AsyncTask 机制。</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>AsyncTask是个abstract类，所以在使用时需要实现一个AsyncTask的具体实现类，一般来说会覆盖4个方法，我们以前面所说的从网络中下载一张图片，然后更新到UI控件来说明：</p><p>（1）onPreExecute()：在执行后台下载操作之前调用，将下载等待动画显示出来，运行在主线程中；</p><p>（2）doInBackground()：核心方法，执行后台下载操作的方法，必须实现的一个方法，运行在子线程中；这个方法是执行在子线程中的。在onPreExecute()执行完后，会立即开启这个方法。</p><p>（3）onProgressUpdate()：在下载操作doInBackground()中调用publishProgress()时的回调方法，用于更新下载进度，运行在主线程中；</p><p>（4）onPostExecute()：后台下载操作完成后调用，将下载等待动画进行隐藏，并更新UI，运行在主线程中；</p><p>然后在主线程中</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image004.jpg" alt="img"></p><p>通过上面的分析，我们可以知道，AsyncTask的构造方法和execute方法是我们分析AsyncTask的重点。</p><h4 id="1）构造方法"><a href="#1）构造方法" class="headerlink" title="1）构造方法"></a>1）构造方法</h4><p>AsyncTask的构造方法中<img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image006.jpg" alt="img"></p><p>mWorker代表了AsyncTask要执行的任务，是对Callable接口的封装，意味着这个任务是有返回值的</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image008.jpg" alt="img"></p><p>mFuture代表了AsyncTask要执行的任务的返回结果，其实就是个FutureTask，安装FutureTask标准用法，mWorker作为Callable被传给了mFuture，那么mFuture的结果就从mWorker执行的任务中取得。仔细看mWorker，return语句返回的结果就是我们前面所说的doInBackground()的执行结果：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image010.jpg" alt="img"></p><h4 id="2）再看执行流程"><a href="#2）再看执行流程" class="headerlink" title="2）再看执行流程"></a>2）再看执行流程</h4><p>查看源码execute()àexecuteOnExecutor(sDefaultExecutor, params)àexec.execute(mFuture)</p><p>到了这一步，将mFuture传递给了AsyncTask的执行器进行执行。AsyncTask的执行器缺省是sDefaultExecutor。</p><p>找到成员变量sDefaultExecutor，最终定位到</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image012.jpg" alt="img"></p><p>SerialExecutor是对JDK里Executor的一个实现，被声明为一个静态变量，我们仔细看SerialExecutor的实现，</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image014.jpg" alt="img"></p><p>内部声明了一个双端队列ArrayDeque类型的mTasks（双端队列中offer方法表示从队列尾插入，poll()表示从队列头获取元素）。</p><p>每次调用execute，就创建一个Runnable匿名内部类对象，这个对象存入mTasks，在匿名内部类的run函数里面调用传入参数r.run()。然后通过一个scheduleNext函数把mTasks里面的所有对象通过THREAD_POOL_EXECUTOR.execute(mActive)执行一遍。说穿了，也就是说SerialExecutor类会把所有的任务丢入一个容器，之后把容器里面的所有对象<strong>一个一个的排队（串行化）</strong>执行THREAD_POOL_EXECUTOR.execute(mActive);</p><p>至于这个THREAD_POOL_EXECUTOR，是这样定义的：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image016.jpg" alt="img"></p><p>我们可以看到这个线程池，被声明为一个静态变量，同时初始化的参数是：</p><p>核心线程数量，这里取得是CPU个数 + 1， 第二个参数是最大线程数量，这里是CPU个数 * 2 + 1，第五个参数是缓冲区的队列，这里是个LinkedBlockingQueue，这个队列的最大容量是128。</p><h4 id="3-结果和进度的通知"><a href="#3-结果和进度的通知" class="headerlink" title="3)结果和进度的通知"></a>3)结果和进度的通知</h4><p>AsyncTask的执行结果和进度是怎么通知给UI线程的呢？检视mFuture</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image018.jpg" alt="img"></p><p>和更新进度时我们会调用的publishProgress方法</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image020.jpg" alt="img"></p><p>我们可以看到都调用了sHandler</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image022.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image024.jpg" alt="img"></p><p>说明当子线程需要和UI线程进行通信时，其实就是通过这个handler，往UI线程发送消息。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1）、线程池的创建：</p><p>在创建了AsyncTask的时候，会默认创建两个线程池SerialExecutor和ThreadPoolExecutor，SerialExecutor负责将任务串行化，ThreadPoolExecutor是真正执行任务的地方，且无论有多少个AsyncTask实例，两个线程池都会只有一份。</p><p>2）、任务的执行：</p><p>在execute中，会执行run方法，当执行完run方法后，会调用scheduleNext()不断的从双端队列中轮询，获取下一个任务并继续放到一个子线程中执行，直到异步任务执行完毕。</p><p>3）、消息的处理：</p><p>在执行完onPreExecute()方法之后，执行了doInBackground()方法，然后就不断的发送请求获取数据；在这个AsyncTask中维护了一个InternalHandler的类，这个类是继承Handler的，获取的数据是通过handler进行处理和发送的。在其handleMessage方法中，将消息传递给onProgressUpdate()进行进度的更新，也就可以将结果发送到主线程中，进行界面的更新了。</p><p>4）、使用AsyncTask的注意点</p><p>通过观察代码我们可以发现，每一个new出的AsyncTask只能执行一次execute()方法，多次运行将会报错，如需多次，需要新new一个AsyncTask。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image026.jpg" alt="img"></p><h3 id="AsyncTask优缺点"><a href="#AsyncTask优缺点" class="headerlink" title="AsyncTask优缺点"></a>AsyncTask优缺点</h3><p><strong>AsyncTask**</strong>：**</p><p>优点：AsyncTask是一个轻量级的异步任务处理类，轻量级体现在，使用方便、代码简洁上，而且整个异步任务的过程可以通过cancel()进行控制；</p><p>缺点：不适用于处理长时间的异步任务，一般这个异步任务的过程最好控制在几秒以内，如果是长时间的异步任务就需要考虑多线程的控制问题；当处理多个异步任务时，UI更新变得困难。</p><p><strong>Handler:</strong></p><p>优点：代码结构清晰，容易处理多个异步任务；</p><p>缺点：当有多个异步任务时，由于要配合Thread或Runnable，代码可能会稍显冗余。</p><p><strong>总之，</strong>AsyncTask不失为一个非常好用的异步任务处理类，只要不是频繁对大量UI进行更新，可以考虑使用；而Handler在处理大量UI更新时可以考虑使用。</p><h1 id="补充知识：CAS"><a href="#补充知识：CAS" class="headerlink" title="补充知识：CAS"></a>补充知识：CAS</h1><h2 id="什么是原子操作？如何实现原子操作？"><a href="#什么是原子操作？如何实现原子操作？" class="headerlink" title="什么是原子操作？如何实现原子操作？"></a>什么是原子操作？如何实现原子操作？</h2><p>假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p><p>实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争（事实上CPU的主要工作并非这些），同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重</p><p>实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样罢了，<strong>每一个**</strong>CAS<strong><strong>操作过程都包含三个运算符：一个内存地址</strong></strong>V<strong><strong>，一个期望的值</strong></strong>A<strong><strong>和一个新值</strong></strong>B<strong><strong>，操作的时候如果这个地址上存放的值等于这个期望的值</strong></strong>A<strong><strong>，则将地址上的值赋为新值</strong></strong>B<strong>**，否则不做任何操作。</strong>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。<strong>循环**</strong>CAS<strong><strong>就是在一个循环里不断的做</strong></strong>CAS<strong>**操作，直到成功为止。</strong>怎么实现线程安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。</p><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p>1)  ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p><p>举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。</p><p>2)  循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>3)  只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环的方式来保证原子操作，但是对多个共享变量操作时，循环就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量＝，，合并一下，然后用来操作。从开始，提供了类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程池原理与AsyncTask&quot;&gt;&lt;a href=&quot;#线程池原理与AsyncTask&quot; class=&quot;headerlink&quot; title=&quot;线程池原理与AsyncTask&quot;&gt;&lt;/a&gt;线程池原理与AsyncTask&lt;/h1&gt;&lt;h2 id=&quot;什么是线程池？为什么要用线程池？&quot;&gt;&lt;a href=&quot;#什么是线程池？为什么要用线程池？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池？为什么要用线程池？&quot;&gt;&lt;/a&gt;什么是线程池？为什么要用线程池？&lt;/h2&gt;&lt;p&gt;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。线程池就是将线程进行池化，需要运行任务时从池中拿一个线程来执行，执行完毕，线程放回池中。&lt;/p&gt;
&lt;p&gt;在开发过程中，合理地使用线程池能够带来3个好处。&lt;/p&gt;
&lt;p&gt;第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/p&gt;
&lt;p&gt;第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。&lt;/p&gt;
&lt;p&gt;第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/p&gt;
&lt;h2 id=&quot;JDK中的线程池和工作机制&quot;&gt;&lt;a href=&quot;#JDK中的线程池和工作机制&quot; class=&quot;headerlink&quot; title=&quot;JDK中的线程池和工作机制&quot;&gt;&lt;/a&gt;JDK中的线程池和工作机制&lt;/h2&gt;&lt;h3 id=&quot;线程池的创建各个参数含义&quot;&gt;&lt;a href=&quot;#线程池的创建各个参数含义&quot; class=&quot;headerlink&quot; title=&quot;线程池的创建各个参数含义&quot;&gt;&lt;/a&gt;线程池的创建各个参数含义&lt;/h3&gt;&lt;p&gt;public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)&lt;/runnable&gt;&lt;/p&gt;
&lt;h4 id=&quot;corePoolSize&quot;&gt;&lt;a href=&quot;#corePoolSize&quot; class=&quot;headerlink&quot; title=&quot;corePoolSize&quot;&gt;&lt;/a&gt;corePoolSize&lt;/h4&gt;&lt;p&gt;线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；&lt;/p&gt;
&lt;p&gt;如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；&lt;/p&gt;
&lt;p&gt;如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。&lt;/p&gt;
&lt;h4 id=&quot;maximumPoolSize&quot;&gt;&lt;a href=&quot;#maximumPoolSize&quot; class=&quot;headerlink&quot; title=&quot;maximumPoolSize&quot;&gt;&lt;/a&gt;maximumPoolSize&lt;/h4&gt;&lt;p&gt;线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize&lt;/p&gt;
&lt;h4 id=&quot;keepAliveTime&quot;&gt;&lt;a href=&quot;#keepAliveTime&quot; class=&quot;headerlink&quot; title=&quot;keepAliveTime&quot;&gt;&lt;/a&gt;keepAliveTime&lt;/h4&gt;&lt;p&gt;线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用&lt;/p&gt;
&lt;h4 id=&quot;TimeUnit&quot;&gt;&lt;a href=&quot;#TimeUnit&quot; class=&quot;headerlink&quot; title=&quot;TimeUnit&quot;&gt;&lt;/a&gt;TimeUnit&lt;/h4&gt;&lt;p&gt;keepAliveTime的时间单位&lt;/p&gt;
&lt;h4 id=&quot;workQueue&quot;&gt;&lt;a href=&quot;#workQueue&quot; class=&quot;headerlink&quot; title=&quot;workQueue&quot;&gt;&lt;/a&gt;workQueue&lt;/h4&gt;&lt;p&gt;workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能&lt;/p&gt;
&lt;h5 id=&quot;什么是阻塞队列&quot;&gt;&lt;a href=&quot;#什么是阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;什么是阻塞队列&quot;&gt;&lt;/a&gt;什么是阻塞队列&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;队列：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。&lt;/p&gt;
&lt;p&gt;队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞队列：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。&lt;/p&gt;
&lt;p&gt;2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。&lt;/p&gt;
&lt;p&gt;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 &lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之线程池原理与Android中AsyncTask/clip_image002.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;•抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。&lt;/p&gt;
&lt;p&gt;•返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。&lt;/p&gt;
&lt;p&gt;•一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。&lt;/p&gt;
&lt;p&gt;•超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。&lt;/p&gt;
&lt;h5 id=&quot;常用阻塞队列&quot;&gt;&lt;a href=&quot;#常用阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;常用阻塞队列&quot;&gt;&lt;/a&gt;常用阻塞队列&lt;/h5&gt;&lt;p&gt;•ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。&lt;/p&gt;
&lt;p&gt;•LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。&lt;/p&gt;
&lt;p&gt;•PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。&lt;/p&gt;
&lt;p&gt;•DelayQueue：一个使用优先级队列实现的无界阻塞队列。&lt;/p&gt;
&lt;p&gt;•SynchronousQueue：一个不存储元素的阻塞队列。&lt;/p&gt;
&lt;p&gt;•LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。&lt;/p&gt;
&lt;p&gt;•LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。&lt;/p&gt;
&lt;h4 id=&quot;threadFactory&quot;&gt;&lt;a href=&quot;#threadFactory&quot; class=&quot;headerlink&quot; title=&quot;threadFactory&quot;&gt;&lt;/a&gt;threadFactory&lt;/h4&gt;&lt;p&gt;创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”&lt;/p&gt;
&lt;h4 id=&quot;RejectedExecutionHandler（饱和策略）&quot;&gt;&lt;a href=&quot;#RejectedExecutionHandler（饱和策略）&quot; class=&quot;headerlink&quot; title=&quot;RejectedExecutionHandler（饱和策略）&quot;&gt;&lt;/a&gt;RejectedExecutionHandler（饱和策略）&lt;/h4&gt;&lt;p&gt;线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：&lt;/p&gt;
&lt;p&gt;（1）AbortPolicy：直接抛出异常，默认策略；&lt;/p&gt;
&lt;p&gt;（2）CallerRunsPolicy：用调用者所在的线程来执行任务；&lt;/p&gt;
&lt;p&gt;（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；&lt;/p&gt;
&lt;p&gt;（4）DiscardPolicy：直接丢弃任务；&lt;/p&gt;
&lt;p&gt;当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="线程池原理" scheme="http://darryrzhong.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java系列之多线程与Android多线程性能优化</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EAndroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/</id>
    <published>2019-09-15T07:05:08.000Z</published>
    <updated>2019-09-15T08:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程与Android线程性能优化"><a href="#多线程与Android线程性能优化" class="headerlink" title="多线程与Android线程性能优化"></a>多线程与Android线程性能优化</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="CPU核心数和线程数的关系"><a href="#CPU核心数和线程数的关系" class="headerlink" title="CPU核心数和线程数的关系"></a>CPU核心数和线程数的关系</h3><p>多核心:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理</p><p>多线程: Simultaneous Multithreading.简称SMT.SMT可通过复制处理器上的结构状态,让同一个处理器上的多个线程同步执行并共享处理器的执行资源可最大限度地实现宽发射、乱序的超标量处理,提高处理器运算部件的利用率,缓和由于数据相关或 Cache未命中带来的访问内存延时。</p><p>核心数、线程数:目前主流CPU有双核、三核和四核,六核也在2010年发布。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系</p><h3 id="CPU时间片轮转机制"><a href="#CPU时间片轮转机制" class="headerlink" title="CPU时间片轮转机制"></a>CPU时间片轮转机制</h3><p>我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。</p><p>时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。</p><p>百度百科对CPU时间片轮转机制原理解释如下:</p><p>如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾</p><p>时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。</p><p>为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发</p><p>结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。</p><p>在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KⅢ掉的,我想也正是因为这种机制的缘故。</p><h3 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程"></a>什么是进程和线程</h3><p><strong>进程是程序运行资源分配的最小单位</strong></p><p>进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘10等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</p><p>进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</p><p><strong>线程是**</strong>cPU<strong><strong>调度的最小单位</strong></strong>,<strong>**必须依赖于进程而存在</strong></p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p><strong>线程无处不在</strong></p><p>任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。</p><h3 id="澄清并行和并发"><a href="#澄清并行和并发" class="headerlink" title="澄清并行和并发"></a>澄清并行和并发</h3><p>我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的<strong>并行</strong>车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。</p><p>当谈论<strong>并发</strong>的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。</p><p>俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。</p><p>综合来说：</p><p>并发:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.</p><p>并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行</p><p>两者区别:一个是交替执行,一个是同时执行.</p><h3 id="高并发编程的意义、好处和注意事项"><a href="#高并发编程的意义、好处和注意事项" class="headerlink" title="高并发编程的意义、好处和注意事项"></a>高并发编程的意义、好处和注意事项</h3><p>由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。</p><p>(1)充分利用CPU的资源</p><p>从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。</p><p>就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。</p><p>(2)加快响应用户的时间</p><p>比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。</p><p>我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。</p><p>(3)可以使你的代码模块化,异步化,简单化</p><p>例如我们在做 Android程序开发的时候,主线程的UI展示部分是一块主代码程序部分,但是UI上的按钮用相应事件的处理程序就可以做个单独的模块程序拿出来。这样既增加了异步的操,又使程序模块化,清晰化和简单化。</p><p>时下最流行的异步程序处理机制,正是多线程、并发程序最好的应用例子。</p><p>多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。</p><p>多线程程序需要注意事项</p><p>(1)线程之间的安全性</p><p>从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</p><p> (2)线程之间的死循环过程</p><p>为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。</p><p>假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生</p><p>(3)线程太多了会将服务器资源耗尽形成死机当机</p><p>线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?</p><p>某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。这里先有一个概念,后面会</p><p>多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。</p><h2 id="认识Java里的线程"><a href="#认识Java里的线程" class="headerlink" title="认识Java里的线程"></a>认识Java里的线程</h2><h3 id="Java里的程序天生就是多线程的"><a href="#Java里的程序天生就是多线程的" class="headerlink" title="Java里的程序天生就是多线程的"></a>Java里的程序天生就是多线程的</h3><p>一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。</p><p>[6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的</p><p>[5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等</p><p>[4] Signal Dispatcher  // 分发处理发送给JVM信号的线程</p><p>[3] Finalizer  // 调用对象finalize方法的线程</p><p>[2] Reference Handler//清除Reference的线程</p><p>[1] main //main线程，用户程序入口</p><h3 id="线程的启动与中止"><a href="#线程的启动与中止" class="headerlink" title="线程的启动与中止"></a>线程的启动与中止</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动线程的方式有：</p><p>1、X extends Thread;，然后X.run</p><p>2、X implements  Runnable；然后交给Thread运行</p><p>3、X implements  Callable；然后交给Thread运行</p><p>第1、2方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p>参见代码：cn.enjoyedu.concurrent.NewThread</p><h5 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h5><p>Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image002.jpg" alt="img"></p><p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image004.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image006.jpg" alt="img"></p><p>FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>事实上，FutureTask是Future接口的一个唯一实现类。</p><p>要new一个FutureTask的实例，有两种方法</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image008.jpg" alt="img"></p><h4 id="中止"><a href="#中止" class="headerlink" title="中止"></a>中止</h4><p>线程自然终止：要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。</p><p>手动中止</p><p>暂停、恢复和停止操作对应在线程Thread的API就是<strong>suspend()**</strong>、<strong><strong>resume()</strong></strong>和<strong>**stop()</strong>。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。</p><p>安全的中止则是其他线程通过调用某个线程A的<strong>interrupt()</strong>方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，线程通过方法<strong>isInterrupted()</strong>来进行判断是否被中断，也可以调用静态方法<strong>Thread.interrupted()</strong>来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。</p><p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。</p><p>不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如sleep等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</p><p><strong>注意：处于死锁状态的线程无法被中断</strong></p><h2 id="对Java里的线程再多一点点认识"><a href="#对Java里的线程再多一点点认识" class="headerlink" title="对Java里的线程再多一点点认识"></a>对Java里的线程再多一点点认识</h2><h3 id="深入理解run-和start"><a href="#深入理解run-和start" class="headerlink" title="深入理解run()和start()"></a>深入理解run()和start()</h3><p>Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。</p><p>start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用。</p><p>而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。</p><h3 id="其他的线程方法"><a href="#其他的线程方法" class="headerlink" title="其他的线程方法"></a>其他的线程方法</h3><p>yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p><p>join方法：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p><p>wait()/notify()/notifyAll()：后面会单独讲述</p><h2 id="线程间的共享和协作"><a href="#线程间的共享和协作" class="headerlink" title="线程间的共享和协作"></a>线程间的共享和协作</h2><h3 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h3><p>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。</p><p>Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><p>对象锁和类锁：</p><p>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。</p><p>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</p><h3 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h3><p>线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：</p><p>1）       难以确保及时性。</p><p>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</p><a id="more"></a><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><p>notify()：</p><p>通知一个在对象上等待的线程,使其从wait方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。</p><p>notifyAll()：</p><p>通知所有等待在该对象上的线程</p><p>wait()</p><p>调用该方法的线程进入 WAITING状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁</p><p>wait(long)</p><p>超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返回</p><p>wait (long,int)</p><p>对于超时时间更细粒度的控制,可以达到纳秒</p><h5 id="等待和通知的标准范式"><a href="#等待和通知的标准范式" class="headerlink" title="等待和通知的标准范式"></a>等待和通知的标准范式</h5><p>等待方遵循如下原则。</p><p>1）获取对象的锁。</p><p>2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p><p>3）条件满足则执行对应的逻辑。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image010.jpg" alt="img"></p><p>通知方遵循如下原则。</p><p>1）获得对象的锁。</p><p>2）改变条件。</p><p>3）通知所有等待在对象上的线程。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image012.jpg" alt="img"></p><p>在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法，进入wait（）方法后，当前线程释放锁，在从wait（）返回前，线程与其他线程竞争重新获得锁，notifyAll方法一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><h5 id="notify和notifyAll应该用谁"><a href="#notify和notifyAll应该用谁" class="headerlink" title="notify和notifyAll应该用谁"></a>notify和notifyAll应该用谁</h5><p>尽可能用notifyall()，谨慎使用notify()，看代码。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值, ThreadLocal往往用来实现变量在线程之间的隔离。</p><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p><p>• void set(Object value) </p><p>设置当前线程的线程局部变量的值。</p><p>• public Object get() </p><p>该方法返回当前线程所对应的线程局部变量。</p><p>• public void remove() </p><p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p><p>• protected Object initialValue() </p><p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p><p>public final static ThreadLocal<string> RESOURCE = new ThreadLocal<string>();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</string></string></p><h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><h3 id="Lock接口和synchronized的比较"><a href="#Lock接口和synchronized的比较" class="headerlink" title="Lock接口和synchronized的比较"></a>Lock接口和synchronized的比较</h3><p>我们一般的Java程序是靠synchronized关键字实现锁功能的，使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。synchronized属于Java语言层面的锁，也被称之为内置锁。</p><p>synchronized这种机制，一旦开始获取锁，是不能中断的，也不提供尝试获取锁的机制。</p><p>而Lock是由Java在语法层面提供的，锁的获取和释放需要我们明显的去获取，因此被称为显式锁。并且提供了synchronized不提供的机制。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image014.jpg" alt="img"></p><h3 id="Lock接口和核心方法"><a href="#Lock接口和核心方法" class="headerlink" title="Lock接口和核心方法"></a>Lock接口和核心方法</h3><p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image016.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image018.jpg" alt="img"></p><h3 id="可重入锁ReentrantLock、所谓锁的公平和非公平"><a href="#可重入锁ReentrantLock、所谓锁的公平和非公平" class="headerlink" title="可重入锁ReentrantLock、所谓锁的公平和非公平"></a>可重入锁ReentrantLock、所谓锁的公平和非公平</h3><p>而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p><p>公平和非公平锁 </p><p>如果在时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。</p><p>ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高。原因是，在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁,并且线程B请求这个锁。由于这个锁已被线程A持有,因此B将被挂起。当A释放锁时,B将被唤醒,因此会再次尝试获取锁。与此同时,如果C也请求这个锁,那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面:B获得锁的时刻并没有推迟,C更早地获得了锁,并且吞吐量也获得了提高。</p><h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>之前提到锁（synchronized和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量</p><h3 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。</p><p>用Lock和Condition实现等待通知</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image020.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程与Android线程性能优化&quot;&gt;&lt;a href=&quot;#多线程与Android线程性能优化&quot; class=&quot;headerlink&quot; title=&quot;多线程与Android线程性能优化&quot;&gt;&lt;/a&gt;多线程与Android线程性能优化&lt;/h1&gt;&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;h3 id=&quot;CPU核心数和线程数的关系&quot;&gt;&lt;a href=&quot;#CPU核心数和线程数的关系&quot; class=&quot;headerlink&quot; title=&quot;CPU核心数和线程数的关系&quot;&gt;&lt;/a&gt;CPU核心数和线程数的关系&lt;/h3&gt;&lt;p&gt;多核心:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理&lt;/p&gt;
&lt;p&gt;多线程: Simultaneous Multithreading.简称SMT.SMT可通过复制处理器上的结构状态,让同一个处理器上的多个线程同步执行并共享处理器的执行资源可最大限度地实现宽发射、乱序的超标量处理,提高处理器运算部件的利用率,缓和由于数据相关或 Cache未命中带来的访问内存延时。&lt;/p&gt;
&lt;p&gt;核心数、线程数:目前主流CPU有双核、三核和四核,六核也在2010年发布。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系&lt;/p&gt;
&lt;h3 id=&quot;CPU时间片轮转机制&quot;&gt;&lt;a href=&quot;#CPU时间片轮转机制&quot; class=&quot;headerlink&quot; title=&quot;CPU时间片轮转机制&quot;&gt;&lt;/a&gt;CPU时间片轮转机制&lt;/h3&gt;&lt;p&gt;我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。&lt;/p&gt;
&lt;p&gt;时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。&lt;/p&gt;
&lt;p&gt;百度百科对CPU时间片轮转机制原理解释如下:&lt;/p&gt;
&lt;p&gt;如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾&lt;/p&gt;
&lt;p&gt;时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。&lt;/p&gt;
&lt;p&gt;为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发&lt;/p&gt;
&lt;p&gt;结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。&lt;/p&gt;
&lt;p&gt;在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KⅢ掉的,我想也正是因为这种机制的缘故。&lt;/p&gt;
&lt;h3 id=&quot;什么是进程和线程&quot;&gt;&lt;a href=&quot;#什么是进程和线程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程和线程&quot;&gt;&lt;/a&gt;什么是进程和线程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程是程序运行资源分配的最小单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘10等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。&lt;/p&gt;
&lt;p&gt;进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程是**&lt;/strong&gt;cPU&lt;strong&gt;&lt;strong&gt;调度的最小单位&lt;/strong&gt;&lt;/strong&gt;,&lt;strong&gt;**必须依赖于进程而存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程无处不在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。&lt;/p&gt;
&lt;h3 id=&quot;澄清并行和并发&quot;&gt;&lt;a href=&quot;#澄清并行和并发&quot; class=&quot;headerlink&quot; title=&quot;澄清并行和并发&quot;&gt;&lt;/a&gt;澄清并行和并发&lt;/h3&gt;&lt;p&gt;我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的&lt;strong&gt;并行&lt;/strong&gt;车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。&lt;/p&gt;
&lt;p&gt;当谈论&lt;strong&gt;并发&lt;/strong&gt;的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。&lt;/p&gt;
&lt;p&gt;俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。&lt;/p&gt;
&lt;p&gt;综合来说：&lt;/p&gt;
&lt;p&gt;并发:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.&lt;/p&gt;
&lt;p&gt;并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行&lt;/p&gt;
&lt;p&gt;两者区别:一个是交替执行,一个是同时执行.&lt;/p&gt;
&lt;h3 id=&quot;高并发编程的意义、好处和注意事项&quot;&gt;&lt;a href=&quot;#高并发编程的意义、好处和注意事项&quot; class=&quot;headerlink&quot; title=&quot;高并发编程的意义、好处和注意事项&quot;&gt;&lt;/a&gt;高并发编程的意义、好处和注意事项&lt;/h3&gt;&lt;p&gt;由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。&lt;/p&gt;
&lt;p&gt;(1)充分利用CPU的资源&lt;/p&gt;
&lt;p&gt;从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。&lt;/p&gt;
&lt;p&gt;就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。&lt;/p&gt;
&lt;p&gt;(2)加快响应用户的时间&lt;/p&gt;
&lt;p&gt;比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。&lt;/p&gt;
&lt;p&gt;我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。&lt;/p&gt;
&lt;p&gt;(3)可以使你的代码模块化,异步化,简单化&lt;/p&gt;
&lt;p&gt;例如我们在做 Android程序开发的时候,主线程的UI展示部分是一块主代码程序部分,但是UI上的按钮用相应事件的处理程序就可以做个单独的模块程序拿出来。这样既增加了异步的操,又使程序模块化,清晰化和简单化。&lt;/p&gt;
&lt;p&gt;时下最流行的异步程序处理机制,正是多线程、并发程序最好的应用例子。&lt;/p&gt;
&lt;p&gt;多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。&lt;/p&gt;
&lt;p&gt;多线程程序需要注意事项&lt;/p&gt;
&lt;p&gt;(1)线程之间的安全性&lt;/p&gt;
&lt;p&gt;从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。&lt;/p&gt;
&lt;p&gt; (2)线程之间的死循环过程&lt;/p&gt;
&lt;p&gt;为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。&lt;/p&gt;
&lt;p&gt;假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生&lt;/p&gt;
&lt;p&gt;(3)线程太多了会将服务器资源耗尽形成死机当机&lt;/p&gt;
&lt;p&gt;线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?&lt;/p&gt;
&lt;p&gt;某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。这里先有一个概念,后面会&lt;/p&gt;
&lt;p&gt;多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。&lt;/p&gt;
&lt;h2 id=&quot;认识Java里的线程&quot;&gt;&lt;a href=&quot;#认识Java里的线程&quot; class=&quot;headerlink&quot; title=&quot;认识Java里的线程&quot;&gt;&lt;/a&gt;认识Java里的线程&lt;/h2&gt;&lt;h3 id=&quot;Java里的程序天生就是多线程的&quot;&gt;&lt;a href=&quot;#Java里的程序天生就是多线程的&quot; class=&quot;headerlink&quot; title=&quot;Java里的程序天生就是多线程的&quot;&gt;&lt;/a&gt;Java里的程序天生就是多线程的&lt;/h3&gt;&lt;p&gt;一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。&lt;/p&gt;
&lt;p&gt;[6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的&lt;/p&gt;
&lt;p&gt;[5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等&lt;/p&gt;
&lt;p&gt;[4] Signal Dispatcher  // 分发处理发送给JVM信号的线程&lt;/p&gt;
&lt;p&gt;[3] Finalizer  // 调用对象finalize方法的线程&lt;/p&gt;
&lt;p&gt;[2] Reference Handler//清除Reference的线程&lt;/p&gt;
&lt;p&gt;[1] main //main线程，用户程序入口&lt;/p&gt;
&lt;h3 id=&quot;线程的启动与中止&quot;&gt;&lt;a href=&quot;#线程的启动与中止&quot; class=&quot;headerlink&quot; title=&quot;线程的启动与中止&quot;&gt;&lt;/a&gt;线程的启动与中止&lt;/h3&gt;&lt;h4 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h4&gt;&lt;p&gt;启动线程的方式有：&lt;/p&gt;
&lt;p&gt;1、X extends Thread;，然后X.run&lt;/p&gt;
&lt;p&gt;2、X implements  Runnable；然后交给Thread运行&lt;/p&gt;
&lt;p&gt;3、X implements  Callable；然后交给Thread运行&lt;/p&gt;
&lt;p&gt;第1、2方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。&lt;/p&gt;
&lt;p&gt;参见代码：cn.enjoyedu.concurrent.NewThread&lt;/p&gt;
&lt;h5 id=&quot;Callable、Future和FutureTask&quot;&gt;&lt;a href=&quot;#Callable、Future和FutureTask&quot; class=&quot;headerlink&quot; title=&quot;Callable、Future和FutureTask&quot;&gt;&lt;/a&gt;Callable、Future和FutureTask&lt;/h5&gt;&lt;p&gt;Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。&lt;/p&gt;
&lt;p&gt;Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。&lt;/p&gt;
&lt;p&gt;Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image002.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image004.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image006.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;FutureTask类实现了RunnableFuture接口，RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。&lt;/p&gt;
&lt;p&gt;事实上，FutureTask是Future接口的一个唯一实现类。&lt;/p&gt;
&lt;p&gt;要new一个FutureTask的实例，有两种方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之多线程与Android多线程性能优化/clip_image008.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;中止&quot;&gt;&lt;a href=&quot;#中止&quot; class=&quot;headerlink&quot; title=&quot;中止&quot;&gt;&lt;/a&gt;中止&lt;/h4&gt;&lt;p&gt;线程自然终止：要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。&lt;/p&gt;
&lt;p&gt;手动中止&lt;/p&gt;
&lt;p&gt;暂停、恢复和停止操作对应在线程Thread的API就是&lt;strong&gt;suspend()**&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;resume()&lt;/strong&gt;&lt;/strong&gt;和&lt;strong&gt;**stop()&lt;/strong&gt;。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。&lt;/p&gt;
&lt;p&gt;安全的中止则是其他线程通过调用某个线程A的&lt;strong&gt;interrupt()&lt;/strong&gt;方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，线程通过方法&lt;strong&gt;isInterrupted()&lt;/strong&gt;来进行判断是否被中断，也可以调用静态方法&lt;strong&gt;Thread.interrupted()&lt;/strong&gt;来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。&lt;/p&gt;
&lt;p&gt;如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。&lt;/p&gt;
&lt;p&gt;不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如sleep等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：处于死锁状态的线程无法被中断&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;对Java里的线程再多一点点认识&quot;&gt;&lt;a href=&quot;#对Java里的线程再多一点点认识&quot; class=&quot;headerlink&quot; title=&quot;对Java里的线程再多一点点认识&quot;&gt;&lt;/a&gt;对Java里的线程再多一点点认识&lt;/h2&gt;&lt;h3 id=&quot;深入理解run-和start&quot;&gt;&lt;a href=&quot;#深入理解run-和start&quot; class=&quot;headerlink&quot; title=&quot;深入理解run()和start()&quot;&gt;&lt;/a&gt;深入理解run()和start()&lt;/h3&gt;&lt;p&gt;Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。&lt;/p&gt;
&lt;p&gt;start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用。&lt;/p&gt;
&lt;p&gt;而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。&lt;/p&gt;
&lt;h3 id=&quot;其他的线程方法&quot;&gt;&lt;a href=&quot;#其他的线程方法&quot; class=&quot;headerlink&quot; title=&quot;其他的线程方法&quot;&gt;&lt;/a&gt;其他的线程方法&lt;/h3&gt;&lt;p&gt;yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行。&lt;/p&gt;
&lt;p&gt;join方法：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。&lt;/p&gt;
&lt;p&gt;wait()/notify()/notifyAll()：后面会单独讲述&lt;/p&gt;
&lt;h2 id=&quot;线程间的共享和协作&quot;&gt;&lt;a href=&quot;#线程间的共享和协作&quot; class=&quot;headerlink&quot; title=&quot;线程间的共享和协作&quot;&gt;&lt;/a&gt;线程间的共享和协作&lt;/h2&gt;&lt;h3 id=&quot;线程间的共享&quot;&gt;&lt;a href=&quot;#线程间的共享&quot; class=&quot;headerlink&quot; title=&quot;线程间的共享&quot;&gt;&lt;/a&gt;线程间的共享&lt;/h3&gt;&lt;p&gt;线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。&lt;/p&gt;
&lt;p&gt;Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。&lt;/p&gt;
&lt;p&gt;对象锁和类锁：&lt;/p&gt;
&lt;p&gt;对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。&lt;/p&gt;
&lt;p&gt;但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。&lt;/p&gt;
&lt;h3 id=&quot;线程间的协作&quot;&gt;&lt;a href=&quot;#线程间的协作&quot; class=&quot;headerlink&quot; title=&quot;线程间的协作&quot;&gt;&lt;/a&gt;线程间的协作&lt;/h3&gt;&lt;p&gt;线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：&lt;/p&gt;
&lt;p&gt;1）       难以确保及时性。&lt;/p&gt;
&lt;p&gt;2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="多线程" scheme="http://darryrzhong.xyz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java系列之反射原理及动态代理模式</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/</id>
    <published>2019-09-15T07:03:22.000Z</published>
    <updated>2019-09-15T08:33:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射原理及动态代理模式"><a href="#反射原理及动态代理模式" class="headerlink" title="反射原理及动态代理模式"></a>反射原理及动态代理模式</h1><h2 id="反射（Reflect）"><a href="#反射（Reflect）" class="headerlink" title="反射（Reflect）"></a>反射（Reflect）</h2><p>反射之中包含了一个「反」字，所以了解反射我们先从「正」开始。</p><p>一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><p>反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。<strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><p>l  在运行时构造任意一个类的对象</p><p>l  在运行时获取任意一个类所具有的成员变量和方法</p><p>l  在运行时调用任意一个对象的方法（属性）</p><p>Java 是一门面向对象的语言。在面向对象的世界里，万事万物皆对象，既然万事万物皆对象，那么我们的类是不是对象呢？我们写的每一个类都可以看成一个对象，是 java.lang.Class 类的对象。每一个类对应的Class放在哪里呢？当我们写完一个类的Java文件，编译成class文件的时候，编译器都会将这个类的对应的class对象放在class文件的末尾。里面都保存了些什么？大家可以理解保存了类的元数据信息，一个类的元数据信息包括什么？有哪些属性，方法，构造器，实现了哪些接口等等，那么这些信息在Java里都有对应的类来表示。</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p><strong>Class**</strong>是一个类，封装了当前对象所对应的类的信息**</p><p>一个类中有属性，方法，构造器等，比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类，现在需要一个类，用来描述类，这就是Class，它应该有类名，属性，方法，构造器等。Class是用来描述类的类。</p><p>Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等</p><p>对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 </p><p>对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例</p><p>获取Class对象的三种方式</p><p>　　1.通过类名获取      类名.class    </p><p>　　2.通过对象获取      对象名.getClass()</p><p>　　3.通过全类名获取    Class.forName(全类名)</p><p>Class类的常用方法</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image002.jpg" alt="img"></p><h3 id="类加载器、构造器、Method、Field"><a href="#类加载器、构造器、Method、Field" class="headerlink" title="类加载器、构造器、Method、Field"></a>类加载器、构造器、Method、Field</h3><p>参见包cn.enjoyedu.refle.more下对应的类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image004.jpg" alt="img"></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="代理模式和静态代理"><a href="#代理模式和静态代理" class="headerlink" title="代理模式和静态代理"></a>代理模式和静态代理</h3><a id="more"></a><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p><p>举个例子来说明：张三想买某种用品，虽然他可以自己去找，但是这确实太浪费时间和精力了，或者不好意思去买。于是张三就通过中介Mark来买，Mark来帮张三，张三只是负责选择自己喜欢的的size，然后付钱就可以了。</p><p>目的：（1）通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性； （2）通过代理对象对原有的业务增强；</p><p>代理模式一般会有三个角色：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image006.jpg" alt="img"></p><p><strong>抽象角色</strong>：指代理角色和真实角色对外提供的公共方法，一般为一个接口</p><p><strong>真实角色</strong>：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业务逻辑在此。</p><p><strong>代理角色</strong>：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理！</p><p>而访问者不再访问真实角色，而是去访问代理角色。</p><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。一般来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。</p><p>静态代理，一对一则会出现时静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代理对象会出现扩展能力差的问题。</p><h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>是指在使用时再创建代理类和实例</p><p><strong>优点</strong></p><p>只需要1个动态代理类就可以解决创建多个静态代理的问题，避免重复、多余代码</p><p>更强的灵活性</p><p><strong>缺点</strong></p><p>效率低，相比静态代理中 直接调用目标对象方法，动态代理则需要先通过Java反射机制 从而 间接调用目标对象方法</p><p>应用场景局限，因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），即只能针对接口 创建 代理类，不能针对类创建代理类。</p><p>在java的动态代理机制中，有两个重要的类或接口，一个是InvocationHandler接口、另一个则是 Proxy类，这个类和接口是实现我们动态代理所必须用到的。</p><p>InvocationHandler接口是给动态代理类实现的，负责处理被代理对象的操作的，而Proxy是用来创建动态代理类实例对象的，因为只有得到了这个对象我们才能调用那些需要代理的方法。</p><p>具体使用，参见包cn.enjoyedu.proxy.dynamic下MarkCompany类</p><h4 id="动态代理实现原理"><a href="#动态代理实现原理" class="headerlink" title="动态代理实现原理"></a>动态代理实现原理</h4><p>通过调试模式我们发现，动态代理里，代理类的类名是这样的：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image008.jpg" alt="img"></p><p>这个代理类为何是这个名字？它是如何执行被代理对象的相关方法呢？我们在java文件编译后的目录里其实找不到这个名为$Proxy0的class文件的。</p><p>观察Proxy.<em>newProxyInstance</em>方法，与创建对象有关的代码主要有：</p><p>获得代理类的class对象：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image010.jpg" alt="img"></p><p>获得代理类的构造器：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image012.jpg" alt="img"></p><p>创建代理类的实例</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image014.jpg" alt="img"></p><p>看来其中的关键点就是如何获得代理类的class对象，我们进入<em>getProxyClass0</em>方法，进而进入<strong>proxyClassCache</strong>.get方法，通过这个这个方法所在的类名，我们可以推测，JDK内部使用了某种机制缓存了我们的代理类的class对象，同时get方法接受的参数是被代理类的类加载器和类实现的的接口。</p><p>在这个get方法中，除去和缓存相关的操作，同时用到了被代理类的类加载器和类实现的的接口这两个参数的是</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image016.jpg" alt="img"></p><p>我们再进入这个方法的实现，</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image018.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image020.jpg" alt="img"></p><p>而最终生成代理类的class对象是<em>defineClass0</em>方法，但是这个方法是个native方法，所以我们不去也无法深究它，但是通过这个方法的参数我们可以明显看到它接收了上面所生成的byte数组。</p><p>而我们通过ProxyUtils，这个自己写的工具类，将这个byte数组写入文件，我们并反编译，我们将会看到</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image022.jpg" alt="img"></p><p>同时我们还会看到其中实现了业务接口的方法</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image024.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image026.jpg" alt="img"></p><p>而h则来自派生类Proxy中</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image028.jpg" alt="img"></p><p>这个h的实例来自哪里？不就是我们在创建代理类的实例时传入的吗？</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image030.jpg" alt="img"></p><h4 id="使用了动态代理的-Retrofit"><a href="#使用了动态代理的-Retrofit" class="headerlink" title="使用了动态代理的`Retrofit"></a>使用了动态代理的`Retrofit</h4><p>Retrofit简单的说就是一个网络请求的适配器，它将一个基本的Java接口通过动态代理的方式翻译成一个HTTP请求，并通过OkHttp去发送请求。此外它还具有强大的可扩展性，支持各种格式转换以及RxJava。我们基于Retrofit2解析。</p><p>先定义一个名为X的java接口，当然里面有各种注解。</p><p>@FormUrlEncoded注解表示from表单，另外还有@Multipart等注解。@POST表示post请求，此外还可以使用@GET请求</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image032.jpg" alt="img"></p><p>然后如何使用的呢？</p><p>首先将域名传入构造一个Retrofit，然后通过retrofit中的create方法传入一个Java接口并得到一个x(当然x这个对象是经过处理了的)调用getPersonalListInfo(12)然后返回一个Call，最后这个Call调用了enqueue方法去异步请求http，这就是一个基本的Retrofit的网络请求。Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image034.jpg" alt="img"></p><p>我们只定义了一个接口X，并没有实现这个接口，那么它是如何工作的呢？我们看看create方法的实现。</p><p>create()方法是个泛型方法，调用它时会返回一个范型T的对象，我们这里类型是X接口，在内部实现上，很明显了使用了动态代理返回了一个X的代理类。当调用X内部方法的时候，会调用invoke方法。invoke方法内则通过内部一系列的封装最后返回一个Call对象。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image036.jpg" alt="img"></p><p>将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image038.jpg" alt="img"></p><p>上面这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，擦除动作导致这两种方法的特征签名变得一模一样。</p><p>由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此，JCP组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[3]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</p><p>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;反射原理及动态代理模式&quot;&gt;&lt;a href=&quot;#反射原理及动态代理模式&quot; class=&quot;headerlink&quot; title=&quot;反射原理及动态代理模式&quot;&gt;&lt;/a&gt;反射原理及动态代理模式&lt;/h1&gt;&lt;h2 id=&quot;反射（Reflect）&quot;&gt;&lt;a href=&quot;#反射（Reflect）&quot; class=&quot;headerlink&quot; title=&quot;反射（Reflect）&quot;&gt;&lt;/a&gt;反射（Reflect）&lt;/h2&gt;&lt;p&gt;反射之中包含了一个「反」字，所以了解反射我们先从「正」开始。&lt;/p&gt;
&lt;p&gt;一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。&lt;/p&gt;
&lt;p&gt;反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。&lt;strong&gt;反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。&lt;/p&gt;
&lt;p&gt;Java反射机制主要提供了以下功能：&lt;/p&gt;
&lt;p&gt;l  在运行时构造任意一个类的对象&lt;/p&gt;
&lt;p&gt;l  在运行时获取任意一个类所具有的成员变量和方法&lt;/p&gt;
&lt;p&gt;l  在运行时调用任意一个对象的方法（属性）&lt;/p&gt;
&lt;p&gt;Java 是一门面向对象的语言。在面向对象的世界里，万事万物皆对象，既然万事万物皆对象，那么我们的类是不是对象呢？我们写的每一个类都可以看成一个对象，是 java.lang.Class 类的对象。每一个类对应的Class放在哪里呢？当我们写完一个类的Java文件，编译成class文件的时候，编译器都会将这个类的对应的class对象放在class文件的末尾。里面都保存了些什么？大家可以理解保存了类的元数据信息，一个类的元数据信息包括什么？有哪些属性，方法，构造器，实现了哪些接口等等，那么这些信息在Java里都有对应的类来表示。&lt;/p&gt;
&lt;h3 id=&quot;Class类&quot;&gt;&lt;a href=&quot;#Class类&quot; class=&quot;headerlink&quot; title=&quot;Class类&quot;&gt;&lt;/a&gt;Class类&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Class**&lt;/strong&gt;是一个类，封装了当前对象所对应的类的信息**&lt;/p&gt;
&lt;p&gt;一个类中有属性，方法，构造器等，比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类，现在需要一个类，用来描述类，这就是Class，它应该有类名，属性，方法，构造器等。Class是用来描述类的类。&lt;/p&gt;
&lt;p&gt;Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等&lt;/p&gt;
&lt;p&gt;对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 &lt;/p&gt;
&lt;p&gt;对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例&lt;/p&gt;
&lt;p&gt;获取Class对象的三种方式&lt;/p&gt;
&lt;p&gt;　　1.通过类名获取      类名.class    &lt;/p&gt;
&lt;p&gt;　　2.通过对象获取      对象名.getClass()&lt;/p&gt;
&lt;p&gt;　　3.通过全类名获取    Class.forName(全类名)&lt;/p&gt;
&lt;p&gt;Class类的常用方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image002.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;类加载器、构造器、Method、Field&quot;&gt;&lt;a href=&quot;#类加载器、构造器、Method、Field&quot; class=&quot;headerlink&quot; title=&quot;类加载器、构造器、Method、Field&quot;&gt;&lt;/a&gt;类加载器、构造器、Method、Field&lt;/h3&gt;&lt;p&gt;参见包cn.enjoyedu.refle.more下对应的类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之反射原理及动态代理模式/clip_image004.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;h3 id=&quot;代理模式和静态代理&quot;&gt;&lt;a href=&quot;#代理模式和静态代理&quot; class=&quot;headerlink&quot; title=&quot;代理模式和静态代理&quot;&gt;&lt;/a&gt;代理模式和静态代理&lt;/h3&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="反射及动态代理" scheme="http://darryrzhong.xyz/tags/%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java系列之泛型</title>
    <link href="http://darryrzhong.xyz/2019/09/15/java%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B3%9B%E5%9E%8B/"/>
    <id>http://darryrzhong.xyz/2019/09/15/java系列之泛型/</id>
    <published>2019-09-15T06:59:38.000Z</published>
    <updated>2019-09-15T08:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的泛型"><a href="#Java中的泛型" class="headerlink" title="Java中的泛型"></a>Java中的泛型</h1><h2 id="为什么我们需要泛型？"><a href="#为什么我们需要泛型？" class="headerlink" title="为什么我们需要泛型？"></a>为什么我们需要泛型？</h2><p>通过两段代码我们就可以知道为何我们需要泛型</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image002.jpg" alt="img"></p><p>实际开发中，经常有数值类型求和的需求，例如实现int类型的加法, 有时候还需要实现long类型的求和, 如果还需要double类型的求和，需要重新在重载一个输入是double类型的add方法。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image004.jpg" alt="img"></p><p>定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</p><p> 在如上的编码过程中，我们发现主要存在两个问题：</p><p>1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</p><p>2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</p><p>所以泛型的好处就是：</p><p>l  适用于多种数据类型执行相同的代码</p><p>l  泛型中的类型在使用时指定，不需要强制类型转换</p><h2 id="泛型类和泛型接口"><a href="#泛型类和泛型接口" class="headerlink" title="泛型类和泛型接口"></a>泛型类和泛型接口</h2><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？</p><p>顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>引入一个类型变量T（其他大写字母都可以，不过常用的就是T，E，K，V等等），并且用&lt;&gt;括起来，并放在类名的后面。泛型类是允许有多个类型变量的。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image006.jpg" alt="img"><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image008.jpg" alt="img"></p><p>泛型接口与泛型类的定义基本相同。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image010.jpg" alt="img"></p><p>而实现泛型接口的类，有两种实现方法：</p><p>1、未传入泛型实参时：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image012.jpg" alt="img"></p><p>在new出类的实例时，需要指定具体类型：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image014.jpg" alt="img"></p><p>2、传入泛型实参</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image016.jpg" alt="img"></p><p>在new出类的实例时，和普通的类没区别。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p><strong><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image018.jpg" alt="img"></strong></p><p>泛型方法，是在调用方法的时候指明泛型的具体类型 ，泛型方法可以在任何地方和任何场景中使用，包括普通类和泛型类。注意泛型类中定义的普通方法和泛型方法的区别。</p><p>普通方法：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image020.jpg" alt="img"></p><p>泛型方法</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image022.jpg" alt="img"></p><h2 id="限定类型变量"><a href="#限定类型变量" class="headerlink" title="限定类型变量"></a>限定类型变量</h2><p>有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image024.jpg" alt="img"></p><p>请问，如果确保传入的两个变量一定有compareTo方法？那么解决这个问题的方案就是将T限制为实现了接口Comparable的类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image026.jpg" alt="img"></p><p>T <strong>extends</strong> Comparable中</p><p>T表示应该绑定类型的子类型，Comparable表示绑定类型，子类型和绑定类型可以是类也可以是接口。</p><p>如果这个时候，我们试图传入一个没有实现接口Comparable的类的实例，将会发生编译错误。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image028.jpg" alt="img"></p><p>同时extends左右都允许有多个，如 T,V <strong>extends</strong> Comparable &amp; Serializable</p><p>注意限定类型中，只允许有一个类，而且如果有类，这个类必须是限定列表的第一个。</p><p>这种类的限定既可以用在泛型方法上也可以用在泛型类上。</p><a id="more"></a><h2 id="泛型中的约束和局限性"><a href="#泛型中的约束和局限性" class="headerlink" title="泛型中的约束和局限性"></a>泛型中的约束和局限性</h2><p>现在我们有泛型类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image030.jpg" alt="img"></p><h3 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image032.jpg" alt="img"></p><h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image034.jpg" alt="img"></p><h3 id="泛型类的静态上下文中类型变量失效"><a href="#泛型类的静态上下文中类型变量失效" class="headerlink" title="泛型类的静态上下文中类型变量失效"></a>泛型类的静态上下文中类型变量失效</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image036.jpg" alt="img"></p><p>不能在静态域或方法中引用类型变量。因为泛型是要在对象创建的时候才知道是什么类型的，而对象创建的代码执行先后顺序是static的部分，然后才是构造函数等等。所以在对象初始化之前static的部分已经执行了，如果你在静态部分引用的泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。</p><h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image038.jpg" alt="img"></p><h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image040.jpg" alt="img"></p><h3 id="不能捕获泛型类的实例"><a href="#不能捕获泛型类的实例" class="headerlink" title="不能捕获泛型类的实例"></a>不能捕获泛型类的实例</h3><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image042.jpg" alt="img"></p><p>但是这样可以：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image044.jpg" alt="img"></p><h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><p>现在我们有一个类和子类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image046.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image048.jpg" alt="img"></p><p>有一个泛型类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image050.jpg" alt="img"></p><p>请问Pair<employee>和Pair<worker>是继承关系吗？</worker></employee></p><p>答案：不是，他们之间没有什么关系</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image052.jpg" alt="img"></p><p>但是泛型类可以继承或者扩展其他泛型类，比如List和ArrayList</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image054.jpg" alt="img"></p><h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><p>正是因为前面所述的，Pair<employee>和Pair<worker>没有任何关系，如果我们有一个泛型类和一个方法</worker></employee></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image056.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image058.jpg" alt="img"></p><p>现在我们有继承关系的类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image060.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image062.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image064.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image066.jpg" alt="img"></p><p>则会产生这种情况：</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image068.jpg" alt="img"></p><p>为解决这个问题，于是提出了一个通配符类型 ? </p><p>有两种使用方式：</p><p>？ extends X  表示类型的上界，类型参数是X的子类</p><p>？ super X  表示类型的下界，类型参数是X的超类</p><p>这两种 方式从名字上来看，特别是super，很有迷惑性，下面我们来仔细辨析这两种方法。</p><h3 id="？-extends-X"><a href="#？-extends-X" class="headerlink" title="？ extends X"></a>？ extends X</h3><p>表示传递给方法的参数，必须是X的子类（包括X本身）</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image070.jpg" alt="img"></p><p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法是不允许被调用的，会出现编译错误</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image072.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image074.jpg" alt="img"></p><p>get方法则没问题，会返回一个Fruit类型的值。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image076.jpg" alt="img"></p><p>为何？</p><p>道理很简单，？ extends X  表示类型的上界，类型参数是X的子类，那么可以肯定的说，get方法返回的一定是个X（不管是X或者X的子类）编译器是可以确定知道的。但是set方法只知道传入的是个X，至于具体是X的那个子类，不知道。</p><p>总结：主要用于安全地访问数据，可以访问X及其子类型，并且不能写入非null的数据。</p><h3 id="？-super-X"><a href="#？-super-X" class="headerlink" title="？ super X"></a>？ super X</h3><p>表示传递给方法的参数，必须是X的超类（包括X本身）</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image078.jpg" alt="img"></p><p>但是对泛型类GenericType来说，如果其中提供了get和set类型参数变量的方法的话，set方法可以被调用的，且能传入的参数只能是X或者X的子类</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image072.jpg" alt="img"></p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image080.jpg" alt="img"></p><p>get方法只会返回一个Object类型的值。</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image081.jpg" alt="img"></p><p>为何？</p><p>？ super  X  表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的超类，所以get方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X和X的子类可以安全的转型为X。</p><p>总结：主要用于安全地写入数据，可以写入X及其子类型。</p><h3 id="无限定的通配符"><a href="#无限定的通配符" class="headerlink" title="无限定的通配符 ?"></a>无限定的通配符 ?</h3><p>表示对类型没有什么限制，可以把？看成所有类型的父类，如Pair&lt; ?&gt;；</p><p>比如：</p><p>ArrayList<t> al=new ArrayList<t>(); 指定集合元素只能是T类型</t></t></p><p>ArrayList&lt;?&gt; al=new ArrayList&lt;?&gt;();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。</p><p>在使用上：</p><p>？ getFirst() ： 返回值只能赋给 Object，；</p><p>void setFirst(?) ： setFirst 方法不能被调用， 甚至不能用 Object 调用；</p><h2 id="虚拟机是如何实现泛型的？"><a href="#虚拟机是如何实现泛型的？" class="headerlink" title="虚拟机是如何实现泛型的？"></a>虚拟机是如何实现泛型的？</h2><p>泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。</p><p>泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</p><p>Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。</p><p>将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型</p><p><img src="//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image083.jpg" alt="img"></p><p>上面这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，擦除动作导致这两种方法的特征签名变得一模一样。</p><p>由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此，JCP组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[3]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</p><p>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java中的泛型&quot;&gt;&lt;a href=&quot;#Java中的泛型&quot; class=&quot;headerlink&quot; title=&quot;Java中的泛型&quot;&gt;&lt;/a&gt;Java中的泛型&lt;/h1&gt;&lt;h2 id=&quot;为什么我们需要泛型？&quot;&gt;&lt;a href=&quot;#为什么我们需要泛型？&quot; class=&quot;headerlink&quot; title=&quot;为什么我们需要泛型？&quot;&gt;&lt;/a&gt;为什么我们需要泛型？&lt;/h2&gt;&lt;p&gt;通过两段代码我们就可以知道为何我们需要泛型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image002.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;实际开发中，经常有数值类型求和的需求，例如实现int类型的加法, 有时候还需要实现long类型的求和, 如果还需要double类型的求和，需要重新在重载一个输入是double类型的add方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image004.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。&lt;/p&gt;
&lt;p&gt; 在如上的编码过程中，我们发现主要存在两个问题：&lt;/p&gt;
&lt;p&gt;1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。&lt;/p&gt;
&lt;p&gt;2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。&lt;/p&gt;
&lt;p&gt;所以泛型的好处就是：&lt;/p&gt;
&lt;p&gt;l  适用于多种数据类型执行相同的代码&lt;/p&gt;
&lt;p&gt;l  泛型中的类型在使用时指定，不需要强制类型转换&lt;/p&gt;
&lt;h2 id=&quot;泛型类和泛型接口&quot;&gt;&lt;a href=&quot;#泛型类和泛型接口&quot; class=&quot;headerlink&quot; title=&quot;泛型类和泛型接口&quot;&gt;&lt;/a&gt;泛型类和泛型接口&lt;/h2&gt;&lt;p&gt;泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？&lt;/p&gt;
&lt;p&gt;顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。&lt;/p&gt;
&lt;p&gt;泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。&lt;/p&gt;
&lt;p&gt;引入一个类型变量T（其他大写字母都可以，不过常用的就是T，E，K，V等等），并且用&amp;lt;&amp;gt;括起来，并放在类名的后面。泛型类是允许有多个类型变量的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image006.jpg&quot; alt=&quot;img&quot;&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image008.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;泛型接口与泛型类的定义基本相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image010.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;而实现泛型接口的类，有两种实现方法：&lt;/p&gt;
&lt;p&gt;1、未传入泛型实参时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image012.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在new出类的实例时，需要指定具体类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image014.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、传入泛型实参&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image016.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在new出类的实例时，和普通的类没区别。&lt;/p&gt;
&lt;h2 id=&quot;泛型方法&quot;&gt;&lt;a href=&quot;#泛型方法&quot; class=&quot;headerlink&quot; title=&quot;泛型方法&quot;&gt;&lt;/a&gt;泛型方法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image018.jpg&quot; alt=&quot;img&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;泛型方法，是在调用方法的时候指明泛型的具体类型 ，泛型方法可以在任何地方和任何场景中使用，包括普通类和泛型类。注意泛型类中定义的普通方法和泛型方法的区别。&lt;/p&gt;
&lt;p&gt;普通方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image020.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;泛型方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image022.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;限定类型变量&quot;&gt;&lt;a href=&quot;#限定类型变量&quot; class=&quot;headerlink&quot; title=&quot;限定类型变量&quot;&gt;&lt;/a&gt;限定类型变量&lt;/h2&gt;&lt;p&gt;有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image024.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;请问，如果确保传入的两个变量一定有compareTo方法？那么解决这个问题的方案就是将T限制为实现了接口Comparable的类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image026.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;T &lt;strong&gt;extends&lt;/strong&gt; Comparable中&lt;/p&gt;
&lt;p&gt;T表示应该绑定类型的子类型，Comparable表示绑定类型，子类型和绑定类型可以是类也可以是接口。&lt;/p&gt;
&lt;p&gt;如果这个时候，我们试图传入一个没有实现接口Comparable的类的实例，将会发生编译错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/09/15/java系列之泛型/clip_image028.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时extends左右都允许有多个，如 T,V &lt;strong&gt;extends&lt;/strong&gt; Comparable &amp;amp; Serializable&lt;/p&gt;
&lt;p&gt;注意限定类型中，只允许有一个类，而且如果有类，这个类必须是限定列表的第一个。&lt;/p&gt;
&lt;p&gt;这种类的限定既可以用在泛型方法上也可以用在泛型类上。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://darryrzhong.xyz/categories/java/"/>
    
    
      <category term="泛型" scheme="http://darryrzhong.xyz/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能优化系列二 : App启动优化</title>
    <link href="http://darryrzhong.xyz/2019/07/13/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E4%BA%8C-App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/</id>
    <published>2019-07-13T09:35:51.000Z</published>
    <updated>2020-03-09T05:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>#前言<br>本篇文章主要针对 Android性能优化 中App的启动优化</p><p>App启动,相信大家都是非常熟悉了,那为何我们需要对App启动做优化呢,这里就要先对我们Android 从开机到启动我们的App进入主页面这一流程做一个简单的阐述了.</p><h2 id="一、Android启动流程"><a href="#一、Android启动流程" class="headerlink" title="一、Android启动流程"></a>一、Android启动流程</h2><p>我们先来看一张流程图</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/1240-20200309132256657.png" alt="Android启动流程.png"></p><p>首先呢,我们Android手机开机时是先加载一个Boot程序,有点类似Windows开机时的开机引导程序,然后通过Boot程序加载Lux内核,随后是调用Native的init()方法做一些初始化加载操作(加载一些系统需要的驱动程序),然后就进入我们的java Framework层,也就是创建我们的java虚拟机,然后通过java虚拟机创建我们的系统程序,最后才是调用我们App的application启动我们的App.</p><p>流程如下:</p><blockquote><p>Loader &gt; Kernel &gt; Native &gt; Framework &gt; Application</p></blockquote><p>Android启动流程大致就是这样,我们不需要去深入,只需要大概知道是这么个流程就行了.</p><a id="more"></a><p>所以说,其实我们手机的操作系统就是一个App,开机启动时先加载各种驱动程序(类似App初始化各种第三方SDK),然后加载系统标识（黑白屏问题），然后启动开机欢迎动画(App欢迎页动画),最后进入到桌面(App主页面).</p><h2 id="二、App启动时黑白屏问题"><a href="#二、App启动时黑白屏问题" class="headerlink" title="二、App启动时黑白屏问题"></a>二、App启动时黑白屏问题</h2><p>基于以上的启动流程 ，那么App启动优化的第一步就是从系统标识入手，我们手机开机时一般最先出现的是手机厂商的logo标识，而App启动时会先调用一个预显示窗口，这个窗口的样式一般是黑色或者白色，所以也就出现了App启动时出现短暂的黑白屏问题，</p><p>流程如下：</p><blockquote><p> Application &gt; onCreate &gt; MainActivity &gt; onCreate &gt; windows &gt; setContentView&gt; layout</p></blockquote><p>在我们点击桌面App启动图标时，系统首先会给我们App分配一个进程，然后在调用我们的application入口，最后调用我们的mainActivity的setContentView方法加载布局文件，最后我们就能看到我们的主界面了。</p><p>然后在application 到MainActivity 之间，还会有一个预显示窗口，就是出现的黑白屏。</p><p>那我们怎么优化去除这个惹人厌的黑白屏呢？</p><p>我们先看一下这个黑白屏从哪蹦出来的。</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/1240-20200309132302546.png" alt="AppTheme.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/1240-20200309132305183.png" alt="image.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/1240-20200309132308114.png" alt="image.png"></p><p>看到了吧，最初我们可没有设置这么个东西，这是系统默认给我们App设置的，而且是白色的。</p><p>知道源头了，那就开始处理吧</p><h3 id="1-可以将背景设置为透明"><a href="#1-可以将背景设置为透明" class="headerlink" title="1.可以将背景设置为透明"></a>1.可以将背景设置为透明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>So easy ,就是这么简单,你在运行下App,果然黑白屏没有了,But 是不是有哪不对劲了.<br>对的,被你发现了,虽然黑白屏没了,但是我们的App似乎是变迟钝了</p><p>你在仔细观察一下,点击App启动图标后,App似乎是顿了一下,然后加载了我们的欢迎页面,有点像ANR,只不过很短暂 ,但是用户还是能够发现的,所以用户体验只是比起黑白屏好了那么一点点而已.</p><p>那就,继续优化呗</p><h3 id="2-给背景设置一张图片或者xml布局文件"><a href="#2-给背景设置一张图片或者xml布局文件" class="headerlink" title="2.给背景设置一张图片或者xml布局文件"></a>2.给背景设置一张图片或者xml布局文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowBackground&quot;&gt;@layout/activity_main&lt;/item&gt;</span><br><span class="line">   </span><br><span class="line">  或者</span><br><span class="line"></span><br><span class="line"> &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_bg&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>So easy,又是这么简单.对的,就是这么简单,这也是目前最认同的方案,稍微有点规模的公司都是采用这种方案来优化的.</p><p>But,这里需要注意的是,放一张图片的话,需要注意图片的大小,如果有虚拟导航键的话可能会出线底部闪烁问题,解决办法就是压缩图片大小,将图片转化成.9.png格式,让其自适应拉伸.</p><h2 id="三、onCreate-优化"><a href="#三、onCreate-优化" class="headerlink" title="三、onCreate()优化"></a>三、onCreate()优化</h2><p>一般我们都会重写自己的Application,然后在onCreate()方法内做一些初始化操作,<br>一般都是一些第三方SDK配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class App extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        </span><br><span class="line">        //......初始化第三方SDK</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以将一些较大的第三方库放在异步线程中进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   public void onCreate() &#123;</span><br><span class="line">       super.onCreate();</span><br><span class="line"></span><br><span class="line">       //懒加载</span><br><span class="line">       new Thread()&#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               super.run();</span><br><span class="line">               //初始化数据库</span><br><span class="line">               //初始化数据库 网络等操作</span><br><span class="line">               //......初始化第三方SDK</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是,如果涉及到UI操作的话,就不要放在异步线程中去执行,否则可能出Null<br>那我们怎么判断哪些初始化能够放在异步线程中呢,这个就需要你自己去分辨了,实在不知道就直接丢异步里,报错了就再丢出来就行了.</p><p>不止是Application中,我们的activity也可以用这种方式来进行优化.</p><p>以上这种优化也称为真优化,对代码层的优化我们叫做真优化,而不对代码层直接操作的我们称为伪优化,一般我们的优化方案都是两种混合使用.</p><h2 id="四、伪优化"><a href="#四、伪优化" class="headerlink" title="四、伪优化"></a>四、伪优化</h2><p>在我们做完上述的优化后,成功进入到主界面后,还没完.</p><p>你可能会发现进入主界面也会出现部分显示加载问题,具体就需要看你布局层级的复杂度和界面业务的需求了.如果是复杂页面,可以先看看布局文件层级是否还可以进行优化,然后在看是否时请求网络数据太大,例如加载了大图等. 这时就可以进去一定的伪优化了.</p><p>例如和产品协商在进入页面时加载一个dialog进行缓冲一下,很多App也是进去这样的优化,</p><p>看看我们的简书App就是这样,我基本每次进去都会弹一个dialog</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/240.png" alt="image.png"></p><blockquote><p>至此,App启动优化方案就介绍完了.当然还有更多优化方案,具体的就要根据业务需求而定了</p></blockquote><p>欢迎关注作者<a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">darryrzhong</a>,更多干货等你来拿哟.</p><h3 id="请赏个小红心！因为你的鼓励是我写作的最大动力！"><a href="#请赏个小红心！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请赏个小红心！因为你的鼓励是我写作的最大动力！"></a>请赏个小红心！因为你的鼓励是我写作的最大动力！</h3><blockquote><p>更多精彩文章请关注</p><ul><li><a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">个人博客:darryrzhong</a></li><li><a href="https://juejin.im/user/5a6c3b19f265da3e49804988" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/users/b7fdf53ec0b9/timeline" target="_blank" rel="noopener">简书</a></li><li><a href="https://segmentfault.com/u/darryrzhong_5ac59892a5882/articles" target="_blank" rel="noopener">SegmentFault</a></li><li><a href="https://www.imooc.com/u/6733207" target="_blank" rel="noopener">慕课网手记</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#前言&lt;br&gt;本篇文章主要针对 Android性能优化 中App的启动优化&lt;/p&gt;
&lt;p&gt;App启动,相信大家都是非常熟悉了,那为何我们需要对App启动做优化呢,这里就要先对我们Android 从开机到启动我们的App进入主页面这一流程做一个简单的阐述了.&lt;/p&gt;
&lt;h2 id=&quot;一、Android启动流程&quot;&gt;&lt;a href=&quot;#一、Android启动流程&quot; class=&quot;headerlink&quot; title=&quot;一、Android启动流程&quot;&gt;&lt;/a&gt;一、Android启动流程&lt;/h2&gt;&lt;p&gt;我们先来看一张流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/07/13/Android-性能优化系列二-App启动优化/1240-20200309132256657.png&quot; alt=&quot;Android启动流程.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先呢,我们Android手机开机时是先加载一个Boot程序,有点类似Windows开机时的开机引导程序,然后通过Boot程序加载Lux内核,随后是调用Native的init()方法做一些初始化加载操作(加载一些系统需要的驱动程序),然后就进入我们的java Framework层,也就是创建我们的java虚拟机,然后通过java虚拟机创建我们的系统程序,最后才是调用我们App的application启动我们的App.&lt;/p&gt;
&lt;p&gt;流程如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Loader &amp;gt; Kernel &amp;gt; Native &amp;gt; Framework &amp;gt; Application&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android启动流程大致就是这样,我们不需要去深入,只需要大概知道是这么个流程就行了.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="性能优化" scheme="http://darryrzhong.xyz/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能优化系列一 :APK极致优化</title>
    <link href="http://darryrzhong.xyz/2019/07/13/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%E4%B8%80-APK%E6%9E%81%E8%87%B4%E4%BC%98%E5%8C%96/"/>
    <id>http://darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/</id>
    <published>2019-07-13T06:53:18.000Z</published>
    <updated>2020-03-09T05:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要针对 Android性能优化 中 Android APK的大小优化</p><p>虽然现在网速已经非常快,用户流量也很多,但是对于我们的 Android apk 文件进行优化还是很有必要的,动不动几十上百兆的大小,用户体验还是很不好的,下面我们就来整理一下 Android apk 的优化方法</p><h2 id="一、icon-图标使用-svg"><a href="#一、icon-图标使用-svg" class="headerlink" title="一、icon 图标使用 svg"></a>一、icon 图标使用 svg</h2><p>在我们的App中会有很多icon,而且美工小姐姐一般都是成套的给,所以在我们的res文件中可能需要放入多套icon,这样一来就会使我们的apk文件体积变得非常大了,所以,优化的第一步就从icon 处理开始.</p><ul><li>icon 尽量使用svg 文件,而不要使用png文件</li></ul><blockquote><p>首先 svg 文件是以xml文件的方式存在的,占用空间小,而且能够根据设备屏幕自动伸缩不会失真.</p></blockquote><p>Android 本身是不支持直接导入svg文件的,所以我们需要将svg 文件进行转换一下.如下:</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132333631.png" alt="image.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132337297.png" alt="image.png"></p><p>使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ImageView</span><br><span class="line">        android:layout_marginTop=&quot;100dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_horizontal&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:src=&quot;@drawable/ic_icon_name&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"> &lt;ImageView</span><br><span class="line">        android:layout_marginTop=&quot;100dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_horizontal&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        app:srcCompat=&quot;@drawable/ic_icon_name&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、icon状态区分使用-Tint-着色器"><a href="#二、icon状态区分使用-Tint-着色器" class="headerlink" title="二、icon状态区分使用 Tint 着色器"></a>二、icon状态区分使用 Tint 着色器</h2><p>Tint着色器能够实现图片变色 ,利用Tint显示不同颜色的图片 ,在原本需要多张相同图片不同颜色的情况,能够减少apk的体积</p><p>UI效果如下:<br><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132340996.png" alt="image.png"></p><p>注意了,这是同一张图片的不同效果</p><p>使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">加上一行代码    android:tint=&quot;@color/colorAccent&quot;</span><br><span class="line"></span><br><span class="line"> &lt;ImageView</span><br><span class="line">        android:layout_marginTop=&quot;100dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_horizontal&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:src=&quot;@drawable/ic_icon_name&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:tint=&quot;@color/colorAccent&quot;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure><h2 id="三、需要多套不同尺寸的icon时-使用-svg"><a href="#三、需要多套不同尺寸的icon时-使用-svg" class="headerlink" title="三、需要多套不同尺寸的icon时,使用 svg"></a>三、需要多套不同尺寸的icon时,使用 svg</h2><p>Android studio 自带功能,可以自行配置需要的icon尺寸,打包时会自动生成对应尺寸的png 图片.</p><p>使用如下:<br>在app的build.graldle中的defaultConfig 标签下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">       applicationId &quot;com.example.apk&quot;</span><br><span class="line">       minSdkVersion 19</span><br><span class="line">       targetSdkVersion 28</span><br><span class="line">       versionCode 1</span><br><span class="line">       versionName &quot;1.0&quot;</span><br><span class="line">       testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">       //minSdkVersion 19 (5.0)</span><br><span class="line">       vectorDrawables.generatedDensities(&apos;xhdpi&apos;,&apos;xxhdpi&apos;,&apos;xxxhdpi&apos;)</span><br><span class="line">       //minSdkVersion &gt; 19</span><br><span class="line">     //  vectorDrawables.useSupportLibrary = true</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此时,drawable文件如下:<br><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132344690.png" alt="image.png"></p><p>打包后如下:</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132347381.png" alt="image.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132349524.png" alt="image.png"></p><p>以后APP内就只需要一套图就可解决多套图造成apk体积增大的问题了</p><h2 id="四、App内大图压缩-使用webp格式图片"><a href="#四、App内大图压缩-使用webp格式图片" class="headerlink" title="四、App内大图压缩,使用webp格式图片"></a>四、App内大图压缩,使用webp格式图片</h2><p>WebP格式，谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器宽带资源和数据空间。</p><p>使用如下:</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132352181.png" alt="image.png"></p><p>转化前后对比<br><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132356836.png" alt="image.png"></p><h2 id="五、-移除无用资源"><a href="#五、-移除无用资源" class="headerlink" title="五、 移除无用资源"></a>五、 移除无用资源</h2><ul><li>一键移除 (不推荐)<blockquote><p>一键移除未用到的资源,如果出现使用动态id加载资源会出现问题,而且这是物理删除,一旦删除将找不回了,所以能不用尽量别用,非要用请事先备份res文件.</p></blockquote></li></ul><p>使用如下</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132359270.png" alt="image.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132401125.png" alt="image.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132402986.png" alt="image.png"></p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132405054.png" alt="image.png"></p><ul><li>使用   shrinkResources  进行移除,配合 //Zipalign优化</li></ul><blockquote><p>使用 shrinkResources   必须先开启代码混淆 minifyEnabled</p></blockquote><p>使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">          //开启代码混淆</span><br><span class="line">            minifyEnabled true</span><br><span class="line">           //Zipalign优化</span><br><span class="line">            zipAlignEnabled true</span><br><span class="line">            //移除无用的resource文件</span><br><span class="line">            shrinkResources true</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打包后效果如下:<br><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132411744.png" alt="image.png"></p><p>虽然图片还存在. 但400多k的大小变成了2B</p><h2 id="六、资源打包设置"><a href="#六、资源打包设置" class="headerlink" title="六、资源打包设置"></a>六、资源打包设置</h2><p>由于第三方库的引入,如appcompat-v7的引入库中包含了大量的国际化资源,可根据自身业务进行相应保留和删除</p><p>原始包如下:</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132416697.png" alt="image.png"></p><p>原始包中存在各国的语言,所以我们一般只需要保留中文即可,配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> defaultConfig &#123;</span><br><span class="line">        applicationId &quot;com.zthx.xianglian&quot;</span><br><span class="line">        minSdkVersion 19</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">        //只保留指定和默认的资源</span><br><span class="line">        resConfigs(&apos;zh-rCN&apos;,&apos;ko&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置后如下:</p><p><img src="//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132418980.png" alt="image.png"></p><h2 id="七、动态库打包配置"><a href="#七、动态库打包配置" class="headerlink" title="七、动态库打包配置"></a>七、动态库打包配置</h2><p>如果项目中包含第三方SDK或者直接使用了NDK,如果不进行配置会自动打包全cpu架构的动态库进入apk,而对于真机,只需要保留一个armeabi或者armeabi-v7a就可以了,所以可以进行一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //配置so库架构(真机: arm ,模拟器 x86 )</span><br><span class="line">ndk &#123;</span><br><span class="line">           abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="八、开启代码混淆压缩"><a href="#八、开启代码混淆压缩" class="headerlink" title="八、开启代码混淆压缩"></a>八、开启代码混淆压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">       release &#123;</span><br><span class="line">          //源代码混淆开启</span><br><span class="line">           minifyEnabled true</span><br><span class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于代码混淆配置,这里就不再多说,不了解的可以自行去网上了解一下</p><blockquote><p>至此,apk 极致优化八道步骤就结束了,如果你的apk没有进行过任何优化,那么<br>这八道工序下来,目测你的apk体积至少缩减到一半,赶快 去试试这神奇的优化吧</p></blockquote><p>欢迎关注作者<a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">darryrzhong</a>,更多干货等你来拿哟.</p><h3 id="请赏个小红心！因为你的鼓励是我写作的最大动力！"><a href="#请赏个小红心！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请赏个小红心！因为你的鼓励是我写作的最大动力！"></a>请赏个小红心！因为你的鼓励是我写作的最大动力！</h3><blockquote><p>更多精彩文章请关注</p><ul><li><a href="http://www.darryrzhong.xyz" target="_blank" rel="noopener">个人博客:darryrzhong</a></li><li><a href="https://juejin.im/user/5a6c3b19f265da3e49804988" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/users/b7fdf53ec0b9/timeline" target="_blank" rel="noopener">简书</a></li><li><a href="https://segmentfault.com/u/darryrzhong_5ac59892a5882/articles" target="_blank" rel="noopener">SegmentFault</a></li><li><a href="https://www.imooc.com/u/6733207" target="_blank" rel="noopener">慕课网手记</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章主要针对 Android性能优化 中 Android APK的大小优化&lt;/p&gt;
&lt;p&gt;虽然现在网速已经非常快,用户流量也很多,但是对于我们的 Android apk 文件进行优化还是很有必要的,动不动几十上百兆的大小,用户体验还是很不好的,下面我们就来整理一下 Android apk 的优化方法&lt;/p&gt;
&lt;h2 id=&quot;一、icon-图标使用-svg&quot;&gt;&lt;a href=&quot;#一、icon-图标使用-svg&quot; class=&quot;headerlink&quot; title=&quot;一、icon 图标使用 svg&quot;&gt;&lt;/a&gt;一、icon 图标使用 svg&lt;/h2&gt;&lt;p&gt;在我们的App中会有很多icon,而且美工小姐姐一般都是成套的给,所以在我们的res文件中可能需要放入多套icon,这样一来就会使我们的apk文件体积变得非常大了,所以,优化的第一步就从icon 处理开始.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;icon 尽量使用svg 文件,而不要使用png文件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;首先 svg 文件是以xml文件的方式存在的,占用空间小,而且能够根据设备屏幕自动伸缩不会失真.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android 本身是不支持直接导入svg文件的,所以我们需要将svg 文件进行转换一下.如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132333631.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//darryrzhong.xyz/2019/07/13/Android-性能优化系列一-APK极致优化/1240-20200309132337297.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &amp;lt;ImageView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_marginTop=&amp;quot;100dp&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_gravity=&amp;quot;center_horizontal&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_centerInParent=&amp;quot;true&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:src=&amp;quot;@drawable/ic_icon_name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;lt;ImageView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_marginTop=&amp;quot;100dp&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_gravity=&amp;quot;center_horizontal&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_centerInParent=&amp;quot;true&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        app:srcCompat=&amp;quot;@drawable/ic_icon_name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://darryrzhong.xyz/categories/Android/"/>
    
    
      <category term="性能优化" scheme="http://darryrzhong.xyz/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
